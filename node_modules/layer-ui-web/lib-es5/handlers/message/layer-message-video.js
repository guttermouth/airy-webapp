/**
 * The Layer Video MessageHandler renders a single MessagePart Video, or an Atlas 3-message-part Video.
 *
 * As with all Message Handling, Message Height should be fixed at rendering time, and should not change asynchrnously
 * except in response to a user action.  Otherwise scroll positions get mucked and users get lost.
 * As a result, video heights should be fixed before any asynchronously loaded video or preview has loaded.
 *
 * @class layerUI.handlers.message.Video
 * @extends layerUI.components.Component
 */
'use strict';

var _component = require('../../components/component');

var _sizing = require('../../utils/sizing');

var _sizing2 = _interopRequireDefault(_sizing);

var _base = require('../../base');

var _messageHandler = require('../../mixins/message-handler');

var _messageHandler2 = _interopRequireDefault(_messageHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


(0, _component.registerMessageComponent)('layer-message-video', {
  mixins: [_messageHandler2.default],
  template: '<video layer-id="video"></video>',
  properties: {
    label: {
      value: '<i class="fa fa-file-video-o layer-video-message-icon" aria-hidden="true"></i> Video message'
    },

    /**
     * The Message property provides the MessageParts we are going to render.
     *
     * @property {layer.Message} [message=null]
     */
    message: {
      set: function set(value) {

        // Extract our video, preview and metadata message parts
        this.properties.video = value.parts.filter(function (part) {
          return part.mimeType === 'video/mp4';
        })[0];
        this.properties.preview = value.parts.filter(function (part) {
          return part.mimeType === 'image/jpeg+preview';
        })[0];
        var meta = value.parts.filter(function (part) {
          return part.mimeType === 'application/json+imageSize';
        })[0];
        if (meta) this.properties.meta = JSON.parse(meta.body);

        this.properties.sizes = (0, _sizing2.default)(this.properties.meta, {
          width: _base.settings.maxSizes.width,
          height: _base.settings.maxSizes.height
        });

        if (!this.properties.video.url) this.properties.video.fetchStream();
        this.properties.video.on('url-loaded', this.onRender, this);

        if (this.properties.preview) {
          if (!this.properties.preview.url) this.properties.preview.fetchStream();
          this.properties.preview.on('url-loaded', this.onRender, this);
        }
      }
    }
  },
  methods: {
    handlesMessage: function handlesMessage(message, container) {
      var videoParts = message.parts.filter(function (part) {
        return part.mimeType === 'video/mp4';
      }).length;
      var previewParts = message.parts.filter(function (part) {
        return part.mimeType === 'image/jpeg+preview';
      }).length;
      var metaParts = message.parts.filter(function (part) {
        return part.mimeType === 'application/json+imageSize';
      }).length;
      return message.parts.length === 1 && videoParts || message.parts.length === 3 && videoParts === 1 && previewParts === 1 && metaParts === 1;
    },


    /**
     * Render the Message.
     *
     * Primarily, this method determines whether to call renderCanvas on the preview or the image.
     *
     * @method
     * @private
     */
    onRender: function onRender() {
      this.nodes.video.width = this.properties.sizes.width;
      this.nodes.video.height = this.properties.sizes.height;
      this.nodes.video.src = this.properties.video.url;
      if (this.properties.preview) {
        this.nodes.video.poster = this.properties.preview.url;
      }
      this.nodes.video.controls = true;
    }
  }
});