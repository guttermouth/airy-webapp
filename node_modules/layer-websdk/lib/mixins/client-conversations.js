'use strict';

/**
 * Adds Conversation handling to the layer.Client.
 *
 * @class layer.mixins.ClientConversations
 */

var Conversation = require('../models/conversation');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * One or more layer.Conversation objects have been added to the client.
   *
   * They may have been added via the websocket, or via the user creating
   * a new Conversation locally.
   *
   *      client.on('conversations:add', function(evt) {
   *          evt.conversations.forEach(function(conversation) {
   *              myView.addConversation(conversation);
   *          });
   *      });
   *
   * @event conversations_add
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation[]} evt.conversations - Array of conversations added
   */
  'conversations:add',

  /**
   * One or more layer.Conversation objects have been removed.
   *
   * A removed Conversation is not necessarily deleted, its just
   * no longer being held in local memory.
   *
   * Note that typically you will want the conversations:delete event
   * rather than conversations:remove.
   *
   *      client.on('conversations:remove', function(evt) {
   *          evt.conversations.forEach(function(conversation) {
   *              myView.removeConversation(conversation);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation[]} evt.conversations - Array of conversations removed
   */
  'conversations:remove',

  /**
   * The conversation is now on the server.
   *
   * Called after creating the conversation
   * on the server.  The Result property is one of:
   *
   * * layer.Conversation.CREATED: A new Conversation has been created
   * * layer.Conversation.FOUND: A matching Distinct Conversation has been found
   * * layer.Conversation.FOUND_WITHOUT_REQUESTED_METADATA: A matching Distinct Conversation has been found
   *                       but note that the metadata is NOT what you requested.
   *
   * All of these results will also mean that the updated property values have been
   * copied into your Conversation object.  That means your metadata property may no
   * longer be its initial value; it will be the value found on the server.
   *
   *      client.on('conversations:sent', function(evt) {
   *          switch(evt.result) {
   *              case Conversation.CREATED:
   *                  alert(evt.target.id + ' Created!');
   *                  break;
   *              case Conversation.FOUND:
   *                  alert(evt.target.id + ' Found!');
   *                  break;
   *              case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
   *                  alert(evt.target.id + ' Found, but does not have the requested metadata!');
   *                  break;
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} event
   * @param {string} event.result
   * @param {layer.Conversation} target
   */
  'conversations:sent',

  /**
   * A conversation failed to load or create on the server.
   *
   *      client.on('conversations:sent-error', function(evt) {
   *          alert(evt.data.message);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.data
   * @param {layer.Conversation} target
   */
  'conversations:sent-error',

  /**
   * A conversation had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('conversations:change', function(evt) {
   *          var metadataChanges = evt.getChangesFor('metadata');
   *          var participantChanges = evt.getChangesFor('participants');
   *          if (metadataChanges.length) {
   *              myView.renderTitle(evt.target.metadata.title);
   *          }
   *          if (participantChanges.length) {
   *              myView.renderParticipants(evt.target.participants);
   *          }
   *      });
   *
   * NOTE: Typically such rendering is done using Events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'conversations:change',

  /**
   * A call to layer.Conversation.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   */
  'conversations:loaded',

  /**
   * A Conversation has been deleted from the server.
   *
   * Caused by either a successful call to layer.Conversation.delete() on the Conversation
   * or by a remote user.
   *
   *      client.on('conversations:delete', function(evt) {
   *          myView.removeConversation(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Conversation} evt.target
   */
  'conversations:delete'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.conversations = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.conversations).forEach(function (id) {
        var conversation = _this._models.conversations[id];
        if (conversation && !conversation.isDestroyed) {
          conversation.destroy();
        }
      });
      this._models.conversations = null;
    },
    reset: function reset() {
      this._models.conversations = {};
    }
  },
  methods: {
    /**
     * Retrieve a conversation by Identifier.
     *
     *      var c = client.getConversation('layer:///conversations/uuid');
     *
     * If there is not a conversation with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Conversation instance that has no data; the `conversations:loaded` / `conversations:loaded-error` events
     * will let you know when the conversation has finished/failed loading from the server.
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          // Render the Conversation with all of its details loaded
     *          myrerender(c);
     *      });
     *      // Render a placeholder for c until the details of c have loaded
     *      myrender(c);
     *
     * Note in the above example that the `conversations:loaded` event will trigger even if the Conversation has previously loaded.
     *
     * @method getConversation
     * @param  {string} id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a conversation from
     *                                    the server if not found
     * @return {layer.Conversation}
     */
    getConversation: function getConversation(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      if (!Conversation.isValidId(id)) {
        id = Conversation.prefixUUID + id;
      }
      if (this._models.conversations[id]) {
        return this._models.conversations[id];
      } else if (canLoad) {
        return Conversation.load(id, this);
      }
      return null;
    },


    /**
     * Adds a conversation to the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _addConversation for you:
     *
     *      var conv = new layer.Conversation({
     *          client: client,
     *          participants: ['a', 'b']
     *      });
     *
     *      // OR:
     *      var conv = client.createConversation(['a', 'b']);
     *
     * @method _addConversation
     * @protected
     * @param  {layer.Conversation} c
     */
    _addConversation: function _addConversation(conversation) {
      var id = conversation.id;
      if (!this._models.conversations[id]) {
        // Register the Conversation
        this._models.conversations[id] = conversation;

        // Make sure the client is set so that the next event bubbles up
        if (conversation.clientId !== this.appId) conversation.clientId = this.appId;
        this._triggerAsync('conversations:add', { conversations: [conversation] });

        this._scheduleCheckAndPurgeCache(conversation);
      }
    },


    /**
     * Removes a conversation from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeConversation for you:
     *
     *      conversation.destroy();
     *
     * @method _removeConversation
     * @protected
     * @param  {layer.Conversation} c
     */
    _removeConversation: function _removeConversation(conversation) {
      var _this2 = this;

      // Insure we do not get any events, such as message:remove
      conversation.off(null, null, this);

      if (this._models.conversations[conversation.id]) {
        delete this._models.conversations[conversation.id];
        this._triggerAsync('conversations:remove', { conversations: [conversation] });
      }

      // Remove any Message associated with this Conversation
      Object.keys(this._models.messages).forEach(function (id) {
        if (_this2._models.messages[id].conversationId === conversation.id) {
          _this2._models.messages[id].destroy();
        }
      });
    },


    /**
     * If the Conversation ID changes, we need to reregister the Conversation
     *
     * @method _updateConversationId
     * @protected
     * @param  {layer.Conversation} conversation - Conversation whose ID has changed
     * @param  {string} oldId - Previous ID
     */
    _updateConversationId: function _updateConversationId(conversation, oldId) {
      var _this3 = this;

      if (this._models.conversations[oldId]) {
        this._models.conversations[conversation.id] = conversation;
        delete this._models.conversations[oldId];

        // This is a nasty way to work... but need to find and update all
        // conversationId properties of all Messages or the Query's won't
        // see these as matching the query.
        Object.keys(this._models.messages).filter(function (id) {
          return _this3._models.messages[id].conversationId === oldId;
        }).forEach(function (id) {
          return _this3._models.messages[id].conversationId = conversation.id;
        });
      }
    },


    /**
     * Searches locally cached conversations for a matching conversation.
     *
     * Iterates over conversations calling a matching function until
     * the conversation is found or all conversations tested.
     *
     *      var c = client.findCachedConversation(function(conversation) {
     *          if (conversation.participants.indexOf('a') != -1) return true;
     *      });
     *
     * @method findCachedConversation
     * @param  {Function} f - Function to call until we find a match
     * @param  {layer.Conversation} f.conversation - A conversation to test
     * @param  {boolean} f.return - Return true if the conversation is a match
     * @param  {Object} [context] - Optional context for the *this* object
     * @return {layer.Conversation}
     *
     * @deprecated
     * This should be replaced by iterating over your layer.Query data.
     */
    findCachedConversation: function findCachedConversation(func, context) {
      var test = context ? func.bind(context) : func;
      var list = Object.keys(this._models.conversations);
      var len = list.length;
      for (var index = 0; index < len; index++) {
        var key = list[index];
        var conversation = this._models.conversations[key];
        if (test(conversation, index)) return conversation;
      }
      return null;
    },


    /**
     * This method is recommended way to create a Conversation.
     *
     * There are a few ways to invoke it; note that the default behavior is to create a Distinct Conversation
     * unless otherwise stated via the layer.Conversation.distinct property.
     *
     *         client.createConversation({participants: ['a', 'b']});
     *         client.createConversation({participants: [userIdentityA, userIdentityB]});
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             distinct: false
     *         });
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             metadata: {
     *                 title: 'I am a title'
     *             }
     *         });
     *
     * If you try to create a Distinct Conversation that already exists,
     * you will get back an existing Conversation, and any requested metadata
     * will NOT be set; you will get whatever metadata the matching Conversation
     * already had.
     *
     * The default value for distinct is `true`.
     *
     * Whether the Conversation already exists or not, a 'conversations:sent' event
     * will be triggered asynchronously and the Conversation object will be ready
     * at that time.  Further, the event will provide details on the result:
     *
     *       var conversation = client.createConversation({
     *          participants: ['a', 'b'],
     *          metadata: {
     *            title: 'I am a title'
     *          }
     *       });
     *       conversation.on('conversations:sent', function(evt) {
     *           switch(evt.result) {
     *               case Conversation.CREATED:
     *                   alert(conversation.id + ' was created');
     *                   break;
     *               case Conversation.FOUND:
     *                   alert(conversation.id + ' was found');
     *                   break;
     *               case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
     *                   alert(conversation.id + ' was found but it already has a title so your requested title was not set');
     *                   break;
     *            }
     *       });
     *
     * Warning: This method will throw an error if called when you are not (or are no longer) an authenticated user.
     * That means if authentication has expired, and you have not yet reauthenticated the user, this will throw an error.
     *
     *
     * @method createConversation
     * @param  {Object} options
     * @param {string[]/layer.Identity[]} participants - Array of UserIDs or UserIdentities
     * @param {Boolean} [options.distinct=true] Is this a distinct Conversation?
     * @param {Object} [options.metadata={}] Metadata for your Conversation
     * @return {layer.Conversation}
     */
    createConversation: function createConversation(options) {
      // If we aren't authenticated, then we don't yet have a UserID, and won't create the correct Conversation
      if (!this.isAuthenticated) throw new Error(ErrorDictionary.clientMustBeReady);
      if (!('distinct' in options)) options.distinct = true;
      options.client = this;
      return Conversation.create(options);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taXhpbnMvY2xpZW50LWNvbnZlcnNhdGlvbnMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0FBTUEsSUFBTSxlQUFlLFFBQVEsd0JBQVIsQ0FBckI7QUFDQSxJQUFNLGtCQUFrQixRQUFRLGdCQUFSLEVBQTBCLFVBQWxEOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFVBQVE7QUFDTjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxxQkFqQk07O0FBbUJOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLHdCQXRDTTs7QUF3Q047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0Esc0JBMUVNOztBQTRFTjs7Ozs7Ozs7Ozs7O0FBWUEsNEJBeEZNOztBQTBGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBLHdCQXJITTs7QUF1SE47Ozs7Ozs7QUFPQSx3QkE5SE07O0FBZ0lOOzs7Ozs7Ozs7Ozs7OztBQWNBLHdCQTlJTSxDQURPO0FBaUpmLGFBQVc7QUFDVCxlQURTLHVCQUNHLE9BREgsRUFDWTtBQUNuQixXQUFLLE9BQUwsQ0FBYSxhQUFiLEdBQTZCLEVBQTdCO0FBQ0QsS0FIUTtBQUlULFdBSlMscUJBSUM7QUFBQTs7QUFDUixhQUFPLElBQVAsQ0FBWSxLQUFLLE9BQUwsQ0FBYSxhQUF6QixFQUF3QyxPQUF4QyxDQUFnRCxVQUFDLEVBQUQsRUFBUTtBQUN0RCxZQUFNLGVBQWUsTUFBSyxPQUFMLENBQWEsYUFBYixDQUEyQixFQUEzQixDQUFyQjtBQUNBLFlBQUksZ0JBQWdCLENBQUMsYUFBYSxXQUFsQyxFQUErQztBQUM3Qyx1QkFBYSxPQUFiO0FBQ0Q7QUFDRixPQUxEO0FBTUEsV0FBSyxPQUFMLENBQWEsYUFBYixHQUE2QixJQUE3QjtBQUNELEtBWlE7QUFjVCxTQWRTLG1CQWNEO0FBQ04sV0FBSyxPQUFMLENBQWEsYUFBYixHQUE2QixFQUE3QjtBQUNEO0FBaEJRLEdBakpJO0FBbUtmLFdB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QXRCLEVBQTBCLGNBQTFCLEdBQTJDLGFBQWEsRUFBL0Q7QUFBQSxTQUZmO0FBR0Q7QUFDRixLQTNITTs7O0FBOEhQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQSwwQkFsSk8sa0NBa0pnQixJQWxKaEIsRUFrSnNCLE9BbEp0QixFQWtKK0I7QUFDcEMsVUFBTSxPQUFPLFVBQVUsS0FBSyxJQUFMLENBQVUsT0FBVixDQUFWLEdBQStCLElBQTVDO0FBQ0EsVUFBTSxPQUFPLE9BQU8sSUFBUCxDQUFZLEtBQUssT0FBTCxDQUFhLGFBQXpCLENBQWI7QUFDQSxVQUFNLE1BQU0sS0FBSyxNQUFqQjtBQUNBLFdBQUssSUFBSSxRQUFRLENBQWpCLEVBQW9CLFFBQVEsR0FBNUIsRUFBaUMsT0FBakMsRUFBMEM7QUFDeEMsWUFBTSxNQUFNLEtBQUssS0FBTCxDQUFaO0FBQ0EsWUFBTSxlQUFlLEtBQUssT0FBTCxDQUFhLGFBQWIsQ0FBMkIsR0FBM0IsQ0FBckI7QUFDQSxZQUFJLEtBQUssWUFBTCxFQUFtQixLQUFuQixDQUFKLEVBQStCLE9BQU8sWUFBUDtBQUNoQztBQUNELGFBQU8sSUFBUDtBQUNELEtBNUpNOzs7QUE4SlA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStEQSxzQkE3Tk8sOEJBNk5ZLE9BN05aLEVBNk5xQjtBQUMxQjtBQUNBLFVBQUksQ0FBQyxLQUFLLGVBQVYsRUFBMkIsTUFBTSxJQUFJLEtBQUosQ0FBVSxnQkFBZ0IsaUJBQTFCLENBQU47QUFDM0IsVUFBSSxFQUFFLGNBQWMsT0FBaEIsQ0FBSixFQUE4QixRQUFRLFFBQVIsR0FBbUIsSUFBbkI7QUFDOUIsY0FBUSxNQUFSLEdBQWlCLElBQWpCO0FBQ0EsYUFBTyxhQUFhLE1BQWIsQ0FBb0IsT0FBcEIsQ0FBUDtBQUNEO0FBbk9NO0FBbktNLENBQWpCIiwiZmlsZSI6ImNsaWVudC1jb252ZXJzYXRpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZGRzIENvbnZlcnNhdGlvbiBoYW5kbGluZyB0byB0aGUgbGF5ZXIuQ2xpZW50LlxuICpcbiAqIEBjbGFzcyBsYXllci5taXhpbnMuQ2xpZW50Q29udmVyc2F0aW9uc1xuICovXG5cbmNvbnN0IENvbnZlcnNhdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9jb252ZXJzYXRpb24nKTtcbmNvbnN0IEVycm9yRGljdGlvbmFyeSA9IHJlcXVpcmUoJy4uL2xheWVyLWVycm9yJykuZGljdGlvbmFyeTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV2ZW50czogW1xuICAgIC8qKlxuICAgICAqIE9uZSBvciBtb3JlIGxheWVyLkNvbnZlcnNhdGlvbiBvYmplY3RzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogVGhleSBtYXkgaGF2ZSBiZWVuIGFkZGVkIHZpYSB0aGUgd2Vic29ja2V0LCBvciB2aWEgdGhlIHVzZXIgY3JlYXRpbmdcbiAgICAgKiBhIG5ldyBDb252ZXJzYXRpb24gbG9jYWxseS5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdjb252ZXJzYXRpb25zOmFkZCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIGV2dC5jb252ZXJzYXRpb25zLmZvckVhY2goZnVuY3Rpb24oY29udmVyc2F0aW9uKSB7XG4gICAgICogICAgICAgICAgICAgIG15Vmlldy5hZGRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKTtcbiAgICAgKiAgICAgICAgICB9KTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50IGNvbnZlcnNhdGlvbnNfYWRkXG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBldnQuY29udmVyc2F0aW9ucyAtIEFycmF5IG9mIGNvbnZlcnNhdGlvbnMgYWRkZWRcbiAgICAgKi9cbiAgICAnY29udmVyc2F0aW9uczphZGQnLFxuXG4gICAgLyoqXG4gICAgICogT25lIG9yIG1vcmUgbGF5ZXIuQ29udmVyc2F0aW9uIG9iamVjdHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBBIHJlbW92ZWQgQ29udmVyc2F0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBkZWxldGVkLCBpdHMganVzdFxuICAgICAqIG5vIGxvbmdlciBiZWluZyBoZWxkIGluIGxvY2FsIG1lbW9yeS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0eXBpY2FsbHkgeW91IHdpbGwgd2FudCB0aGUgY29udmVyc2F0aW9uczpkZWxldGUgZXZlbnRcbiAgICAgKiByYXRoZXIgdGhhbiBjb252ZXJzYXRpb25zOnJlbW92ZS5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdjb252ZXJzYXRpb25zOnJlbW92ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIGV2dC5jb252ZXJzYXRpb25zLmZvckVhY2goZnVuY3Rpb24oY29udmVyc2F0aW9uKSB7XG4gICAgICogICAgICAgICAgICAgIG15Vmlldy5yZW1vdmVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKTtcbiAgICAgKiAgICAgICAgICB9KTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBldnQuY29udmVyc2F0aW9ucyAtIEFycmF5IG9mIGNvbnZlcnNhdGlvbnMgcmVtb3ZlZFxuICAgICAqL1xuICAgICdjb252ZXJzYXRpb25zOnJlbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udmVyc2F0aW9uIGlzIG5vdyBvbiB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQ2FsbGVkIGFmdGVyIGNyZWF0aW5nIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKiBvbiB0aGUgc2VydmVyLiAgVGhlIFJlc3VsdCBwcm9wZXJ0eSBpcyBvbmUgb2Y6XG4gICAgICpcbiAgICAgKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5DUkVBVEVEOiBBIG5ldyBDb252ZXJzYXRpb24gaGFzIGJlZW4gY3JlYXRlZFxuICAgICAqICogbGF5ZXIuQ29udmVyc2F0aW9uLkZPVU5EOiBBIG1hdGNoaW5nIERpc3RpbmN0IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBmb3VuZFxuICAgICAqICogbGF5ZXIuQ29udmVyc2F0aW9uLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBOiBBIG1hdGNoaW5nIERpc3RpbmN0IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBmb3VuZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoZSBtZXRhZGF0YSBpcyBOT1Qgd2hhdCB5b3UgcmVxdWVzdGVkLlxuICAgICAqXG4gICAgICogQWxsIG9mIHRoZXNlIHJlc3VsdHMgd2lsbCBhbHNvIG1lYW4gdGhhdCB0aGUgdXBkYXRlZCBwcm9wZXJ0eSB2YWx1ZXMgaGF2ZSBiZWVuXG4gICAgICogY29waWVkIGludG8geW91ciBDb252ZXJzYXRpb24gb2JqZWN0LiAgVGhhdCBtZWFucyB5b3VyIG1ldGFkYXRhIHByb3BlcnR5IG1heSBub1xuICAgICAqIGxvbmdlciBiZSBpdHMgaW5pdGlhbCB2YWx1ZTsgaXQgd2lsbCBiZSB0aGUgdmFsdWUgZm91bmQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdjb252ZXJzYXRpb25zOnNlbnQnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgICAgICAgICBzd2l0Y2goZXZ0LnJlc3VsdCkge1xuICAgICAqICAgICAgICAgICAgICBjYXNlIENvbnZlcnNhdGlvbi5DUkVBVEVEOlxuICAgICAqICAgICAgICAgICAgICAgICAgYWxlcnQoZXZ0LnRhcmdldC5pZCArICcgQ3JlYXRlZCEnKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgICAgICBjYXNlIENvbnZlcnNhdGlvbi5GT1VORDpcbiAgICAgKiAgICAgICAgICAgICAgICAgIGFsZXJ0KGV2dC50YXJnZXQuaWQgKyAnIEZvdW5kIScpO1xuICAgICAqICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICogICAgICAgICAgICAgIGNhc2UgQ29udmVyc2F0aW9uLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBOlxuICAgICAqICAgICAgICAgICAgICAgICAgYWxlcnQoZXZ0LnRhcmdldC5pZCArICcgRm91bmQsIGJ1dCBkb2VzIG5vdCBoYXZlIHRoZSByZXF1ZXN0ZWQgbWV0YWRhdGEhJyk7XG4gICAgICogICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQucmVzdWx0XG4gICAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb259IHRhcmdldFxuICAgICAqL1xuICAgICdjb252ZXJzYXRpb25zOnNlbnQnLFxuXG4gICAgLyoqXG4gICAgICogQSBjb252ZXJzYXRpb24gZmFpbGVkIHRvIGxvYWQgb3IgY3JlYXRlIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiAgICAgIGNsaWVudC5vbignY29udmVyc2F0aW9uczpzZW50LWVycm9yJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgYWxlcnQoZXZ0LmRhdGEubWVzc2FnZSk7XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldnQuZGF0YVxuICAgICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9ufSB0YXJnZXRcbiAgICAgKi9cbiAgICAnY29udmVyc2F0aW9uczpzZW50LWVycm9yJyxcblxuICAgIC8qKlxuICAgICAqIEEgY29udmVyc2F0aW9uIGhhZCBhIGNoYW5nZSBpbiBpdHMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2hhbmdlIG1heSBoYXZlIGJlZW4gZGVsaXZlcmVkIGZyb20gYSByZW1vdGUgdXNlclxuICAgICAqIG9yIGFzIGEgcmVzdWx0IG9mIGEgbG9jYWwgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgdmFyIG1ldGFkYXRhQ2hhbmdlcyA9IGV2dC5nZXRDaGFuZ2VzRm9yKCdtZXRhZGF0YScpO1xuICAgICAqICAgICAgICAgIHZhciBwYXJ0aWNpcGFudENoYW5nZXMgPSBldnQuZ2V0Q2hhbmdlc0ZvcigncGFydGljaXBhbnRzJyk7XG4gICAgICogICAgICAgICAgaWYgKG1ldGFkYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgKiAgICAgICAgICAgICAgbXlWaWV3LnJlbmRlclRpdGxlKGV2dC50YXJnZXQubWV0YWRhdGEudGl0bGUpO1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICBpZiAocGFydGljaXBhbnRDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAqICAgICAgICAgICAgICBteVZpZXcucmVuZGVyUGFydGljaXBhbnRzKGV2dC50YXJnZXQucGFydGljaXBhbnRzKTtcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIE5PVEU6IFR5cGljYWxseSBzdWNoIHJlbmRlcmluZyBpcyBkb25lIHVzaW5nIEV2ZW50cyBvbiBsYXllci5RdWVyeS5cbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb259IGV2dC50YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBldnQuY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV2dC5jaGFuZ2VzLm5ld1ZhbHVlXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXZ0LmNoYW5nZXMub2xkVmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0LmNoYW5nZXMucHJvcGVydHkgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGhhcyBjaGFuZ2VkXG4gICAgICovXG4gICAgJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJyxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbCB0byBsYXllci5Db252ZXJzYXRpb24ubG9hZCBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVxuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbn0gZXZ0LnRhcmdldFxuICAgICAqL1xuICAgICdjb252ZXJzYXRpb25zOmxvYWRlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIENvbnZlcnNhdGlvbiBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIENhdXNlZCBieSBlaXRoZXIgYSBzdWNjZXNzZnVsIGNhbGwgdG8gbGF5ZXIuQ29udmVyc2F0aW9uLmRlbGV0ZSgpIG9uIHRoZSBDb252ZXJzYXRpb25cbiAgICAgKiBvciBieSBhIHJlbW90ZSB1c2VyLlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6ZGVsZXRlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgbXlWaWV3LnJlbW92ZUNvbnZlcnNhdGlvbihldnQudGFyZ2V0KTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbn0gZXZ0LnRhcmdldFxuICAgICAqL1xuICAgICdjb252ZXJzYXRpb25zOmRlbGV0ZScsXG4gIF0sXG4gIGxpZmVjeWNsZToge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX21vZGVscy5jb252ZXJzYXRpb25zID0ge307XG4gICAgfSxcbiAgICBjbGVhbnVwKCkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuX21vZGVscy5jb252ZXJzYXRpb25zW2lkXTtcbiAgICAgICAgaWYgKGNvbnZlcnNhdGlvbiAmJiAhY29udmVyc2F0aW9uLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgY29udmVyc2F0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9tb2RlbHMuY29udmVyc2F0aW9ucyA9IG51bGw7XG4gICAgfSxcblxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnMgPSB7fTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBjb252ZXJzYXRpb24gYnkgSWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGMgPSBjbGllbnQuZ2V0Q29udmVyc2F0aW9uKCdsYXllcjovLy9jb252ZXJzYXRpb25zL3V1aWQnKTtcbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vdCBhIGNvbnZlcnNhdGlvbiB3aXRoIHRoYXQgaWQsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCBpdCB0byBsb2FkIGl0IGZyb20gY2FjaGUgYW5kIHRoZW4gZnJvbSBzZXJ2ZXIgaWYgbm90IGluIGNhY2hlLCB1c2UgdGhlIGBjYW5Mb2FkYCBwYXJhbWV0ZXIuXG4gICAgICogSWYgbG9hZGluZyBmcm9tIHRoZSBzZXJ2ZXIsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm5cbiAgICAgKiBhIGxheWVyLkNvbnZlcnNhdGlvbiBpbnN0YW5jZSB0aGF0IGhhcyBubyBkYXRhOyB0aGUgYGNvbnZlcnNhdGlvbnM6bG9hZGVkYCAvIGBjb252ZXJzYXRpb25zOmxvYWRlZC1lcnJvcmAgZXZlbnRzXG4gICAgICogd2lsbCBsZXQgeW91IGtub3cgd2hlbiB0aGUgY29udmVyc2F0aW9uIGhhcyBmaW5pc2hlZC9mYWlsZWQgbG9hZGluZyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjID0gY2xpZW50LmdldENvbnZlcnNhdGlvbignbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy8xMjMnLCB0cnVlKVxuICAgICAqICAgICAgLm9uKCdjb252ZXJzYXRpb25zOmxvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIC8vIFJlbmRlciB0aGUgQ29udmVyc2F0aW9uIHdpdGggYWxsIG9mIGl0cyBkZXRhaWxzIGxvYWRlZFxuICAgICAqICAgICAgICAgIG15cmVyZW5kZXIoYyk7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIC8vIFJlbmRlciBhIHBsYWNlaG9sZGVyIGZvciBjIHVudGlsIHRoZSBkZXRhaWxzIG9mIGMgaGF2ZSBsb2FkZWRcbiAgICAgKiAgICAgIG15cmVuZGVyKGMpO1xuICAgICAqXG4gICAgICogTm90ZSBpbiB0aGUgYWJvdmUgZXhhbXBsZSB0aGF0IHRoZSBgY29udmVyc2F0aW9uczpsb2FkZWRgIGV2ZW50IHdpbGwgdHJpZ2dlciBldmVuIGlmIHRoZSBDb252ZXJzYXRpb24gaGFzIHByZXZpb3VzbHkgbG9hZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDb252ZXJzYXRpb25cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2NhbkxvYWQ9ZmFsc2VdIC0gUGFzcyB0cnVlIHRvIGFsbG93IGxvYWRpbmcgYSBjb252ZXJzYXRpb24gZnJvbVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNlcnZlciBpZiBub3QgZm91bmRcbiAgICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259XG4gICAgICovXG4gICAgZ2V0Q29udmVyc2F0aW9uKGlkLCBjYW5Mb2FkKSB7XG4gICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKEVycm9yRGljdGlvbmFyeS5pZFBhcmFtUmVxdWlyZWQpO1xuICAgICAgaWYgKCFDb252ZXJzYXRpb24uaXNWYWxpZElkKGlkKSkge1xuICAgICAgICBpZCA9IENvbnZlcnNhdGlvbi5wcmVmaXhVVUlEICsgaWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbaWRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHMuY29udmVyc2F0aW9uc1tpZF07XG4gICAgICB9IGVsc2UgaWYgKGNhbkxvYWQpIHtcbiAgICAgICAgcmV0dXJuIENvbnZlcnNhdGlvbi5sb2FkKGlkLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29udmVyc2F0aW9uIHRvIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUeXBpY2FsbHksIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXM7IHRoZSBmb2xsb3dpbmcgY29kZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgY2FsbHMgX2FkZENvbnZlcnNhdGlvbiBmb3IgeW91OlxuICAgICAqXG4gICAgICogICAgICB2YXIgY29udiA9IG5ldyBsYXllci5Db252ZXJzYXRpb24oe1xuICAgICAqICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAqICAgICAgICAgIHBhcnRpY2lwYW50czogWydhJywgJ2InXVxuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgIC8vIE9SOlxuICAgICAqICAgICAgdmFyIGNvbnYgPSBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKFsnYScsICdiJ10pO1xuICAgICAqXG4gICAgICogQG1ldGhvZCBfYWRkQ29udmVyc2F0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gY1xuICAgICAqL1xuICAgIF9hZGRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSB7XG4gICAgICBjb25zdCBpZCA9IGNvbnZlcnNhdGlvbi5pZDtcbiAgICAgIGlmICghdGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbaWRdKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBDb252ZXJzYXRpb25cbiAgICAgICAgdGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbaWRdID0gY29udmVyc2F0aW9uO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2xpZW50IGlzIHNldCBzbyB0aGF0IHRoZSBuZXh0IGV2ZW50IGJ1YmJsZXMgdXBcbiAgICAgICAgaWYgKGNvbnZlcnNhdGlvbi5jbGllbnRJZCAhPT0gdGhpcy5hcHBJZCkgY29udmVyc2F0aW9uLmNsaWVudElkID0gdGhpcy5hcHBJZDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjb252ZXJzYXRpb25zOmFkZCcsIHsgY29udmVyc2F0aW9uczogW2NvbnZlcnNhdGlvbl0gfSk7XG5cbiAgICAgICAgdGhpcy5fc2NoZWR1bGVDaGVja0FuZFB1cmdlQ2FjaGUoY29udmVyc2F0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbnZlcnNhdGlvbiBmcm9tIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUeXBpY2FsbHksIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXM7IHRoZSBmb2xsb3dpbmcgY29kZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgY2FsbHMgX3JlbW92ZUNvbnZlcnNhdGlvbiBmb3IgeW91OlxuICAgICAqXG4gICAgICogICAgICBjb252ZXJzYXRpb24uZGVzdHJveSgpO1xuICAgICAqXG4gICAgICogQG1ldGhvZCBfcmVtb3ZlQ29udmVyc2F0aW9uXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gY1xuICAgICAqL1xuICAgIF9yZW1vdmVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSB7XG4gICAgICAvLyBJbnN1cmUgd2UgZG8gbm90IGdldCBhbnkgZXZlbnRzLCBzdWNoIGFzIG1lc3NhZ2U6cmVtb3ZlXG4gICAgICBjb252ZXJzYXRpb24ub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbY29udmVyc2F0aW9uLmlkXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbY29udmVyc2F0aW9uLmlkXTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjb252ZXJzYXRpb25zOnJlbW92ZScsIHsgY29udmVyc2F0aW9uczogW2NvbnZlcnNhdGlvbl0gfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgTWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBDb252ZXJzYXRpb25cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscy5tZXNzYWdlcykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21vZGVscy5tZXNzYWdlc1tpZF0uY29udmVyc2F0aW9uSWQgPT09IGNvbnZlcnNhdGlvbi5pZCkge1xuICAgICAgICAgIHRoaXMuX21vZGVscy5tZXNzYWdlc1tpZF0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIENvbnZlcnNhdGlvbiBJRCBjaGFuZ2VzLCB3ZSBuZWVkIHRvIHJlcmVnaXN0ZXIgdGhlIENvbnZlcnNhdGlvblxuICAgICAqXG4gICAgICogQG1ldGhvZCBfdXBkYXRlQ29udmVyc2F0aW9uSWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtICB7bGF5ZXIuQ29udmVyc2F0aW9ufSBjb252ZXJzYXRpb24gLSBDb252ZXJzYXRpb24gd2hvc2UgSUQgaGFzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG9sZElkIC0gUHJldmlvdXMgSURcbiAgICAgKi9cbiAgICBfdXBkYXRlQ29udmVyc2F0aW9uSWQoY29udmVyc2F0aW9uLCBvbGRJZCkge1xuICAgICAgaWYgKHRoaXMuX21vZGVscy5jb252ZXJzYXRpb25zW29sZElkXSkge1xuICAgICAgICB0aGlzLl9tb2RlbHMuY29udmVyc2F0aW9uc1tjb252ZXJzYXRpb24uaWRdID0gY29udmVyc2F0aW9uO1xuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzLmNvbnZlcnNhdGlvbnNbb2xkSWRdO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBuYXN0eSB3YXkgdG8gd29yay4uLiBidXQgbmVlZCB0byBmaW5kIGFuZCB1cGRhdGUgYWxsXG4gICAgICAgIC8vIGNvbnZlcnNhdGlvbklkIHByb3BlcnRpZXMgb2YgYWxsIE1lc3NhZ2VzIG9yIHRoZSBRdWVyeSdzIHdvbid0XG4gICAgICAgIC8vIHNlZSB0aGVzZSBhcyBtYXRjaGluZyB0aGUgcXVlcnkuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscy5tZXNzYWdlcylcbiAgICAgICAgICAgICAgLmZpbHRlcihpZCA9PiB0aGlzLl9tb2RlbHMubWVzc2FnZXNbaWRdLmNvbnZlcnNhdGlvbklkID09PSBvbGRJZClcbiAgICAgICAgICAgICAgLmZvckVhY2goaWQgPT4gKHRoaXMuX21vZGVscy5tZXNzYWdlc1tpZF0uY29udmVyc2F0aW9uSWQgPSBjb252ZXJzYXRpb24uaWQpKTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBsb2NhbGx5IGNhY2hlZCBjb252ZXJzYXRpb25zIGZvciBhIG1hdGNoaW5nIGNvbnZlcnNhdGlvbi5cbiAgICAgKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgY29udmVyc2F0aW9ucyBjYWxsaW5nIGEgbWF0Y2hpbmcgZnVuY3Rpb24gdW50aWxcbiAgICAgKiB0aGUgY29udmVyc2F0aW9uIGlzIGZvdW5kIG9yIGFsbCBjb252ZXJzYXRpb25zIHRlc3RlZC5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGMgPSBjbGllbnQuZmluZENhY2hlZENvbnZlcnNhdGlvbihmdW5jdGlvbihjb252ZXJzYXRpb24pIHtcbiAgICAgKiAgICAgICAgICBpZiAoY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cy5pbmRleE9mKCdhJykgIT0gLTEpIHJldHVybiB0cnVlO1xuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZpbmRDYWNoZWRDb252ZXJzYXRpb25cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZiAtIEZ1bmN0aW9uIHRvIGNhbGwgdW50aWwgd2UgZmluZCBhIG1hdGNoXG4gICAgICogQHBhcmFtICB7bGF5ZXIuQ29udmVyc2F0aW9ufSBmLmNvbnZlcnNhdGlvbiAtIEEgY29udmVyc2F0aW9uIHRvIHRlc3RcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBmLnJldHVybiAtIFJldHVybiB0cnVlIGlmIHRoZSBjb252ZXJzYXRpb24gaXMgYSBtYXRjaFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCBmb3IgdGhlICp0aGlzKiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IGl0ZXJhdGluZyBvdmVyIHlvdXIgbGF5ZXIuUXVlcnkgZGF0YS5cbiAgICAgKi9cbiAgICBmaW5kQ2FjaGVkQ29udmVyc2F0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHRlc3QgPSBjb250ZXh0ID8gZnVuYy5iaW5kKGNvbnRleHQpIDogZnVuYztcbiAgICAgIGNvbnN0IGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLl9tb2RlbHMuY29udmVyc2F0aW9ucyk7XG4gICAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbGlzdFtpbmRleF07XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuX21vZGVscy5jb252ZXJzYXRpb25zW2tleV07XG4gICAgICAgIGlmICh0ZXN0KGNvbnZlcnNhdGlvbiwgaW5kZXgpKSByZXR1cm4gY29udmVyc2F0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHJlY29tbWVuZGVkIHdheSB0byBjcmVhdGUgYSBDb252ZXJzYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgYSBmZXcgd2F5cyB0byBpbnZva2UgaXQ7IG5vdGUgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjcmVhdGUgYSBEaXN0aW5jdCBDb252ZXJzYXRpb25cbiAgICAgKiB1bmxlc3Mgb3RoZXJ3aXNlIHN0YXRlZCB2aWEgdGhlIGxheWVyLkNvbnZlcnNhdGlvbi5kaXN0aW5jdCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbih7cGFydGljaXBhbnRzOiBbJ2EnLCAnYiddfSk7XG4gICAgICogICAgICAgICBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKHtwYXJ0aWNpcGFudHM6IFt1c2VySWRlbnRpdHlBLCB1c2VySWRlbnRpdHlCXX0pO1xuICAgICAqXG4gICAgICogICAgICAgICBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKHtcbiAgICAgKiAgICAgICAgICAgICBwYXJ0aWNpcGFudHM6IFsnYScsICdiJ10sXG4gICAgICogICAgICAgICAgICAgZGlzdGluY3Q6IGZhbHNlXG4gICAgICogICAgICAgICB9KTtcbiAgICAgKlxuICAgICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbih7XG4gICAgICogICAgICAgICAgICAgcGFydGljaXBhbnRzOiBbJ2EnLCAnYiddLFxuICAgICAqICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICogICAgICAgICAgICAgICAgIHRpdGxlOiAnSSBhbSBhIHRpdGxlJ1xuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqXG4gICAgICogSWYgeW91IHRyeSB0byBjcmVhdGUgYSBEaXN0aW5jdCBDb252ZXJzYXRpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyxcbiAgICAgKiB5b3Ugd2lsbCBnZXQgYmFjayBhbiBleGlzdGluZyBDb252ZXJzYXRpb24sIGFuZCBhbnkgcmVxdWVzdGVkIG1ldGFkYXRhXG4gICAgICogd2lsbCBOT1QgYmUgc2V0OyB5b3Ugd2lsbCBnZXQgd2hhdGV2ZXIgbWV0YWRhdGEgdGhlIG1hdGNoaW5nIENvbnZlcnNhdGlvblxuICAgICAqIGFscmVhZHkgaGFkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIGRpc3RpbmN0IGlzIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIFdoZXRoZXIgdGhlIENvbnZlcnNhdGlvbiBhbHJlYWR5IGV4aXN0cyBvciBub3QsIGEgJ2NvbnZlcnNhdGlvbnM6c2VudCcgZXZlbnRcbiAgICAgKiB3aWxsIGJlIHRyaWdnZXJlZCBhc3luY2hyb25vdXNseSBhbmQgdGhlIENvbnZlcnNhdGlvbiBvYmplY3Qgd2lsbCBiZSByZWFkeVxuICAgICAqIGF0IHRoYXQgdGltZS4gIEZ1cnRoZXIsIHRoZSBldmVudCB3aWxsIHByb3ZpZGUgZGV0YWlscyBvbiB0aGUgcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgICAgdmFyIGNvbnZlcnNhdGlvbiA9IGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oe1xuICAgICAqICAgICAgICAgIHBhcnRpY2lwYW50czogWydhJywgJ2InXSxcbiAgICAgKiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAqICAgICAgICAgICAgdGl0bGU6ICdJIGFtIGEgdGl0bGUnXG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICAgIGNvbnZlcnNhdGlvbi5vbignY29udmVyc2F0aW9uczpzZW50JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgIHN3aXRjaChldnQucmVzdWx0KSB7XG4gICAgICogICAgICAgICAgICAgICBjYXNlIENvbnZlcnNhdGlvbi5DUkVBVEVEOlxuICAgICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNvbnZlcnNhdGlvbi5pZCArICcgd2FzIGNyZWF0ZWQnKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgKiAgICAgICAgICAgICAgIGNhc2UgQ29udmVyc2F0aW9uLkZPVU5EOlxuICAgICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNvbnZlcnNhdGlvbi5pZCArICcgd2FzIGZvdW5kJyk7XG4gICAgICogICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICogICAgICAgICAgICAgICBjYXNlIENvbnZlcnNhdGlvbi5GT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQTpcbiAgICAgKiAgICAgICAgICAgICAgICAgICBhbGVydChjb252ZXJzYXRpb24uaWQgKyAnIHdhcyBmb3VuZCBidXQgaXQgYWxyZWFkeSBoYXMgYSB0aXRsZSBzbyB5b3VyIHJlcXVlc3RlZCB0aXRsZSB3YXMgbm90IHNldCcpO1xuICAgICAqICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgICAgfVxuICAgICAqICAgICAgIH0pO1xuICAgICAqXG4gICAgICogV2FybmluZzogVGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgd2hlbiB5b3UgYXJlIG5vdCAob3IgYXJlIG5vIGxvbmdlcikgYW4gYXV0aGVudGljYXRlZCB1c2VyLlxuICAgICAqIFRoYXQgbWVhbnMgaWYgYXV0aGVudGljYXRpb24gaGFzIGV4cGlyZWQsIGFuZCB5b3UgaGF2ZSBub3QgeWV0IHJlYXV0aGVudGljYXRlZCB0aGUgdXNlciwgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUNvbnZlcnNhdGlvblxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW10vbGF5ZXIuSWRlbnRpdHlbXX0gcGFydGljaXBhbnRzIC0gQXJyYXkgb2YgVXNlcklEcyBvciBVc2VySWRlbnRpdGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzdGluY3Q9dHJ1ZV0gSXMgdGhpcyBhIGRpc3RpbmN0IENvbnZlcnNhdGlvbj9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWV0YWRhdGE9e31dIE1ldGFkYXRhIGZvciB5b3VyIENvbnZlcnNhdGlvblxuICAgICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb252ZXJzYXRpb24ob3B0aW9ucykge1xuICAgICAgLy8gSWYgd2UgYXJlbid0IGF1dGhlbnRpY2F0ZWQsIHRoZW4gd2UgZG9uJ3QgeWV0IGhhdmUgYSBVc2VySUQsIGFuZCB3b24ndCBjcmVhdGUgdGhlIGNvcnJlY3QgQ29udmVyc2F0aW9uXG4gICAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKSB0aHJvdyBuZXcgRXJyb3IoRXJyb3JEaWN0aW9uYXJ5LmNsaWVudE11c3RCZVJlYWR5KTtcbiAgICAgIGlmICghKCdkaXN0aW5jdCcgaW4gb3B0aW9ucykpIG9wdGlvbnMuZGlzdGluY3QgPSB0cnVlO1xuICAgICAgb3B0aW9ucy5jbGllbnQgPSB0aGlzO1xuICAgICAgcmV0dXJuIENvbnZlcnNhdGlvbi5jcmVhdGUob3B0aW9ucyk7XG4gICAgfSxcbiAgfSxcbn07XG4iXX0=
