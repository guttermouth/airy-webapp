'use strict';

/**
 * Adds Message handling to the layer.Client.
 *
 * @class layer.mixins.ClientMessages
 */

var Syncable = require('../models/syncable');
var Message = require('../models/message');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * A new message has been received for which a notification may be suitable.
   *
   * This event is triggered for messages that are:
   *
   * 1. Added via websocket rather than other IO
   * 2. Not yet been marked as read
   * 3. Not sent by this user
   *
          client.on('messages:notify', function(evt) {
              myNotify(evt.message);
          })
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Message} evt.Message
  */
  'messages:notify',

  /**
   * Messages have been added to a conversation.
   *
   * May also fire when new Announcements are received.
   *
   * This event is triggered on
   *
   * * creating/sending a new message
   * * Receiving a new layer.Message or layer.Announcement via websocket
   * * Querying/downloading a set of Messages
   *
          client.on('messages:add', function(evt) {
              evt.messages.forEach(function(message) {
                  myView.addMessage(message);
              });
          });
  *
  * NOTE: Such rendering would typically be done using events on layer.Query.
  *
  * @event
  * @param {layer.LayerEvent} evt
  * @param {layer.Message[]} evt.messages
  */
  'messages:add',

  /**
   * A message has been removed from a conversation.
   *
   * A removed Message is not necessarily deleted,
   * just no longer being held in memory.
   *
   * Note that typically you will want the messages:delete event
   * rather than messages:remove.
   *
   *      client.on('messages:remove', function(evt) {
   *          evt.messages.forEach(function(message) {
   *              myView.removeMessage(message);
   *          });
   *      });
   *
   * NOTE: Such rendering would typically be done using events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.message
   */
  'messages:remove',

  /**
   * A message has been sent.
   *
   *      client.on('messages:sent', function(evt) {
   *          alert(evt.target.getText() + ' has been sent');
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:sent',

  /**
   * A message is about to be sent.
   *
   * Useful if you want to
   * add parts to the message before it goes out.
   *
   *      client.on('messages:sending', function(evt) {
   *          evt.target.addPart({
   *              mimeType: 'text/plain',
   *              body: 'this is just a test'
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:sending',

  /**
   * Server failed to receive a Message.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.error
   */
  'messages:sent-error',

  /**
   * A message has had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('messages:change', function(evt) {
   *          var recpientStatusChanges = evt.getChangesFor('recipientStatus');
   *          if (recpientStatusChanges.length) {
   *              myView.renderStatus(evt.target);
   *          }
   *      });
   *
   * NOTE: Such rendering would typically be done using events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'messages:change',

  /**
   * A call to layer.Message.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:loaded',

  /**
   * A Message has been deleted from the server.
   *
   * Caused by either a successful call to layer.Message.delete() on the Message
   * or by a remote user.
   *
   *      client.on('messages:delete', function(evt) {
   *          myView.removeMessage(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Message} evt.target
   */
  'messages:delete'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.messages = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.messages).forEach(function (id) {
        var message = _this._models.messages[id];
        if (message && !message.isDestroyed) {
          message.destroy();
        }
      });
      this._models.messages = null;
    },
    reset: function reset() {
      this._models.messages = {};
    }
  },
  methods: {
    /**
     * Retrieve the message or announcement by ID.
     *
     * Useful for finding a message when you have only the ID.
     *
     * If the message is not found, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Message instance that has no data; the messages:loaded/messages:loaded-error events
     * will let you know when the message has finished/failed loading from the server.
     *
     *      var m = client.getMessage('layer:///messages/123', true)
     *      .on('messages:loaded', function() {
     *          // Render the Message with all of its details loaded
     *          myrerender(m);
     *      });
     *      // Render a placeholder for m until the details of m have loaded
     *      myrender(m);
     *
     *
     * @method getMessage
     * @param  {string} id              - layer:///messages/uuid
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a message from the server if not found
     * @return {layer.Message}
     */
    getMessage: function getMessage(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);

      // NOTE: This could be an announcement
      if (id.indexOf('layer:///') !== 0) {
        id = Message.prefixUUID + id;
      }

      if (this._models.messages[id]) {
        return this._models.messages[id];
      } else if (canLoad) {
        return Syncable.load(id, this);
      }
      return null;
    },


    /**
     * Get a MessagePart by ID
     *
     * ```
     * var part = client.getMessagePart('layer:///messages/6f08acfa-3268-4ae5-83d9-6ca00000000/parts/0');
     * ```
     *
     * @method getMessagePart
     * @param {String} id - ID of the Message Part; layer:///messages/uuid/parts/5
     */
    getMessagePart: function getMessagePart(id) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);

      var messageId = id.replace(/\/parts.*$/, '');
      var message = this.getMessage(messageId);
      if (message) return message.getPartById(id);
      return null;
    },


    /**
     * Registers a message in _models.messages and triggers events.
     *
     * May also update Conversation.lastMessage.
     *
     * @method _addMessage
     * @protected
     * @param  {layer.Message} message
     */
    _addMessage: function _addMessage(message) {
      if (!this._models.messages[message.id]) {
        this._models.messages[message.id] = message;
        this._triggerAsync('messages:add', { messages: [message] });
        if (message._notify) {
          this._triggerAsync('messages:notify', { message: message });
          message._notify = false;
        }

        var conversation = message.getConversation(false);
        if (conversation && (!conversation.lastMessage || conversation.lastMessage.position < message.position)) {
          var lastMessageWas = conversation.lastMessage;
          conversation.lastMessage = message;
          if (lastMessageWas) this._scheduleCheckAndPurgeCache(lastMessageWas);
        } else {
          this._scheduleCheckAndPurgeCache(message);
        }
      }
    },


    /**
     * Removes message from _models.messages.
     *
     * Accepts IDs or Message instances
     *
     * TODO: Remove support for remove by ID
     *
     * @method _removeMessage
     * @private
     * @param  {layer.Message|string} message or Message ID
     */
    _removeMessage: function _removeMessage(message) {
      var id = typeof message === 'string' ? message : message.id;
      message = this._models.messages[id];
      if (message) {
        delete this._models.messages[id];
        if (!this._inCleanup) {
          this._triggerAsync('messages:remove', { messages: [message] });
          var conv = message.getConversation(false);

          // Websocket will eventually deliver an update to the latest lastMessage;
          // until then, use the old lastMessage's position as a placeholder
          if (!this._inCheckAndPurgeCache && conv && conv.lastMessage === message) {
            conv.lastMessage = null;
            conv._lastMessagePosition = message.position;
          }
        }
      }
    },


    /**
     * Handles delete from position event from Websocket.
     *
     * A WebSocket may deliver a `delete` Conversation event with a
     * from_position field indicating that all Messages at the specified position
     * and earlier should be deleted.
     *
     * @method _purgeMessagesByPosition
     * @private
     * @param {string} conversationId
     * @param {number} fromPosition
     */
    _purgeMessagesByPosition: function _purgeMessagesByPosition(conversationId, fromPosition) {
      var _this2 = this;

      Object.keys(this._models.messages).forEach(function (id) {
        var message = _this2._models.messages[id];
        if (message.conversationId === conversationId && message.position <= fromPosition) {
          message.destroy();
        }
      });
    }
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taXhpbnMvY2xpZW50LW1lc3NhZ2VzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7OztBQU1BLElBQU0sV0FBVyxRQUFRLG9CQUFSLENBQWpCO0FBQ0EsSUFBTSxVQUFVLFFBQVEsbUJBQVIsQ0FBaEI7QUFDQSxJQUFNLGtCQUFrQixRQUFRLGdCQUFSLEVBQTBCLFVBQWxEOztBQUVBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFVBQVE7QUFDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsbUJBbEJNOztBQW9CTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsZ0JBM0NNOztBQTZDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBLG1CQWxFTTs7QUFvRU47Ozs7Ozs7Ozs7O0FBV0EsaUJBL0VNOztBQWlGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsb0JBbEdNOztBQW9HTjs7Ozs7OztBQU9BLHVCQTNHTTs7QUE2R047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLG1CQXBJTTs7QUF1SU47Ozs7Ozs7QUFPQSxtQkE5SU07O0FBZ0pOOzs7Ozs7Ozs7Ozs7OztBQWNBLG1CQTlKTSxDQURPO0FBaUtmLGFBQVc7QUFDVCxlQURTLHVCQUNHLE9BREgsRUFDWTtBQUNuQixXQUFLLE9BQUwsQ0FBYSxRQUFiLEdBQXdCLEVBQXhCO0FBQ0QsS0FIUTtBQUlULFdBSlMscUJBSUM7QUFBQTs7QUFDUixhQUFPLElBQVAsQ0FBWSxLQUFLLE9BQUwsQ0FBYSxRQUF6QixFQUFtQyxPQUFuQyxDQUEyQyxVQUFDLEVBQUQsRUFBUTtBQUNqRCxZQUFNLFVBQVUsTUFBSyxPQUFMLENBQWEsUUFBYixDQUFzQixFQUF0QixDQUFoQjtBQUNBLFlBQUksV0FBVyxDQUFDLFFBQVEsV0FBeEIsRUFBcUM7QUFDbkMsa0JBQVEsT0FBUjtBQUNEO0FBQ0YsT0FMRDtBQU1BLFdBQUssT0FBTCxDQUFhLFFBQWIsR0FBd0IsSUFBeEI7QUFDRCxLQVpRO0FBYVQs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LGNBQU0sT0FBTyxRQUFRLGVBQVIsQ0FBd0IsS0FBeEIsQ0FBYjs7QUFFQTtBQUNBO0FBQ0EsY0FBSSxDQUFDLEtBQUsscUJBQU4sSUFBK0IsSUFBL0IsSUFBdUMsS0FBSyxXQUFMLEtBQXFCLE9BQWhFLEVBQXlFO0FBQ3ZFLGlCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxpQkFBSyxvQkFBTCxHQUE0QixRQUFRLFFBQXBDO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsS0F2SE07OztBQXlIUDs7Ozs7Ozs7Ozs7O0FBWUEsNEJBcklPLG9DQXFJa0IsY0FySWxCLEVBcUlrQyxZQXJJbEMsRUFxSWdEO0FBQUE7O0FBQ3JELGFBQU8sSUFBUCxDQUFZLEtBQUssT0FBTCxDQUFhLFFBQXpCLEVBQW1DLE9BQW5DLENBQTJDLFVBQUMsRUFBRCxFQUFRO0FBQ2pELFlBQU0sVUFBVSxPQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLEVBQXRCLENBQWhCO0FBQ0EsWUFBSSxRQUFRLGNBQVIsS0FBMkIsY0FBM0IsSUFBNkMsUUFBUSxRQUFSLElBQW9CLFlBQXJFLEVBQW1GO0FBQ2pGLGtCQUFRLE9BQVI7QUFDRDtBQUNGLE9BTEQ7QUFNRDtBQTVJTTtBQWxMTSxDQUFqQiIsImZpbGUiOiJjbGllbnQtbWVzc2FnZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFkZHMgTWVzc2FnZSBoYW5kbGluZyB0byB0aGUgbGF5ZXIuQ2xpZW50LlxuICpcbiAqIEBjbGFzcyBsYXllci5taXhpbnMuQ2xpZW50TWVzc2FnZXNcbiAqL1xuXG5jb25zdCBTeW5jYWJsZSA9IHJlcXVpcmUoJy4uL21vZGVscy9zeW5jYWJsZScpO1xuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4uL21vZGVscy9tZXNzYWdlJyk7XG5jb25zdCBFcnJvckRpY3Rpb25hcnkgPSByZXF1aXJlKCcuLi9sYXllci1lcnJvcicpLmRpY3Rpb25hcnk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBldmVudHM6IFtcbiAgICAvKipcbiAgICAgKiBBIG5ldyBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkIGZvciB3aGljaCBhIG5vdGlmaWNhdGlvbiBtYXkgYmUgc3VpdGFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBmb3IgbWVzc2FnZXMgdGhhdCBhcmU6XG4gICAgICpcbiAgICAgKiAxLiBBZGRlZCB2aWEgd2Vic29ja2V0IHJhdGhlciB0aGFuIG90aGVyIElPXG4gICAgICogMi4gTm90IHlldCBiZWVuIG1hcmtlZCBhcyByZWFkXG4gICAgICogMy4gTm90IHNlbnQgYnkgdGhpcyB1c2VyXG4gICAgICpcbiAgICAgICAgICAgIGNsaWVudC5vbignbWVzc2FnZXM6bm90aWZ5JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgbXlOb3RpZnkoZXZ0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSlcbiAgICAqXG4gICAgKiBAZXZlbnRcbiAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2V9IGV2dC5NZXNzYWdlXG4gICAgKi9cbiAgICAnbWVzc2FnZXM6bm90aWZ5JyxcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2VzIGhhdmUgYmVlbiBhZGRlZCB0byBhIGNvbnZlcnNhdGlvbi5cbiAgICAgKlxuICAgICAqIE1heSBhbHNvIGZpcmUgd2hlbiBuZXcgQW5ub3VuY2VtZW50cyBhcmUgcmVjZWl2ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBvblxuICAgICAqXG4gICAgICogKiBjcmVhdGluZy9zZW5kaW5nIGEgbmV3IG1lc3NhZ2VcbiAgICAgKiAqIFJlY2VpdmluZyBhIG5ldyBsYXllci5NZXNzYWdlIG9yIGxheWVyLkFubm91bmNlbWVudCB2aWEgd2Vic29ja2V0XG4gICAgICogKiBRdWVyeWluZy9kb3dubG9hZGluZyBhIHNldCBvZiBNZXNzYWdlc1xuICAgICAqXG4gICAgICAgICAgICBjbGllbnQub24oJ21lc3NhZ2VzOmFkZCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIGV2dC5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbXlWaWV3LmFkZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAqXG4gICAgKiBOT1RFOiBTdWNoIHJlbmRlcmluZyB3b3VsZCB0eXBpY2FsbHkgYmUgZG9uZSB1c2luZyBldmVudHMgb24gbGF5ZXIuUXVlcnkuXG4gICAgKlxuICAgICogQGV2ZW50XG4gICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlW119IGV2dC5tZXNzYWdlc1xuICAgICovXG4gICAgJ21lc3NhZ2VzOmFkZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGEgY29udmVyc2F0aW9uLlxuICAgICAqXG4gICAgICogQSByZW1vdmVkIE1lc3NhZ2UgaXMgbm90IG5lY2Vzc2FyaWx5IGRlbGV0ZWQsXG4gICAgICoganVzdCBubyBsb25nZXIgYmVpbmcgaGVsZCBpbiBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdHlwaWNhbGx5IHlvdSB3aWxsIHdhbnQgdGhlIG1lc3NhZ2VzOmRlbGV0ZSBldmVudFxuICAgICAqIHJhdGhlciB0aGFuIG1lc3NhZ2VzOnJlbW92ZS5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdtZXNzYWdlczpyZW1vdmUnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgICAgICAgICBldnQubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICogICAgICAgICAgICAgIG15Vmlldy5yZW1vdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAqICAgICAgICAgIH0pO1xuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBOT1RFOiBTdWNoIHJlbmRlcmluZyB3b3VsZCB0eXBpY2FsbHkgYmUgZG9uZSB1c2luZyBldmVudHMgb24gbGF5ZXIuUXVlcnkuXG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gZXZ0Lm1lc3NhZ2VcbiAgICAgKi9cbiAgICAnbWVzc2FnZXM6cmVtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBoYXMgYmVlbiBzZW50LlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ21lc3NhZ2VzOnNlbnQnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgICAgICAgICBhbGVydChldnQudGFyZ2V0LmdldFRleHQoKSArICcgaGFzIGJlZW4gc2VudCcpO1xuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gZXZ0LnRhcmdldFxuICAgICAqL1xuICAgICdtZXNzYWdlczpzZW50JyxcblxuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSBpcyBhYm91dCB0byBiZSBzZW50LlxuICAgICAqXG4gICAgICogVXNlZnVsIGlmIHlvdSB3YW50IHRvXG4gICAgICogYWRkIHBhcnRzIHRvIHRoZSBtZXNzYWdlIGJlZm9yZSBpdCBnb2VzIG91dC5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdtZXNzYWdlczpzZW5kaW5nJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgZXZ0LnRhcmdldC5hZGRQYXJ0KHtcbiAgICAgKiAgICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiAgICAgICAgICAgICAgYm9keTogJ3RoaXMgaXMganVzdCBhIHRlc3QnXG4gICAgICogICAgICAgICAgfSk7XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQudGFyZ2V0XG4gICAgICovXG4gICAgJ21lc3NhZ2VzOnNlbmRpbmcnLFxuXG4gICAgLyoqXG4gICAgICogU2VydmVyIGZhaWxlZCB0byByZWNlaXZlIGEgTWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldnQuZXJyb3JcbiAgICAgKi9cbiAgICAnbWVzc2FnZXM6c2VudC1lcnJvcicsXG5cbiAgICAvKipcbiAgICAgKiBBIG1lc3NhZ2UgaGFzIGhhZCBhIGNoYW5nZSBpbiBpdHMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2hhbmdlIG1heSBoYXZlIGJlZW4gZGVsaXZlcmVkIGZyb20gYSByZW1vdGUgdXNlclxuICAgICAqIG9yIGFzIGEgcmVzdWx0IG9mIGEgbG9jYWwgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ21lc3NhZ2VzOmNoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIHZhciByZWNwaWVudFN0YXR1c0NoYW5nZXMgPSBldnQuZ2V0Q2hhbmdlc0ZvcigncmVjaXBpZW50U3RhdHVzJyk7XG4gICAgICogICAgICAgICAgaWYgKHJlY3BpZW50U3RhdHVzQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgKiAgICAgICAgICAgICAgbXlWaWV3LnJlbmRlclN0YXR1cyhldnQudGFyZ2V0KTtcbiAgICAgKiAgICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIE5PVEU6IFN1Y2ggcmVuZGVyaW5nIHdvdWxkIHR5cGljYWxseSBiZSBkb25lIHVzaW5nIGV2ZW50cyBvbiBsYXllci5RdWVyeS5cbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQudGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZXZ0LmNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge01peGVkfSBldnQuY2hhbmdlcy5uZXdWYWx1ZVxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV2dC5jaGFuZ2VzLm9sZFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2dC5jaGFuZ2VzLnByb3BlcnR5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBoYXMgY2hhbmdlZFxuICAgICAqL1xuICAgICdtZXNzYWdlczpjaGFuZ2UnLFxuXG5cbiAgICAvKipcbiAgICAgKiBBIGNhbGwgdG8gbGF5ZXIuTWVzc2FnZS5sb2FkIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gZXZ0LnRhcmdldFxuICAgICAqL1xuICAgICdtZXNzYWdlczpsb2FkZWQnLFxuXG4gICAgLyoqXG4gICAgICogQSBNZXNzYWdlIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQ2F1c2VkIGJ5IGVpdGhlciBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBsYXllci5NZXNzYWdlLmRlbGV0ZSgpIG9uIHRoZSBNZXNzYWdlXG4gICAgICogb3IgYnkgYSByZW1vdGUgdXNlci5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdtZXNzYWdlczpkZWxldGUnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgICAgICAgICBteVZpZXcucmVtb3ZlTWVzc2FnZShldnQudGFyZ2V0KTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2V9IGV2dC50YXJnZXRcbiAgICAgKi9cbiAgICAnbWVzc2FnZXM6ZGVsZXRlJyxcbiAgXSxcbiAgbGlmZWN5Y2xlOiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgdGhpcy5fbW9kZWxzLm1lc3NhZ2VzID0ge307XG4gICAgfSxcbiAgICBjbGVhbnVwKCkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzLm1lc3NhZ2VzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgIW1lc3NhZ2UuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICBtZXNzYWdlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9tb2RlbHMubWVzc2FnZXMgPSBudWxsO1xuICAgIH0sXG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLl9tb2RlbHMubWVzc2FnZXMgPSB7fTtcbiAgICB9LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIG1lc3NhZ2Ugb3IgYW5ub3VuY2VtZW50IGJ5IElELlxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciBmaW5kaW5nIGEgbWVzc2FnZSB3aGVuIHlvdSBoYXZlIG9ubHkgdGhlIElELlxuICAgICAqXG4gICAgICogSWYgdGhlIG1lc3NhZ2UgaXMgbm90IGZvdW5kLCBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgaXQgdG8gbG9hZCBpdCBmcm9tIGNhY2hlIGFuZCB0aGVuIGZyb20gc2VydmVyIGlmIG5vdCBpbiBjYWNoZSwgdXNlIHRoZSBgY2FuTG9hZGAgcGFyYW1ldGVyLlxuICAgICAqIElmIGxvYWRpbmcgZnJvbSB0aGUgc2VydmVyLCB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgICogYSBsYXllci5NZXNzYWdlIGluc3RhbmNlIHRoYXQgaGFzIG5vIGRhdGE7IHRoZSBtZXNzYWdlczpsb2FkZWQvbWVzc2FnZXM6bG9hZGVkLWVycm9yIGV2ZW50c1xuICAgICAqIHdpbGwgbGV0IHlvdSBrbm93IHdoZW4gdGhlIG1lc3NhZ2UgaGFzIGZpbmlzaGVkL2ZhaWxlZCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIG0gPSBjbGllbnQuZ2V0TWVzc2FnZSgnbGF5ZXI6Ly8vbWVzc2FnZXMvMTIzJywgdHJ1ZSlcbiAgICAgKiAgICAgIC5vbignbWVzc2FnZXM6bG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgLy8gUmVuZGVyIHRoZSBNZXNzYWdlIHdpdGggYWxsIG9mIGl0cyBkZXRhaWxzIGxvYWRlZFxuICAgICAqICAgICAgICAgIG15cmVyZW5kZXIobSk7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIC8vIFJlbmRlciBhIHBsYWNlaG9sZGVyIGZvciBtIHVudGlsIHRoZSBkZXRhaWxzIG9mIG0gaGF2ZSBsb2FkZWRcbiAgICAgKiAgICAgIG15cmVuZGVyKG0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldE1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICAgICAgICAgICAgICAtIGxheWVyOi8vL21lc3NhZ2VzL3V1aWRcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbY2FuTG9hZD1mYWxzZV0gLSBQYXNzIHRydWUgdG8gYWxsb3cgbG9hZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyIGlmIG5vdCBmb3VuZFxuICAgICAqIEByZXR1cm4ge2xheWVyLk1lc3NhZ2V9XG4gICAgICovXG4gICAgZ2V0TWVzc2FnZShpZCwgY2FuTG9hZCkge1xuICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihFcnJvckRpY3Rpb25hcnkuaWRQYXJhbVJlcXVpcmVkKTtcblxuICAgICAgLy8gTk9URTogVGhpcyBjb3VsZCBiZSBhbiBhbm5vdW5jZW1lbnRcbiAgICAgIGlmIChpZC5pbmRleE9mKCdsYXllcjovLy8nKSAhPT0gMCkge1xuICAgICAgICBpZCA9IE1lc3NhZ2UucHJlZml4VVVJRCArIGlkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuTG9hZCkge1xuICAgICAgICByZXR1cm4gU3luY2FibGUubG9hZChpZCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgTWVzc2FnZVBhcnQgYnkgSURcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBwYXJ0ID0gY2xpZW50LmdldE1lc3NhZ2VQYXJ0KCdsYXllcjovLy9tZXNzYWdlcy82ZjA4YWNmYS0zMjY4LTRhZTUtODNkOS02Y2EwMDAwMDAwMC9wYXJ0cy8wJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldE1lc3NhZ2VQYXJ0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gSUQgb2YgdGhlIE1lc3NhZ2UgUGFydDsgbGF5ZXI6Ly8vbWVzc2FnZXMvdXVpZC9wYXJ0cy81XG4gICAgICovXG4gICAgZ2V0TWVzc2FnZVBhcnQoaWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoRXJyb3JEaWN0aW9uYXJ5LmlkUGFyYW1SZXF1aXJlZCk7XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9IGlkLnJlcGxhY2UoL1xcL3BhcnRzLiokLywgJycpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShtZXNzYWdlSWQpO1xuICAgICAgaWYgKG1lc3NhZ2UpIHJldHVybiBtZXNzYWdlLmdldFBhcnRCeUlkKGlkKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBtZXNzYWdlIGluIF9tb2RlbHMubWVzc2FnZXMgYW5kIHRyaWdnZXJzIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIE1heSBhbHNvIHVwZGF0ZSBDb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9hZGRNZXNzYWdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSAge2xheWVyLk1lc3NhZ2V9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBfYWRkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBpZiAoIXRoaXMuX21vZGVscy5tZXNzYWdlc1ttZXNzYWdlLmlkXSkge1xuICAgICAgICB0aGlzLl9tb2RlbHMubWVzc2FnZXNbbWVzc2FnZS5pZF0gPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmFkZCcsIHsgbWVzc2FnZXM6IFttZXNzYWdlXSB9KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuX25vdGlmeSkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6bm90aWZ5JywgeyBtZXNzYWdlIH0pO1xuICAgICAgICAgIG1lc3NhZ2UuX25vdGlmeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gbWVzc2FnZS5nZXRDb252ZXJzYXRpb24oZmFsc2UpO1xuICAgICAgICBpZiAoY29udmVyc2F0aW9uICYmICghY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlIHx8IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5wb3NpdGlvbiA8IG1lc3NhZ2UucG9zaXRpb24pKSB7XG4gICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2VXYXMgPSBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2U7XG4gICAgICAgICAgY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICBpZiAobGFzdE1lc3NhZ2VXYXMpIHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlKGxhc3RNZXNzYWdlV2FzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG1lc3NhZ2UgZnJvbSBfbW9kZWxzLm1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQWNjZXB0cyBJRHMgb3IgTWVzc2FnZSBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciByZW1vdmUgYnkgSURcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3JlbW92ZU1lc3NhZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge2xheWVyLk1lc3NhZ2V8c3RyaW5nfSBtZXNzYWdlIG9yIE1lc3NhZ2UgSURcbiAgICAgKi9cbiAgICBfcmVtb3ZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBjb25zdCBpZCA9ICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpID8gbWVzc2FnZSA6IG1lc3NhZ2UuaWQ7XG4gICAgICBtZXNzYWdlID0gdGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXTtcbiAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RlbHMubWVzc2FnZXNbaWRdO1xuICAgICAgICBpZiAoIXRoaXMuX2luQ2xlYW51cCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6cmVtb3ZlJywgeyBtZXNzYWdlczogW21lc3NhZ2VdIH0pO1xuICAgICAgICAgIGNvbnN0IGNvbnYgPSBtZXNzYWdlLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG5cbiAgICAgICAgICAvLyBXZWJzb2NrZXQgd2lsbCBldmVudHVhbGx5IGRlbGl2ZXIgYW4gdXBkYXRlIHRvIHRoZSBsYXRlc3QgbGFzdE1lc3NhZ2U7XG4gICAgICAgICAgLy8gdW50aWwgdGhlbiwgdXNlIHRoZSBvbGQgbGFzdE1lc3NhZ2UncyBwb3NpdGlvbiBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgaWYgKCF0aGlzLl9pbkNoZWNrQW5kUHVyZ2VDYWNoZSAmJiBjb252ICYmIGNvbnYubGFzdE1lc3NhZ2UgPT09IG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnYubGFzdE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgY29udi5fbGFzdE1lc3NhZ2VQb3NpdGlvbiA9IG1lc3NhZ2UucG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZGVsZXRlIGZyb20gcG9zaXRpb24gZXZlbnQgZnJvbSBXZWJzb2NrZXQuXG4gICAgICpcbiAgICAgKiBBIFdlYlNvY2tldCBtYXkgZGVsaXZlciBhIGBkZWxldGVgIENvbnZlcnNhdGlvbiBldmVudCB3aXRoIGFcbiAgICAgKiBmcm9tX3Bvc2l0aW9uIGZpZWxkIGluZGljYXRpbmcgdGhhdCBhbGwgTWVzc2FnZXMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIGFuZCBlYXJsaWVyIHNob3VsZCBiZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfcHVyZ2VNZXNzYWdlc0J5UG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb252ZXJzYXRpb25JZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tUG9zaXRpb25cbiAgICAgKi9cbiAgICBfcHVyZ2VNZXNzYWdlc0J5UG9zaXRpb24oY29udmVyc2F0aW9uSWQsIGZyb21Qb3NpdGlvbikge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzLm1lc3NhZ2VzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udmVyc2F0aW9uSWQgPT09IGNvbnZlcnNhdGlvbklkICYmIG1lc3NhZ2UucG9zaXRpb24gPD0gZnJvbVBvc2l0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgfSxcbn07XG4iXX0=
