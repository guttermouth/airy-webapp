'use strict';

/**
 * Adds Channel handling to the layer.Client.
 *
 * @class layer.mixins.ClientChannels
 */

var Channel = require('../models/channel');
var ErrorDictionary = require('../layer-error').dictionary;

module.exports = {
  events: [
  /**
   * One or more layer.Channel objects have been added to the client.
   *
   * They may have been added via the websocket, or via the user creating
   * a new Channel locally.
   *
   *      client.on('channels:add', function(evt) {
   *          evt.channels.forEach(function(channel) {
   *              myView.addChannel(channel);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel[]} evt.channels - Array of channels added
   */
  'channels:add',

  /**
   * One or more layer.Channel objects have been removed.
   *
   * A removed Channel is not necessarily deleted, its just
   * no longer being held in local memory.
   *
   * Note that typically you will want the channels:delete event
   * rather than channels:remove.
   *
   *      client.on('channels:remove', function(evt) {
   *          evt.channels.forEach(function(channel) {
   *              myView.removeChannel(channel);
   *          });
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel[]} evt.channels - Array of channels removed
   */
  'channels:remove',

  /**
   * A channel had a change in its properties.
   *
   * This change may have been delivered from a remote user
   * or as a result of a local operation.
   *
   *      client.on('channels:change', function(evt) {
   *          var metadataChanges = evt.getChangesFor('metadata');
   *          var participantChanges = evt.getChangesFor('members');
   *          if (metadataChanges.length) {
   *              myView.renderTitle(evt.target.metadata.title);
   *          }
   *          if (participantChanges.length) {
   *              myView.rendermembers(evt.target.members);
   *          }
   *      });
   *
   * NOTE: Typically such rendering is done using Events on layer.Query.
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   * @param {Object[]} evt.changes
   * @param {Mixed} evt.changes.newValue
   * @param {Mixed} evt.changes.oldValue
   * @param {string} evt.changes.property - Name of the property that has changed
   */
  'channels:change',

  /**
   * A call to layer.Channel.load has completed successfully
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   */
  'channels:loaded',

  /**
   * A Channel has been deleted from the server.
   *
   * Caused by either a successful call to layer.Channel.delete() on the Channel
   * or by a remote user.
   *
   *      client.on('channels:delete', function(evt) {
   *          myView.removeChannel(evt.target);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.Channel} evt.target
   */
  'channels:delete',

  /**
   * The channel is now on the server.
   *
   * Called after creating the channel
   * on the server.  The Result property is one of:
   *
   * * layer.Channel.CREATED: A new Channel has been created
   * * layer.Channel.FOUND: A matching Channel has been found
   *
   * All of these results will also mean that the updated property values have been
   * copied into your Channel object.  That means your metadata property may no
   * longer be its initial value; it will be the value found on the server.
   *
   *      client.on('channels:sent', function(evt) {
   *          switch(evt.result) {
   *              case Channel.CREATED:
   *                  alert(evt.target.id + ' Created!');
   *                  break;
   *              case Channel.FOUND:
   *                  alert(evt.target.id + ' Found!');
   *                  break;
   *          }
   *      });
   *
   * @event
   * @param {layer.LayerEvent} event
   * @param {string} event.result
   * @param {layer.Channel} target
   */
  'channels:sent',

  /**
   * A channel failed to load or create on the server.
   *
   *      client.on('channels:sent-error', function(evt) {
   *          alert(evt.data.message);
   *      });
   *
   * @event
   * @param {layer.LayerEvent} evt
   * @param {layer.LayerError} evt.data
   * @param {layer.Channel} target
   */
  'channels:sent-error'],
  lifecycle: {
    constructor: function constructor(options) {
      this._models.channels = {};
    },
    cleanup: function cleanup() {
      var _this = this;

      Object.keys(this._models.channels).forEach(function (id) {
        var channel = _this._models.channels[id];
        if (channel && !channel.isDestroyed) {
          channel.destroy();
        }
      });
      this._models.channels = null;
    },
    reset: function reset() {
      this._models.channels = {};
    }
  },
  methods: {
    /**
     * Retrieve a channel by Identifier.
     *
     *      var c = client.getChannel('layer:///channels/uuid');
     *
     * If there is not a channel with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Channel instance that has no data; the `channels:loaded` / `channels:loaded-error` events
     * will let you know when the channel has finished/failed loading from the server.
     *
     *      var c = client.getChannel('layer:///channels/123', true)
     *      .on('channels:loaded', function() {
     *          // Render the Channel with all of its details loaded
     *          myrerender(c);
     *      });
     *      // Render a placeholder for c until the details of c have loaded
     *      myrender(c);
     *
     * Note in the above example that the `channels:loaded` event will trigger even if the Channel has previously loaded.
     *
     * @method getChannel
     * @param  {string} id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a channel from
     *                                    the server if not found
     * @return {layer.Channel}
     */
    getChannel: function getChannel(id, canLoad) {
      if (typeof id !== 'string') throw new Error(ErrorDictionary.idParamRequired);
      if (!Channel.isValidId(id)) {
        id = Channel.prefixUUID + id;
      }
      if (this._models.channels[id]) {
        return this._models.channels[id];
      } else if (canLoad) {
        return Channel.load(id, this);
      }
      return null;
    },


    /**
     * Adds a channel to the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _addChannel for you:
     *
     *      var conv = new layer.Channel({
     *          client: client,
     *          members: ['a', 'b']
     *      });
     *
     *      // OR:
     *      var conv = client.createChannel(['a', 'b']);
     *
     * @method _addChannel
     * @protected
     * @param  {layer.Channel} c
     */
    _addChannel: function _addChannel(channel) {
      var id = channel.id;
      if (!this._models.channels[id]) {
        // Register the Channel
        this._models.channels[id] = channel;

        // Make sure the client is set so that the next event bubbles up
        if (channel.clientId !== this.appId) channel.clientId = this.appId;
        this._triggerAsync('channels:add', { channels: [channel] });

        this._scheduleCheckAndPurgeCache(channel);
      }
    },


    /**
     * Removes a channel from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeChannel for you:
     *
     *      channel.destroy();
     *
     * @method _removeChannel
     * @protected
     * @param  {layer.Channel} c
     */
    _removeChannel: function _removeChannel(channel) {
      var _this2 = this;

      // Insure we do not get any events, such as message:remove
      channel.off(null, null, this);

      if (this._models.channels[channel.id]) {
        delete this._models.channels[channel.id];
        this._triggerAsync('channels:remove', { channels: [channel] });
      }

      // Remove any Message associated with this Channel
      Object.keys(this._models.messages).forEach(function (id) {
        if (_this2._models.messages[id].channelId === channel.id) {
          _this2._models.messages[id].destroy();
        }
      });
    },


    /**
     * If the Channel ID changes, we need to reregister the Channel
     *
     * @method _updateChannelId
     * @protected
     * @param  {layer.Channel} channel - Channel whose ID has changed
     * @param  {string} oldId - Previous ID
     */
    _updateChannelId: function _updateChannelId(channel, oldId) {
      var _this3 = this;

      if (this._models.channels[oldId]) {
        this._models.channels[channel.id] = channel;
        delete this._models.channels[oldId];

        // This is a nasty way to work... but need to find and update all
        // channelId properties of all Messages or the Query's won't
        // see these as matching the query.
        Object.keys(this._models.messages).filter(function (id) {
          return _this3._models.messages[id].conversationId === oldId;
        }).forEach(function (id) {
          return _this3._models.messages[id].conversationId = channel.id;
        });
      }
    },


    /**
     * Searches locally cached channels for a matching channel.
     *
     * Iterates over channels calling a matching function until
     * the channel is found or all channels tested.
     *
     *      var c = client.findCachedChannel(function(channel) {
     *          if (channel.participants.indexOf('a') != -1) return true;
     *      });
     *
     * @method findCachedChannel
     * @param  {Function} f - Function to call until we find a match
     * @param  {layer.Channel} f.channel - A channel to test
     * @param  {boolean} f.return - Return true if the channel is a match
     * @param  {Object} [context] - Optional context for the *this* object
     * @return {layer.Channel}
     *
     * @deprecated
     * This should be replaced by iterating over your layer.Query data.
     */
    findCachedChannel: function findCachedChannel(func, context) {
      var test = context ? func.bind(context) : func;
      var list = Object.keys(this._models.channels);
      var len = list.length;
      for (var index = 0; index < len; index++) {
        var key = list[index];
        var channel = this._models.channels[key];
        if (test(channel, index)) return channel;
      }
      return null;
    },


    /**
     * This method is recommended way to create a Channel.
     *
     * ```
     *         client.createChannel({
     *             members: ['layer:///identities/a', 'layer:///identities/b'],
     *             name: 'a-channel'
     *         });
     *         client.createChannel({
     *             members: [userIdentityObjectA, userIdentityObjectB],
     *             name: 'another-channel'
     *         });
     *
     *         client.createChannel({
     *             members: ['layer:///identities/a', 'layer:///identities/b'],
     *             name: 'a-channel-with-metadata',
     *             metadata: {
     *                 topicDetails: 'I am a detail'
     *             }
     *         });
     * ```
     *
     * If you try to create a Channel with a name that already exists,
     * you will get back an existing Channel, and any requested metadata and members
     * will NOT be set; you will get whatever metadata the matching Conversation
     * already had, and no members will be added/removed.
     *
     * Whether the Channel already exists or not, a 'channels:sent' event
     * will be triggered asynchronously and the Channel object will be ready
     * at that time.  Further, the event will provide details on the result:
     *
     * ```
     *       var channel = client.createChannel({
     *          members: ['a', 'b'],
     *          name: 'yet-another-channel-with-metadata',
     *          metadata: {
     *                 topicDetails: 'I am a detail'
     *          }
     *       });
     *       channel.on('channels:sent', function(evt) {
     *           switch(evt.result) {
     *               case Channel.CREATED:
     *                   alert(channel.id + ' was created');
     *                   break;
     *               case Channel.FOUND:
     *                   alert(channel.id + ' was found');
     *                   break;
     *               case Channel.FOUND_WITHOUT_REQUESTED_METADATA:
     *                   alert(channel.id + ' was found but it already has a topicDetails so your requested detail was not set');
     *                   break;
     *            }
     *       });
     * ```
     *
     * Warning: This method will throw an error if called when you are not (or are no longer) an authenticated user.
     * That means if authentication has expired, and you have not yet reauthenticated the user, this will throw an error.
     *
     *
     * @method createChannel
     * @param  {Object} options
     * @param {string[]/layer.Identity[]} options.members - Array of UserIDs or UserIdentities
     * @param {String} options.name - The unique name for this Channel
     * @param {Object} [options.metadata={}] Metadata for your Channel
     * @return {layer.Channel}
     */
    createChannel: function createChannel(options) {
      // If we aren't authenticated, then we don't yet have a UserID, and won't create the correct Channel
      if (!this.isAuthenticated) throw new Error(ErrorDictionary.clientMustBeReady);
      if (!('private' in options)) options.private = false;
      options.client = this;
      return Channel.create(options);
    }
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9taXhpbnMvY2xpZW50LWNoYW5uZWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7OztBQU1BLElBQU0sVUFBVSxRQUFRLG1CQUFSLENBQWhCO0FBQ0EsSUFBTSxrQkFBa0IsUUFBUSxnQkFBUixFQUEwQixVQUFsRDs7QUFFQSxPQUFPLE9BQVAsR0FBaUI7QUFDZixVQUFRO0FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsZ0JBakJNOztBQW1CTjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxtQkF0Q007O0FBd0NOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsbUJBbkVNOztBQXFFTjs7Ozs7OztBQU9BLG1CQTVFTTs7QUE4RU47Ozs7Ozs7Ozs7Ozs7O0FBY0EsbUJBNUZNOztBQStGTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkEsaUJBNUhNOztBQThITjs7Ozs7Ozs7Ozs7O0FBWUEsdUJBMUlNLENBRE87QUE2SWYsYUFBVztBQUNULGVBRFMsdUJBQ0csT0FESCxFQUNZO0FBQ25CLFdBQUssT0FBTCxDQUFhLFFBQWIsR0FBd0IsRUFBeEI7QUFDRCxLQUhRO0FBSVQsV0FKUyxxQkFJQztBQUFBOztBQUNSLGFBQU8sSUFBUCxDQUFZLEtBQUssT0FBTCxDQUFhLFFBQXpCLEVBQW1DLE9BQW5DLENBQTJDLFVBQUMsRUFBRCxFQUFRO0FBQ2pELFlBQU0sVUFBVSxNQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLEVBQXRCLENBQWhCO0FBQ0EsWUFBSSxXQUFXLENBQUMsUUFBUSxXQUF4QixFQUFxQztBQUNuQyxrQkFBUSxPQUFSO0FBQ0Q7QUFDRixPQUxEO0FBTUEsV0FBSyxPQUFMLENBQWEsUUFBYixHQUF3QixJQUF4QjtBQUNELEtBWlE7QUFjVCxTQWRTLG1CQWNEO0FBQ04sV0FBSyxPQUFMLENBQWEsUUFBYixHQUF3QixFQUF4QjtBQUNEO0FBaEJRLEdBN0lJO0FBZ0tmLFdBQVM7QUFDUDs7Ozs7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QUFRLEVBQTFEO0FBQUEsU0FGZjtBQUdEO0FBQ0YsS0EzSE07OztBQTZIUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEscUJBakpPLDZCQWlKVyxJQWpKWCxFQWlKaUIsT0FqSmpCLEVBaUowQjtBQUMvQixVQUFNLE9BQU8sVUFBVSxLQUFLLElBQUwsQ0FBVSxPQUFWLENBQVYsR0FBK0IsSUFBNUM7QUFDQSxVQUFNLE9BQU8sT0FBTyxJQUFQLENBQVksS0FBSyxPQUFMLENBQWEsUUFBekIsQ0FBYjtBQUNBLFVBQU0sTUFBTSxLQUFLLE1BQWpCO0FBQ0EsV0FBSyxJQUFJLFFBQVEsQ0FBakIsRUFBb0IsUUFBUSxHQUE1QixFQUFpQyxPQUFqQyxFQUEwQztBQUN4QyxZQUFNLE1BQU0sS0FBSyxLQUFMLENBQVo7QUFDQSxZQUFNLFVBQVUsS0FBSyxPQUFMLENBQWEsUUFBYixDQUFzQixHQUF0QixDQUFoQjtBQUNBLFlBQUksS0FBSyxPQUFMLEVBQWMsS0FBZCxDQUFKLEVBQTBCLE9BQU8sT0FBUDtBQUMzQjtBQUNELGFBQU8sSUFBUDtBQUNELEtBM0pNOzs7QUE2SlA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUVBLGlCQTlOTyx5QkE4Tk8sT0E5TlAsRUE4TmdCO0FBQ3JCO0FBQ0EsVUFBSSxDQUFDLEtBQUssZUFBVixFQUEyQixNQUFNLElBQUksS0FBSixDQUFVLGdCQUFnQixpQkFBMUIsQ0FBTjtBQUMzQixVQUFJLEVBQUUsYUFBYSxPQUFmLENBQUosRUFBNkIsUUFBUSxPQUFSLEdBQWtCLEtBQWxCO0FBQzdCLGNBQVEsTUFBUixHQUFpQixJQUFqQjtBQUNBLGFBQU8sUUFBUSxNQUFSLENBQWUsT0FBZixDQUFQO0FBQ0Q7QUFwT007QUFoS00sQ0FBakIiLCJmaWxlIjoiY2xpZW50LWNoYW5uZWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBZGRzIENoYW5uZWwgaGFuZGxpbmcgdG8gdGhlIGxheWVyLkNsaWVudC5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIubWl4aW5zLkNsaWVudENoYW5uZWxzXG4gKi9cblxuY29uc3QgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL21vZGVscy9jaGFubmVsJyk7XG5jb25zdCBFcnJvckRpY3Rpb25hcnkgPSByZXF1aXJlKCcuLi9sYXllci1lcnJvcicpLmRpY3Rpb25hcnk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBldmVudHM6IFtcbiAgICAvKipcbiAgICAgKiBPbmUgb3IgbW9yZSBsYXllci5DaGFubmVsIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUaGV5IG1heSBoYXZlIGJlZW4gYWRkZWQgdmlhIHRoZSB3ZWJzb2NrZXQsIG9yIHZpYSB0aGUgdXNlciBjcmVhdGluZ1xuICAgICAqIGEgbmV3IENoYW5uZWwgbG9jYWxseS5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdjaGFubmVsczphZGQnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgICAgICAgICBldnQuY2hhbm5lbHMuZm9yRWFjaChmdW5jdGlvbihjaGFubmVsKSB7XG4gICAgICogICAgICAgICAgICAgIG15Vmlldy5hZGRDaGFubmVsKGNoYW5uZWwpO1xuICAgICAqICAgICAgICAgIH0pO1xuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuQ2hhbm5lbFtdfSBldnQuY2hhbm5lbHMgLSBBcnJheSBvZiBjaGFubmVscyBhZGRlZFxuICAgICAqL1xuICAgICdjaGFubmVsczphZGQnLFxuXG4gICAgLyoqXG4gICAgICogT25lIG9yIG1vcmUgbGF5ZXIuQ2hhbm5lbCBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICAqXG4gICAgICogQSByZW1vdmVkIENoYW5uZWwgaXMgbm90IG5lY2Vzc2FyaWx5IGRlbGV0ZWQsIGl0cyBqdXN0XG4gICAgICogbm8gbG9uZ2VyIGJlaW5nIGhlbGQgaW4gbG9jYWwgbWVtb3J5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHR5cGljYWxseSB5b3Ugd2lsbCB3YW50IHRoZSBjaGFubmVsczpkZWxldGUgZXZlbnRcbiAgICAgKiByYXRoZXIgdGhhbiBjaGFubmVsczpyZW1vdmUuXG4gICAgICpcbiAgICAgKiAgICAgIGNsaWVudC5vbignY2hhbm5lbHM6cmVtb3ZlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgZXZ0LmNoYW5uZWxzLmZvckVhY2goZnVuY3Rpb24oY2hhbm5lbCkge1xuICAgICAqICAgICAgICAgICAgICBteVZpZXcucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICAgKiAgICAgICAgICB9KTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNoYW5uZWxbXX0gZXZ0LmNoYW5uZWxzIC0gQXJyYXkgb2YgY2hhbm5lbHMgcmVtb3ZlZFxuICAgICAqL1xuICAgICdjaGFubmVsczpyZW1vdmUnLFxuXG4gICAgLyoqXG4gICAgICogQSBjaGFubmVsIGhhZCBhIGNoYW5nZSBpbiBpdHMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2hhbmdlIG1heSBoYXZlIGJlZW4gZGVsaXZlcmVkIGZyb20gYSByZW1vdGUgdXNlclxuICAgICAqIG9yIGFzIGEgcmVzdWx0IG9mIGEgbG9jYWwgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ2NoYW5uZWxzOmNoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIHZhciBtZXRhZGF0YUNoYW5nZXMgPSBldnQuZ2V0Q2hhbmdlc0ZvcignbWV0YWRhdGEnKTtcbiAgICAgKiAgICAgICAgICB2YXIgcGFydGljaXBhbnRDaGFuZ2VzID0gZXZ0LmdldENoYW5nZXNGb3IoJ21lbWJlcnMnKTtcbiAgICAgKiAgICAgICAgICBpZiAobWV0YWRhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAqICAgICAgICAgICAgICBteVZpZXcucmVuZGVyVGl0bGUoZXZ0LnRhcmdldC5tZXRhZGF0YS50aXRsZSk7XG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgICAgIGlmIChwYXJ0aWNpcGFudENoYW5nZXMubGVuZ3RoKSB7XG4gICAgICogICAgICAgICAgICAgIG15Vmlldy5yZW5kZXJtZW1iZXJzKGV2dC50YXJnZXQubWVtYmVycyk7XG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBOT1RFOiBUeXBpY2FsbHkgc3VjaCByZW5kZXJpbmcgaXMgZG9uZSB1c2luZyBFdmVudHMgb24gbGF5ZXIuUXVlcnkuXG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuQ2hhbm5lbH0gZXZ0LnRhcmdldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGV2dC5jaGFuZ2VzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXZ0LmNoYW5nZXMubmV3VmFsdWVcbiAgICAgKiBAcGFyYW0ge01peGVkfSBldnQuY2hhbmdlcy5vbGRWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldnQuY2hhbmdlcy5wcm9wZXJ0eSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRoYXQgaGFzIGNoYW5nZWRcbiAgICAgKi9cbiAgICAnY2hhbm5lbHM6Y2hhbmdlJyxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbCB0byBsYXllci5DaGFubmVsLmxvYWQgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5DaGFubmVsfSBldnQudGFyZ2V0XG4gICAgICovXG4gICAgJ2NoYW5uZWxzOmxvYWRlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIENoYW5uZWwgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBDYXVzZWQgYnkgZWl0aGVyIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGxheWVyLkNoYW5uZWwuZGVsZXRlKCkgb24gdGhlIENoYW5uZWxcbiAgICAgKiBvciBieSBhIHJlbW90ZSB1c2VyLlxuICAgICAqXG4gICAgICogICAgICBjbGllbnQub24oJ2NoYW5uZWxzOmRlbGV0ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIG15Vmlldy5yZW1vdmVDaGFubmVsKGV2dC50YXJnZXQpO1xuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuQ2hhbm5lbH0gZXZ0LnRhcmdldFxuICAgICAqL1xuICAgICdjaGFubmVsczpkZWxldGUnLFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbm5lbCBpcyBub3cgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIENhbGxlZCBhZnRlciBjcmVhdGluZyB0aGUgY2hhbm5lbFxuICAgICAqIG9uIHRoZSBzZXJ2ZXIuICBUaGUgUmVzdWx0IHByb3BlcnR5IGlzIG9uZSBvZjpcbiAgICAgKlxuICAgICAqICogbGF5ZXIuQ2hhbm5lbC5DUkVBVEVEOiBBIG5ldyBDaGFubmVsIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKiAqIGxheWVyLkNoYW5uZWwuRk9VTkQ6IEEgbWF0Y2hpbmcgQ2hhbm5lbCBoYXMgYmVlbiBmb3VuZFxuICAgICAqXG4gICAgICogQWxsIG9mIHRoZXNlIHJlc3VsdHMgd2lsbCBhbHNvIG1lYW4gdGhhdCB0aGUgdXBkYXRlZCBwcm9wZXJ0eSB2YWx1ZXMgaGF2ZSBiZWVuXG4gICAgICogY29waWVkIGludG8geW91ciBDaGFubmVsIG9iamVjdC4gIFRoYXQgbWVhbnMgeW91ciBtZXRhZGF0YSBwcm9wZXJ0eSBtYXkgbm9cbiAgICAgKiBsb25nZXIgYmUgaXRzIGluaXRpYWwgdmFsdWU7IGl0IHdpbGwgYmUgdGhlIHZhbHVlIGZvdW5kIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiAgICAgIGNsaWVudC5vbignY2hhbm5lbHM6c2VudCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgICAgICAgIHN3aXRjaChldnQucmVzdWx0KSB7XG4gICAgICogICAgICAgICAgICAgIGNhc2UgQ2hhbm5lbC5DUkVBVEVEOlxuICAgICAqICAgICAgICAgICAgICAgICAgYWxlcnQoZXZ0LnRhcmdldC5pZCArICcgQ3JlYXRlZCEnKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgICAgICBjYXNlIENoYW5uZWwuRk9VTkQ6XG4gICAgICogICAgICAgICAgICAgICAgICBhbGVydChldnQudGFyZ2V0LmlkICsgJyBGb3VuZCEnKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5yZXN1bHRcbiAgICAgKiBAcGFyYW0ge2xheWVyLkNoYW5uZWx9IHRhcmdldFxuICAgICAqL1xuICAgICdjaGFubmVsczpzZW50JyxcblxuICAgIC8qKlxuICAgICAqIEEgY2hhbm5lbCBmYWlsZWQgdG8gbG9hZCBvciBjcmVhdGUgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqICAgICAgY2xpZW50Lm9uKCdjaGFubmVsczpzZW50LWVycm9yJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgYWxlcnQoZXZ0LmRhdGEubWVzc2FnZSk7XG4gICAgICogICAgICB9KTtcbiAgICAgKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldnQuZGF0YVxuICAgICAqIEBwYXJhbSB7bGF5ZXIuQ2hhbm5lbH0gdGFyZ2V0XG4gICAgICovXG4gICAgJ2NoYW5uZWxzOnNlbnQtZXJyb3InLFxuICBdLFxuICBsaWZlY3ljbGU6IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9tb2RlbHMuY2hhbm5lbHMgPSB7fTtcbiAgICB9LFxuICAgIGNsZWFudXAoKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9tb2RlbHMuY2hhbm5lbHMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9tb2RlbHMuY2hhbm5lbHNbaWRdO1xuICAgICAgICBpZiAoY2hhbm5lbCAmJiAhY2hhbm5lbC5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIGNoYW5uZWwuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21vZGVscy5jaGFubmVscyA9IG51bGw7XG4gICAgfSxcblxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5fbW9kZWxzLmNoYW5uZWxzID0ge307XG4gICAgfSxcblxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBjaGFubmVsIGJ5IElkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjID0gY2xpZW50LmdldENoYW5uZWwoJ2xheWVyOi8vL2NoYW5uZWxzL3V1aWQnKTtcbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vdCBhIGNoYW5uZWwgd2l0aCB0aGF0IGlkLCBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgaXQgdG8gbG9hZCBpdCBmcm9tIGNhY2hlIGFuZCB0aGVuIGZyb20gc2VydmVyIGlmIG5vdCBpbiBjYWNoZSwgdXNlIHRoZSBgY2FuTG9hZGAgcGFyYW1ldGVyLlxuICAgICAqIElmIGxvYWRpbmcgZnJvbSB0aGUgc2VydmVyLCB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuXG4gICAgICogYSBsYXllci5DaGFubmVsIGluc3RhbmNlIHRoYXQgaGFzIG5vIGRhdGE7IHRoZSBgY2hhbm5lbHM6bG9hZGVkYCAvIGBjaGFubmVsczpsb2FkZWQtZXJyb3JgIGV2ZW50c1xuICAgICAqIHdpbGwgbGV0IHlvdSBrbm93IHdoZW4gdGhlIGNoYW5uZWwgaGFzIGZpbmlzaGVkL2ZhaWxlZCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqICAgICAgdmFyIGMgPSBjbGllbnQuZ2V0Q2hhbm5lbCgnbGF5ZXI6Ly8vY2hhbm5lbHMvMTIzJywgdHJ1ZSlcbiAgICAgKiAgICAgIC5vbignY2hhbm5lbHM6bG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgLy8gUmVuZGVyIHRoZSBDaGFubmVsIHdpdGggYWxsIG9mIGl0cyBkZXRhaWxzIGxvYWRlZFxuICAgICAqICAgICAgICAgIG15cmVyZW5kZXIoYyk7XG4gICAgICogICAgICB9KTtcbiAgICAgKiAgICAgIC8vIFJlbmRlciBhIHBsYWNlaG9sZGVyIGZvciBjIHVudGlsIHRoZSBkZXRhaWxzIG9mIGMgaGF2ZSBsb2FkZWRcbiAgICAgKiAgICAgIG15cmVuZGVyKGMpO1xuICAgICAqXG4gICAgICogTm90ZSBpbiB0aGUgYWJvdmUgZXhhbXBsZSB0aGF0IHRoZSBgY2hhbm5lbHM6bG9hZGVkYCBldmVudCB3aWxsIHRyaWdnZXIgZXZlbiBpZiB0aGUgQ2hhbm5lbCBoYXMgcHJldmlvdXNseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldENoYW5uZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2NhbkxvYWQ9ZmFsc2VdIC0gUGFzcyB0cnVlIHRvIGFsbG93IGxvYWRpbmcgYSBjaGFubmVsIGZyb21cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzZXJ2ZXIgaWYgbm90IGZvdW5kXG4gICAgICogQHJldHVybiB7bGF5ZXIuQ2hhbm5lbH1cbiAgICAgKi9cbiAgICBnZXRDaGFubmVsKGlkLCBjYW5Mb2FkKSB7XG4gICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKEVycm9yRGljdGlvbmFyeS5pZFBhcmFtUmVxdWlyZWQpO1xuICAgICAgaWYgKCFDaGFubmVsLmlzVmFsaWRJZChpZCkpIHtcbiAgICAgICAgaWQgPSBDaGFubmVsLnByZWZpeFVVSUQgKyBpZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tb2RlbHMuY2hhbm5lbHNbaWRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHMuY2hhbm5lbHNbaWRdO1xuICAgICAgfSBlbHNlIGlmIChjYW5Mb2FkKSB7XG4gICAgICAgIHJldHVybiBDaGFubmVsLmxvYWQoaWQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjaGFubmVsIHRvIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUeXBpY2FsbHksIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXM7IHRoZSBmb2xsb3dpbmcgY29kZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgY2FsbHMgX2FkZENoYW5uZWwgZm9yIHlvdTpcbiAgICAgKlxuICAgICAqICAgICAgdmFyIGNvbnYgPSBuZXcgbGF5ZXIuQ2hhbm5lbCh7XG4gICAgICogICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICogICAgICAgICAgbWVtYmVyczogWydhJywgJ2InXVxuICAgICAqICAgICAgfSk7XG4gICAgICpcbiAgICAgKiAgICAgIC8vIE9SOlxuICAgICAqICAgICAgdmFyIGNvbnYgPSBjbGllbnQuY3JlYXRlQ2hhbm5lbChbJ2EnLCAnYiddKTtcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX2FkZENoYW5uZWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtICB7bGF5ZXIuQ2hhbm5lbH0gY1xuICAgICAqL1xuICAgIF9hZGRDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgIGNvbnN0IGlkID0gY2hhbm5lbC5pZDtcbiAgICAgIGlmICghdGhpcy5fbW9kZWxzLmNoYW5uZWxzW2lkXSkge1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgQ2hhbm5lbFxuICAgICAgICB0aGlzLl9tb2RlbHMuY2hhbm5lbHNbaWRdID0gY2hhbm5lbDtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNsaWVudCBpcyBzZXQgc28gdGhhdCB0aGUgbmV4dCBldmVudCBidWJibGVzIHVwXG4gICAgICAgIGlmIChjaGFubmVsLmNsaWVudElkICE9PSB0aGlzLmFwcElkKSBjaGFubmVsLmNsaWVudElkID0gdGhpcy5hcHBJZDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjaGFubmVsczphZGQnLCB7IGNoYW5uZWxzOiBbY2hhbm5lbF0gfSk7XG5cbiAgICAgICAgdGhpcy5fc2NoZWR1bGVDaGVja0FuZFB1cmdlQ2FjaGUoY2hhbm5lbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGFubmVsIGZyb20gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIFR5cGljYWxseSwgeW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpczsgdGhlIGZvbGxvd2luZyBjb2RlXG4gICAgICogYXV0b21hdGljYWxseSBjYWxscyBfcmVtb3ZlQ2hhbm5lbCBmb3IgeW91OlxuICAgICAqXG4gICAgICogICAgICBjaGFubmVsLmRlc3Ryb3koKTtcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX3JlbW92ZUNoYW5uZWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtICB7bGF5ZXIuQ2hhbm5lbH0gY1xuICAgICAqL1xuICAgIF9yZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgIC8vIEluc3VyZSB3ZSBkbyBub3QgZ2V0IGFueSBldmVudHMsIHN1Y2ggYXMgbWVzc2FnZTpyZW1vdmVcbiAgICAgIGNoYW5uZWwub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuXG4gICAgICBpZiAodGhpcy5fbW9kZWxzLmNoYW5uZWxzW2NoYW5uZWwuaWRdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tb2RlbHMuY2hhbm5lbHNbY2hhbm5lbC5pZF07XG4gICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnY2hhbm5lbHM6cmVtb3ZlJywgeyBjaGFubmVsczogW2NoYW5uZWxdIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgYW55IE1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ2hhbm5lbFxuICAgICAgT2JqZWN0LmtleXModGhpcy5fbW9kZWxzLm1lc3NhZ2VzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fbW9kZWxzLm1lc3NhZ2VzW2lkXS5jaGFubmVsSWQgPT09IGNoYW5uZWwuaWQpIHtcbiAgICAgICAgICB0aGlzLl9tb2RlbHMubWVzc2FnZXNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBDaGFubmVsIElEIGNoYW5nZXMsIHdlIG5lZWQgdG8gcmVyZWdpc3RlciB0aGUgQ2hhbm5lbFxuICAgICAqXG4gICAgICogQG1ldGhvZCBfdXBkYXRlQ2hhbm5lbElkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSAge2xheWVyLkNoYW5uZWx9IGNoYW5uZWwgLSBDaGFubmVsIHdob3NlIElEIGhhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBvbGRJZCAtIFByZXZpb3VzIElEXG4gICAgICovXG4gICAgX3VwZGF0ZUNoYW5uZWxJZChjaGFubmVsLCBvbGRJZCkge1xuICAgICAgaWYgKHRoaXMuX21vZGVscy5jaGFubmVsc1tvbGRJZF0pIHtcbiAgICAgICAgdGhpcy5fbW9kZWxzLmNoYW5uZWxzW2NoYW5uZWwuaWRdID0gY2hhbm5lbDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVscy5jaGFubmVsc1tvbGRJZF07XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIG5hc3R5IHdheSB0byB3b3JrLi4uIGJ1dCBuZWVkIHRvIGZpbmQgYW5kIHVwZGF0ZSBhbGxcbiAgICAgICAgLy8gY2hhbm5lbElkIHByb3BlcnRpZXMgb2YgYWxsIE1lc3NhZ2VzIG9yIHRoZSBRdWVyeSdzIHdvbid0XG4gICAgICAgIC8vIHNlZSB0aGVzZSBhcyBtYXRjaGluZyB0aGUgcXVlcnkuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21vZGVscy5tZXNzYWdlcylcbiAgICAgICAgICAgICAgLmZpbHRlcihpZCA9PiB0aGlzLl9tb2RlbHMubWVzc2FnZXNbaWRdLmNvbnZlcnNhdGlvbklkID09PSBvbGRJZClcbiAgICAgICAgICAgICAgLmZvckVhY2goaWQgPT4gKHRoaXMuX21vZGVscy5tZXNzYWdlc1tpZF0uY29udmVyc2F0aW9uSWQgPSBjaGFubmVsLmlkKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGxvY2FsbHkgY2FjaGVkIGNoYW5uZWxzIGZvciBhIG1hdGNoaW5nIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGNoYW5uZWxzIGNhbGxpbmcgYSBtYXRjaGluZyBmdW5jdGlvbiB1bnRpbFxuICAgICAqIHRoZSBjaGFubmVsIGlzIGZvdW5kIG9yIGFsbCBjaGFubmVscyB0ZXN0ZWQuXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjID0gY2xpZW50LmZpbmRDYWNoZWRDaGFubmVsKGZ1bmN0aW9uKGNoYW5uZWwpIHtcbiAgICAgKiAgICAgICAgICBpZiAoY2hhbm5lbC5wYXJ0aWNpcGFudHMuaW5kZXhPZignYScpICE9IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqXG4gICAgICogQG1ldGhvZCBmaW5kQ2FjaGVkQ2hhbm5lbFxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmIC0gRnVuY3Rpb24gdG8gY2FsbCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hcbiAgICAgKiBAcGFyYW0gIHtsYXllci5DaGFubmVsfSBmLmNoYW5uZWwgLSBBIGNoYW5uZWwgdG8gdGVzdFxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGYucmV0dXJuIC0gUmV0dXJuIHRydWUgaWYgdGhlIGNoYW5uZWwgaXMgYSBtYXRjaFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCBmb3IgdGhlICp0aGlzKiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtsYXllci5DaGFubmVsfVxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaGlzIHNob3VsZCBiZSByZXBsYWNlZCBieSBpdGVyYXRpbmcgb3ZlciB5b3VyIGxheWVyLlF1ZXJ5IGRhdGEuXG4gICAgICovXG4gICAgZmluZENhY2hlZENoYW5uZWwoZnVuYywgY29udGV4dCkge1xuICAgICAgY29uc3QgdGVzdCA9IGNvbnRleHQgPyBmdW5jLmJpbmQoY29udGV4dCkgOiBmdW5jO1xuICAgICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMuX21vZGVscy5jaGFubmVscyk7XG4gICAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbGlzdFtpbmRleF07XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9tb2RlbHMuY2hhbm5lbHNba2V5XTtcbiAgICAgICAgaWYgKHRlc3QoY2hhbm5lbCwgaW5kZXgpKSByZXR1cm4gY2hhbm5lbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZWNvbW1lbmRlZCB3YXkgdG8gY3JlYXRlIGEgQ2hhbm5lbC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNoYW5uZWwoe1xuICAgICAqICAgICAgICAgICAgIG1lbWJlcnM6IFsnbGF5ZXI6Ly8vaWRlbnRpdGllcy9hJywgJ2xheWVyOi8vL2lkZW50aXRpZXMvYiddLFxuICAgICAqICAgICAgICAgICAgIG5hbWU6ICdhLWNoYW5uZWwnXG4gICAgICogICAgICAgICB9KTtcbiAgICAgKiAgICAgICAgIGNsaWVudC5jcmVhdGVDaGFubmVsKHtcbiAgICAgKiAgICAgICAgICAgICBtZW1iZXJzOiBbdXNlcklkZW50aXR5T2JqZWN0QSwgdXNlcklkZW50aXR5T2JqZWN0Ql0sXG4gICAgICogICAgICAgICAgICAgbmFtZTogJ2Fub3RoZXItY2hhbm5lbCdcbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqXG4gICAgICogICAgICAgICBjbGllbnQuY3JlYXRlQ2hhbm5lbCh7XG4gICAgICogICAgICAgICAgICAgbWVtYmVyczogWydsYXllcjovLy9pZGVudGl0aWVzL2EnLCAnbGF5ZXI6Ly8vaWRlbnRpdGllcy9iJ10sXG4gICAgICogICAgICAgICAgICAgbmFtZTogJ2EtY2hhbm5lbC13aXRoLW1ldGFkYXRhJyxcbiAgICAgKiAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAqICAgICAgICAgICAgICAgICB0b3BpY0RldGFpbHM6ICdJIGFtIGEgZGV0YWlsJ1xuICAgICAqICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSWYgeW91IHRyeSB0byBjcmVhdGUgYSBDaGFubmVsIHdpdGggYSBuYW1lIHRoYXQgYWxyZWFkeSBleGlzdHMsXG4gICAgICogeW91IHdpbGwgZ2V0IGJhY2sgYW4gZXhpc3RpbmcgQ2hhbm5lbCwgYW5kIGFueSByZXF1ZXN0ZWQgbWV0YWRhdGEgYW5kIG1lbWJlcnNcbiAgICAgKiB3aWxsIE5PVCBiZSBzZXQ7IHlvdSB3aWxsIGdldCB3aGF0ZXZlciBtZXRhZGF0YSB0aGUgbWF0Y2hpbmcgQ29udmVyc2F0aW9uXG4gICAgICogYWxyZWFkeSBoYWQsIGFuZCBubyBtZW1iZXJzIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIFdoZXRoZXIgdGhlIENoYW5uZWwgYWxyZWFkeSBleGlzdHMgb3Igbm90LCBhICdjaGFubmVsczpzZW50JyBldmVudFxuICAgICAqIHdpbGwgYmUgdHJpZ2dlcmVkIGFzeW5jaHJvbm91c2x5IGFuZCB0aGUgQ2hhbm5lbCBvYmplY3Qgd2lsbCBiZSByZWFkeVxuICAgICAqIGF0IHRoYXQgdGltZS4gIEZ1cnRoZXIsIHRoZSBldmVudCB3aWxsIHByb3ZpZGUgZGV0YWlscyBvbiB0aGUgcmVzdWx0OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgICAgdmFyIGNoYW5uZWwgPSBjbGllbnQuY3JlYXRlQ2hhbm5lbCh7XG4gICAgICogICAgICAgICAgbWVtYmVyczogWydhJywgJ2InXSxcbiAgICAgKiAgICAgICAgICBuYW1lOiAneWV0LWFub3RoZXItY2hhbm5lbC13aXRoLW1ldGFkYXRhJyxcbiAgICAgKiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAqICAgICAgICAgICAgICAgICB0b3BpY0RldGFpbHM6ICdJIGFtIGEgZGV0YWlsJ1xuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgICB9KTtcbiAgICAgKiAgICAgICBjaGFubmVsLm9uKCdjaGFubmVsczpzZW50JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICAgICAgICAgIHN3aXRjaChldnQucmVzdWx0KSB7XG4gICAgICogICAgICAgICAgICAgICBjYXNlIENoYW5uZWwuQ1JFQVRFRDpcbiAgICAgKiAgICAgICAgICAgICAgICAgICBhbGVydChjaGFubmVsLmlkICsgJyB3YXMgY3JlYXRlZCcpO1xuICAgICAqICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgICAgICAgY2FzZSBDaGFubmVsLkZPVU5EOlxuICAgICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNoYW5uZWwuaWQgKyAnIHdhcyBmb3VuZCcpO1xuICAgICAqICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAqICAgICAgICAgICAgICAgY2FzZSBDaGFubmVsLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBOlxuICAgICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNoYW5uZWwuaWQgKyAnIHdhcyBmb3VuZCBidXQgaXQgYWxyZWFkeSBoYXMgYSB0b3BpY0RldGFpbHMgc28geW91ciByZXF1ZXN0ZWQgZGV0YWlsIHdhcyBub3Qgc2V0Jyk7XG4gICAgICogICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICogICAgICAgICAgICB9XG4gICAgICogICAgICAgfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBUaGlzIG1ldGhvZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGNhbGxlZCB3aGVuIHlvdSBhcmUgbm90IChvciBhcmUgbm8gbG9uZ2VyKSBhbiBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICogVGhhdCBtZWFucyBpZiBhdXRoZW50aWNhdGlvbiBoYXMgZXhwaXJlZCwgYW5kIHlvdSBoYXZlIG5vdCB5ZXQgcmVhdXRoZW50aWNhdGVkIHRoZSB1c2VyLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlQ2hhbm5lbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW10vbGF5ZXIuSWRlbnRpdHlbXX0gb3B0aW9ucy5tZW1iZXJzIC0gQXJyYXkgb2YgVXNlcklEcyBvciBVc2VySWRlbnRpdGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm5hbWUgLSBUaGUgdW5pcXVlIG5hbWUgZm9yIHRoaXMgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5tZXRhZGF0YT17fV0gTWV0YWRhdGEgZm9yIHlvdXIgQ2hhbm5lbFxuICAgICAqIEByZXR1cm4ge2xheWVyLkNoYW5uZWx9XG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbChvcHRpb25zKSB7XG4gICAgICAvLyBJZiB3ZSBhcmVuJ3QgYXV0aGVudGljYXRlZCwgdGhlbiB3ZSBkb24ndCB5ZXQgaGF2ZSBhIFVzZXJJRCwgYW5kIHdvbid0IGNyZWF0ZSB0aGUgY29ycmVjdCBDaGFubmVsXG4gICAgICBpZiAoIXRoaXMuaXNBdXRoZW50aWNhdGVkKSB0aHJvdyBuZXcgRXJyb3IoRXJyb3JEaWN0aW9uYXJ5LmNsaWVudE11c3RCZVJlYWR5KTtcbiAgICAgIGlmICghKCdwcml2YXRlJyBpbiBvcHRpb25zKSkgb3B0aW9ucy5wcml2YXRlID0gZmFsc2U7XG4gICAgICBvcHRpb25zLmNsaWVudCA9IHRoaXM7XG4gICAgICByZXR1cm4gQ2hhbm5lbC5jcmVhdGUob3B0aW9ucyk7XG4gICAgfSxcbiAgfSxcbn07XG4iXX0=
