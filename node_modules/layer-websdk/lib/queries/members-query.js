'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Query class for running a Query on Channel Members
 *
 *      var membersQuery = client.createQuery({
 *        client: client,
 *        model: layer.Query.Membership,
 *        predicate: 'channel.id = "layer:///channels/UUID"'
 *      });
 *
 * You can change the data selected by your query any time you want using:
 *
 *      query.update({
 *        predicate: 'channel.id = "layer:///channels/UUID2"'
 *      });
 *
 * You can release data held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### predicate
 *
 * Note that the `predicate` property is only supported for Messages and Membership, and only supports
 * querying by Channel.
 *
 * @class  layer.MembersQuery
 * @extends layer.Query
 */
var Root = require('../root');
var LayerError = require('../layer-error');
var Logger = require('../logger');
var Query = require('./query');

var findChannelIdRegex = new RegExp(/^channel.id\s*=\s*['"]((layer:\/\/\/channels\/)?.{8}-.{4}-.{4}-.{4}-.{12})['"]$/);

var MembersQuery = function (_Query) {
  _inherits(MembersQuery, _Query);

  function MembersQuery() {
    _classCallCheck(this, MembersQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(MembersQuery).apply(this, arguments));
  }

  _createClass(MembersQuery, [{
    key: '_fixPredicate',
    value: function _fixPredicate(inValue) {
      if (inValue === '') return '';
      if (inValue.indexOf('channel.id') !== -1) {
        var channelId = inValue.match(findChannelIdRegex) ? inValue.replace(findChannelIdRegex, '$1') : null;
        if (!channelId) throw new Error(LayerError.dictionary.invalidPredicate);
        if (channelId.indexOf('layer:///channels/') !== 0) channelId = 'layer:///channels/' + channelId;
        return 'channel.id = \'' + channelId + '\'';
      } else {
        throw new Error(LayerError.dictionary.invalidPredicate);
      }
    }

    /**
     * Get the Channel UUID from the predicate property.
     *
     * Extract the Channel's UUID from the predicate... or returned the cached value.
     *
     * @method _getChannelPredicateIds
     * @private
     */

  }, {
    key: '_getChannelPredicateIds',
    value: function _getChannelPredicateIds() {
      if (this.predicate.match(findChannelIdRegex)) {
        var channelId = this.predicate.replace(findChannelIdRegex, '$1');

        // We will already have a this._predicate if we are paging; else we need to extract the UUID from
        // the channelId.
        var uuid = (this._predicate || channelId).replace(/^layer:\/\/\/channels\//, '');
        if (uuid) {
          return {
            uuid: uuid,
            id: channelId,
            type: Query.Channel
          };
        }
      }
    }
  }, {
    key: '_fetchData',
    value: function _fetchData(pageSize) {
      var _this2 = this;

      var predicateIds = this._getChannelPredicateIds();

      // Do nothing if we don't have a conversation to query on
      if (!predicateIds) {
        if (this.predicate && !this.predicate.match(/['"]/)) {
          Logger.error('This query may need to quote its value');
        }
        return;
      }

      var channelId = 'layer:///channels/' + predicateIds.uuid;
      if (!this._predicate) this._predicate = predicateIds.id;
      var channel = this.client.getChannel(channelId);

      var newRequest = 'channels/' + predicateIds.uuid + '/members?page_size=' + pageSize + (this._nextServerFromId ? '&from_id=' + this._nextServerFromId : '');

      // Don't query on unsaved channels, nor repeat still firing queries
      if ((!channel || channel.isSaved()) && newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          telemetry: {
            name: 'member_query_time'
          },
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this2._processRunResults(results, newRequest, pageSize);
        });
      }
    }
  }, {
    key: '_appendResultsSplice',
    value: function _appendResultsSplice(item) {
      this.data.push(this._getData(item));
    }
  }, {
    key: '_handleEvents',
    value: function _handleEvents(eventName, evt) {
      switch (eventName) {

        // If a member has changed and its in our result set, replace
        // it with a new immutable object
        case 'members:change':
          this._handleChangeEvent('members', evt);
          break;

        // If members are added, and they aren't already in our result set
        // add them.
        case 'members:add':
          this._handleAddEvent('members', evt);
          break;

        // If a Identity is deleted and its in our result set, remove it
        // and trigger an event
        case 'members:remove':
          this._handleRemoveEvent('members', evt);
          break;
      }
    }
  }]);

  return MembersQuery;
}(Query);

MembersQuery._supportedEvents = [].concat(Query._supportedEvents);

MembersQuery.MaxPageSize = 500;

MembersQuery.prototype.model = Query.Membership;

Root.initClass.apply(MembersQuery, [MembersQuery, 'MembersQuery']);

module.exports = MembersQuery;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyaWVzL21lbWJlcnMtcXVlcnkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFNLFNBQVMsUUFBUSxXQUFSLENBQWY7QUFDQSxJQUFNLFFBQVEsUUFBUSxTQUFSLENBQWQ7O0FBRUEsSUFBTSxxQkFBcUIsSUFBSSxNQUFKLENBQ3pCLGlGQUR5QixDQUEzQjs7SUFJTSxZOzs7Ozs7Ozs7OztrQ0FDVSxPLEVBQVM7QUFDckIsVUFBSSxZQUFZLEVBQWhCLEVBQW9CLE9BQU8sRUFBUDtBQUNwQixVQUFJLFFBQVEsT0FBUixDQUFnQixZQUFoQixNQUFrQyxDQUFDLENBQXZDLEVBQTBDO0FBQ3hDLFlBQUksWUFBWSxRQUFRLEtBQVIsQ0FBYyxrQkFBZCxJQUFvQyxRQUFRLE9BQVIsQ0FBZ0Isa0JBQWhCLEVBQW9DLElBQXBDLENBQXBDLEdBQWdGLElBQWhHO0FBQ0EsWUFBSSxDQUFDLFNBQUwsRUFBZ0IsTUFBTSxJQUFJLEtBQUosQ0FBVSxXQUFXLFVBQVgsQ0FBc0IsZ0JBQWhDLENBQU47QUFDaEIsWUFBSSxVQUFVLE9BQVYsQ0FBa0Isb0JBQWxCLE1BQTRDLENBQWhELEVBQW1ELFlBQVksdUJBQXVCLFNBQW5DO0FBQ25ELG1DQUF3QixTQUF4QjtBQUNELE9BTEQsTUFLTztBQUNMLGNBQU0sSUFBSSxLQUFKLENBQVUsV0FBVyxVQUFYLENBQXNCLGdCQUFoQyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OENBUTBCO0FBQ3hCLFVBQUksS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixrQkFBckIsQ0FBSixFQUE4QztBQUM1QyxZQUFNLFlBQVksS0FBSyxTQUFMLENBQWUsT0FBZixDQUF1QixrQkFBdkIsRUFBMkMsSUFBM0MsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBLFlBQU0sT0FBTyxDQUFDLEtBQUssVUFBTCxJQUFtQixTQUFwQixFQUErQixPQUEvQixDQUF1Qyx5QkFBdkMsRUFBa0UsRUFBbEUsQ0FBYjtBQUNBLFlBQUksSUFBSixFQUFVO0FBQ1IsaUJBQU87QUFDTCxzQkFESztBQUVMLGdCQUFJLFNBRkM7QUFHTCxrQkFBTSxNQUFNO0FBSFAsV0FBUDtBQUtEO0FBQ0Y7QUFDRjs7OytCQUdVLFEsRUFBVTtBQUFBOztBQUNuQixVQUFNLGVBQWUsS0FBSyx1QkFBTCxFQUFyQjs7QUFFQTtBQUNBLFVBQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2pCLFlBQUksS0FBSyxTQUFMLElBQWtCLENBQUMsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixNQUFyQixDQUF2QixFQUFxRDtBQUNuRCxpQkFBTyxLQUFQLENBQWEsd0NBQWI7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsVUFBTSxZQUFZLHVCQUF1QixhQUFhLElBQXREO0FBQ0EsVUFBSSxDQUFDLEtBQUssVUFBVixFQUFzQixLQUFLLFVBQUwsR0FBa0IsYUFBYSxFQUEvQjtBQUN0QixVQUFNLFVBQVUsS0FBSyxNQUFMLENBQVksVUFBWixDQUF1QixTQUF2QixDQUFoQjs7QUFFQSxVQUFNLGFBQWEsY0FBWSxhQUFhLElBQXpCLDJCQUFtRCxRQUFuRCxJQUNoQixLQUFLLGlCQUFMLEdBQXlCLGNBQWMsS0FBSyxpQkFBNUMsR0FBZ0UsRUFEaEQsQ0FBbkI7O0FBR0E7QUFDQSxVQUFJLENBQUMsQ0FBQyxPQUFELElBQVksUUFBUSxPQUFSLEVBQWIsS0FBbUMsZUFBZSxLQUFLLGNBQTNELEVBQTJFO0FBQ3pFLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssY0FBTCxHQUFzQixVQUF0QjtBQUNBLGFBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0I7QUFDZCxxQkFBVztBQUNULGtCQUFNO0FBREcsV0FERztBQUlkLGVBQUssVUFKUztBQUtkLGtCQUFRLEtBTE07QUFNZCxnQkFBTTtBQU5RLFNBQWhCLEVBT0c7QUFBQSxpQkFBVyxPQUFLLGtCQUFMLENBQXdCLE9BQXhCLEVBQWlDLFVBQWpDLEVBQTZDLFFBQTdDLENBQVg7QUFBQSxTQVBIO0FBUUQ7QUFDRjs7O3lDQUVvQixJLEVBQU07QUFDekIsV0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLEtBQUssUUFBTCxDQUFjLElBQWQsQ0FBZjtBQUNEOzs7a0NBR2EsUyxFQUFXLEcsRUFBSztBQUM1QixjQUFRLFNBQVI7O0FBRUU7QUFDQTtBQUNBLGFBQUssZ0JBQUw7QUFDRSxlQUFLLGtCQUFMLENBQXdCLFNBQXhCLEVBQW1DLEdBQW5DO0FBQ0E7O0FBRUY7QUFDQTtBQUNBLGFBQUssYUFBTDtBQUNFLGVBQUssZUFBTCxDQUFxQixTQUFyQixFQUFnQyxHQUFoQztBQUNBOztBQUVGO0FBQ0E7QUFDQSxhQUFLLGdCQUFMO0FBQ0UsZUFBSyxrQkFBTCxDQUF3QixTQUF4QixFQUFtQyxHQUFuQztBQUNBO0FBbEJKO0FBb0JEOzs7O0VBbEd3QixLOztBQXFHM0IsYUFBYSxnQkFBYixHQUFnQyxHQUU5QixNQUY4QixDQUV2QixNQUFNLGdCQUZpQixDQUFoQzs7QUFLQSxhQUFhLFdBQWIsR0FBMkIsR0FBM0I7O0FBRUEsYUFBYSxTQUFiLENBQXVCLEtBQXZCLEdBQStCLE1BQU0sVUFBckM7O0FBRUEsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixZQUFyQixFQUFtQyxDQUFDLFlBQUQsRUFBZSxjQUFmLENBQW5DOztBQUVBLE9BQU8sT0FBUCxHQUFpQixZQUFqQiIsImZpbGUiOiJtZW1iZXJzLXF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBRdWVyeSBjbGFzcyBmb3IgcnVubmluZyBhIFF1ZXJ5IG9uIENoYW5uZWwgTWVtYmVyc1xuICpcbiAqICAgICAgdmFyIG1lbWJlcnNRdWVyeSA9IGNsaWVudC5jcmVhdGVRdWVyeSh7XG4gKiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gKiAgICAgICAgbW9kZWw6IGxheWVyLlF1ZXJ5Lk1lbWJlcnNoaXAsXG4gKiAgICAgICAgcHJlZGljYXRlOiAnY2hhbm5lbC5pZCA9IFwibGF5ZXI6Ly8vY2hhbm5lbHMvVVVJRFwiJ1xuICogICAgICB9KTtcbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGUgZGF0YSBzZWxlY3RlZCBieSB5b3VyIHF1ZXJ5IGFueSB0aW1lIHlvdSB3YW50IHVzaW5nOlxuICpcbiAqICAgICAgcXVlcnkudXBkYXRlKHtcbiAqICAgICAgICBwcmVkaWNhdGU6ICdjaGFubmVsLmlkID0gXCJsYXllcjovLy9jaGFubmVscy9VVUlEMlwiJ1xuICogICAgICB9KTtcbiAqXG4gKiBZb3UgY2FuIHJlbGVhc2UgZGF0YSBoZWxkIGluIG1lbW9yeSBieSB5b3VyIHF1ZXJpZXMgd2hlbiBkb25lIHdpdGggdGhlbTpcbiAqXG4gKiAgICAgIHF1ZXJ5LmRlc3Ryb3koKTtcbiAqXG4gKiAjIyMjIHByZWRpY2F0ZVxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYHByZWRpY2F0ZWAgcHJvcGVydHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIE1lc3NhZ2VzIGFuZCBNZW1iZXJzaGlwLCBhbmQgb25seSBzdXBwb3J0c1xuICogcXVlcnlpbmcgYnkgQ2hhbm5lbC5cbiAqXG4gKiBAY2xhc3MgIGxheWVyLk1lbWJlcnNRdWVyeVxuICogQGV4dGVuZHMgbGF5ZXIuUXVlcnlcbiAqL1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4uL3Jvb3QnKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuLi9sYXllci1lcnJvcicpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcblxuY29uc3QgZmluZENoYW5uZWxJZFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgL15jaGFubmVsLmlkXFxzKj1cXHMqWydcIl0oKGxheWVyOlxcL1xcL1xcL2NoYW5uZWxzXFwvKT8uezh9LS57NH0tLns0fS0uezR9LS57MTJ9KVsnXCJdJC8pO1xuXG5cbmNsYXNzIE1lbWJlcnNRdWVyeSBleHRlbmRzIFF1ZXJ5IHtcbiAgX2ZpeFByZWRpY2F0ZShpblZhbHVlKSB7XG4gICAgaWYgKGluVmFsdWUgPT09ICcnKSByZXR1cm4gJyc7XG4gICAgaWYgKGluVmFsdWUuaW5kZXhPZignY2hhbm5lbC5pZCcpICE9PSAtMSkge1xuICAgICAgbGV0IGNoYW5uZWxJZCA9IGluVmFsdWUubWF0Y2goZmluZENoYW5uZWxJZFJlZ2V4KSA/IGluVmFsdWUucmVwbGFjZShmaW5kQ2hhbm5lbElkUmVnZXgsICckMScpIDogbnVsbDtcbiAgICAgIGlmICghY2hhbm5lbElkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmludmFsaWRQcmVkaWNhdGUpO1xuICAgICAgaWYgKGNoYW5uZWxJZC5pbmRleE9mKCdsYXllcjovLy9jaGFubmVscy8nKSAhPT0gMCkgY2hhbm5lbElkID0gJ2xheWVyOi8vL2NoYW5uZWxzLycgKyBjaGFubmVsSWQ7XG4gICAgICByZXR1cm4gYGNoYW5uZWwuaWQgPSAnJHtjaGFubmVsSWR9J2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuaW52YWxpZFByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgQ2hhbm5lbCBVVUlEIGZyb20gdGhlIHByZWRpY2F0ZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogRXh0cmFjdCB0aGUgQ2hhbm5lbCdzIFVVSUQgZnJvbSB0aGUgcHJlZGljYXRlLi4uIG9yIHJldHVybmVkIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldENoYW5uZWxQcmVkaWNhdGVJZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDaGFubmVsUHJlZGljYXRlSWRzKCkge1xuICAgIGlmICh0aGlzLnByZWRpY2F0ZS5tYXRjaChmaW5kQ2hhbm5lbElkUmVnZXgpKSB7XG4gICAgICBjb25zdCBjaGFubmVsSWQgPSB0aGlzLnByZWRpY2F0ZS5yZXBsYWNlKGZpbmRDaGFubmVsSWRSZWdleCwgJyQxJyk7XG5cbiAgICAgIC8vIFdlIHdpbGwgYWxyZWFkeSBoYXZlIGEgdGhpcy5fcHJlZGljYXRlIGlmIHdlIGFyZSBwYWdpbmc7IGVsc2Ugd2UgbmVlZCB0byBleHRyYWN0IHRoZSBVVUlEIGZyb21cbiAgICAgIC8vIHRoZSBjaGFubmVsSWQuXG4gICAgICBjb25zdCB1dWlkID0gKHRoaXMuX3ByZWRpY2F0ZSB8fCBjaGFubmVsSWQpLnJlcGxhY2UoL15sYXllcjpcXC9cXC9cXC9jaGFubmVsc1xcLy8sICcnKTtcbiAgICAgIGlmICh1dWlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXVpZCxcbiAgICAgICAgICBpZDogY2hhbm5lbElkLFxuICAgICAgICAgIHR5cGU6IFF1ZXJ5LkNoYW5uZWwsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICBfZmV0Y2hEYXRhKHBhZ2VTaXplKSB7XG4gICAgY29uc3QgcHJlZGljYXRlSWRzID0gdGhpcy5fZ2V0Q2hhbm5lbFByZWRpY2F0ZUlkcygpO1xuXG4gICAgLy8gRG8gbm90aGluZyBpZiB3ZSBkb24ndCBoYXZlIGEgY29udmVyc2F0aW9uIHRvIHF1ZXJ5IG9uXG4gICAgaWYgKCFwcmVkaWNhdGVJZHMpIHtcbiAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSAmJiAhdGhpcy5wcmVkaWNhdGUubWF0Y2goL1snXCJdLykpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKCdUaGlzIHF1ZXJ5IG1heSBuZWVkIHRvIHF1b3RlIGl0cyB2YWx1ZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5uZWxJZCA9ICdsYXllcjovLy9jaGFubmVscy8nICsgcHJlZGljYXRlSWRzLnV1aWQ7XG4gICAgaWYgKCF0aGlzLl9wcmVkaWNhdGUpIHRoaXMuX3ByZWRpY2F0ZSA9IHByZWRpY2F0ZUlkcy5pZDtcbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jbGllbnQuZ2V0Q2hhbm5lbChjaGFubmVsSWQpO1xuXG4gICAgY29uc3QgbmV3UmVxdWVzdCA9IGBjaGFubmVscy8ke3ByZWRpY2F0ZUlkcy51dWlkfS9tZW1iZXJzP3BhZ2Vfc2l6ZT0ke3BhZ2VTaXplfWAgK1xuICAgICAgKHRoaXMuX25leHRTZXJ2ZXJGcm9tSWQgPyAnJmZyb21faWQ9JyArIHRoaXMuX25leHRTZXJ2ZXJGcm9tSWQgOiAnJyk7XG5cbiAgICAvLyBEb24ndCBxdWVyeSBvbiB1bnNhdmVkIGNoYW5uZWxzLCBub3IgcmVwZWF0IHN0aWxsIGZpcmluZyBxdWVyaWVzXG4gICAgaWYgKCghY2hhbm5lbCB8fCBjaGFubmVsLmlzU2F2ZWQoKSkgJiYgbmV3UmVxdWVzdCAhPT0gdGhpcy5fZmlyaW5nUmVxdWVzdCkge1xuICAgICAgdGhpcy5pc0ZpcmluZyA9IHRydWU7XG4gICAgICB0aGlzLl9maXJpbmdSZXF1ZXN0ID0gbmV3UmVxdWVzdDtcbiAgICAgIHRoaXMuY2xpZW50Lnhocih7XG4gICAgICAgIHRlbGVtZXRyeToge1xuICAgICAgICAgIG5hbWU6ICdtZW1iZXJfcXVlcnlfdGltZScsXG4gICAgICAgIH0sXG4gICAgICAgIHVybDogbmV3UmVxdWVzdCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc3luYzogZmFsc2UsXG4gICAgICB9LCByZXN1bHRzID0+IHRoaXMuX3Byb2Nlc3NSdW5SZXN1bHRzKHJlc3VsdHMsIG5ld1JlcXVlc3QsIHBhZ2VTaXplKSk7XG4gICAgfVxuICB9XG5cbiAgX2FwcGVuZFJlc3VsdHNTcGxpY2UoaXRlbSkge1xuICAgIHRoaXMuZGF0YS5wdXNoKHRoaXMuX2dldERhdGEoaXRlbSkpO1xuICB9XG5cblxuICBfaGFuZGxlRXZlbnRzKGV2ZW50TmFtZSwgZXZ0KSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcblxuICAgICAgLy8gSWYgYSBtZW1iZXIgaGFzIGNoYW5nZWQgYW5kIGl0cyBpbiBvdXIgcmVzdWx0IHNldCwgcmVwbGFjZVxuICAgICAgLy8gaXQgd2l0aCBhIG5ldyBpbW11dGFibGUgb2JqZWN0XG4gICAgICBjYXNlICdtZW1iZXJzOmNoYW5nZSc6XG4gICAgICAgIHRoaXMuX2hhbmRsZUNoYW5nZUV2ZW50KCdtZW1iZXJzJywgZXZ0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElmIG1lbWJlcnMgYXJlIGFkZGVkLCBhbmQgdGhleSBhcmVuJ3QgYWxyZWFkeSBpbiBvdXIgcmVzdWx0IHNldFxuICAgICAgLy8gYWRkIHRoZW0uXG4gICAgICBjYXNlICdtZW1iZXJzOmFkZCc6XG4gICAgICAgIHRoaXMuX2hhbmRsZUFkZEV2ZW50KCdtZW1iZXJzJywgZXZ0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElmIGEgSWRlbnRpdHkgaXMgZGVsZXRlZCBhbmQgaXRzIGluIG91ciByZXN1bHQgc2V0LCByZW1vdmUgaXRcbiAgICAgIC8vIGFuZCB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICBjYXNlICdtZW1iZXJzOnJlbW92ZSc6XG4gICAgICAgIHRoaXMuX2hhbmRsZVJlbW92ZUV2ZW50KCdtZW1iZXJzJywgZXZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbk1lbWJlcnNRdWVyeS5fc3VwcG9ydGVkRXZlbnRzID0gW1xuXG5dLmNvbmNhdChRdWVyeS5fc3VwcG9ydGVkRXZlbnRzKTtcblxuXG5NZW1iZXJzUXVlcnkuTWF4UGFnZVNpemUgPSA1MDA7XG5cbk1lbWJlcnNRdWVyeS5wcm90b3R5cGUubW9kZWwgPSBRdWVyeS5NZW1iZXJzaGlwO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShNZW1iZXJzUXVlcnksIFtNZW1iZXJzUXVlcnksICdNZW1iZXJzUXVlcnknXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyc1F1ZXJ5O1xuIl19
