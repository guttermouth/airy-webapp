'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The TypingIndicatorListener receives Typing Indicator state
 * for other users via a websocket, and notifies
 * the client of the updated state.  Typical applications
 * do not access this component directly, but DO subscribe
 * to events produced by this component:
 *
 *      client.on('typing-indicator-change', function(evt) {
 *        if (evt.conversationId == conversationICareAbout) {
 *          console.log('The following users are typing: ' + evt.typing.join(', '));
 *          console.log('The following users are paused: ' + evt.paused.join(', '));
 *        }
 *      });
 *
 * @class layer.TypingIndicators.TypingIndicatorListener
 * @extends {layer.Root}
 */

var Root = require('../root');
var ClientRegistry = require('../client-registry');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

var TypingIndicatorListener = function (_Root) {
  _inherits(TypingIndicatorListener, _Root);

  /**
   * Creates a Typing Indicator Listener for this Client.
   *
   * @method constructor
   * @protected
   * @param  {Object} args
   * @param {string} args.clientId - ID of the client this belongs to
   */
  function TypingIndicatorListener(args) {
    _classCallCheck(this, TypingIndicatorListener);

    /**
     * Stores the state of all Conversations, indicating who is typing and who is paused.
     *
     * People who are stopped are removed from this state.
     * @property {Object} state
     */
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TypingIndicatorListener).call(this, args));

    _this.state = {};
    _this._pollId = 0;
    var client = _this._getClient();
    client.on('ready', function () {
      return _this._clientReady();
    });
    return _this;
  }

  /**
   * Called when the client is ready
   *
   * @method _clientReady
   * @private
   */


  _createClass(TypingIndicatorListener, [{
    key: '_clientReady',
    value: function _clientReady() {
      var client = this._getClient();
      this.user = client.user;
      var ws = client.socketManager;
      ws.on('message', this._handleSocketEvent, this);
      this._startPolling();
    }

    /**
     * Determines if this event is relevant to report on.
     * Must be a typing indicator signal that is reporting on
     * someone other than this user.
     *
     * @method _isRelevantEvent
     * @private
     * @param  {Object}  Websocket event data
     * @return {Boolean}
     */

  }, {
    key: '_isRelevantEvent',
    value: function _isRelevantEvent(evt) {
      return evt.type === 'signal' && evt.body.type === 'typing_indicator' && evt.body.data.sender.id !== this.user.id;
    }

    /**
     * This method receives websocket events and
     * if they are typing indicator events, updates its state.
     *
     * @method _handleSocketEvent
     * @private
     * @param {layer.LayerEvent} evtIn - All websocket events
     */

  }, {
    key: '_handleSocketEvent',
    value: function _handleSocketEvent(evtIn) {
      var _this2 = this;

      var evt = evtIn.data;

      if (this._isRelevantEvent(evt)) {
        (function () {
          // Could just do _createObject() but for ephemeral events, going through _createObject and updating
          // objects for every typing indicator seems a bit much.  Try getIdentity and only create if needed.
          var identity = _this2._getClient().getIdentity(evt.body.data.sender.id) || _this2._getClient()._createObject(evt.body.data.sender);
          var state = evt.body.data.action;
          var conversationId = evt.body.object.id;
          var stateEntry = _this2.state[conversationId];
          if (!stateEntry) {
            stateEntry = _this2.state[conversationId] = {
              users: {},
              typing: [],
              paused: []
            };
          }
          stateEntry.users[identity.id] = {
            startTime: Date.now(),
            state: state,
            identity: identity
          };
          if (stateEntry.users[identity.id].state === FINISHED) {
            delete stateEntry.users[identity.id];
          }

          _this2._updateState(stateEntry, state, identity.id);

          _this2.trigger('typing-indicator-change', {
            conversationId: conversationId,
            typing: stateEntry.typing.map(function (id) {
              return stateEntry.users[id].identity.toObject();
            }),
            paused: stateEntry.paused.map(function (id) {
              return stateEntry.users[id].identity.toObject();
            })
          });
        })();
      }
    }

    /**
     * Get the current typing indicator state of a specified Conversation.
     *
     * Typically used to see if anyone is currently typing when first opening a Conversation.
     * Typically accessed via `client.getTypingState(conversationId)`
     *
     * @method getState
     * @param {String} conversationId
     */

  }, {
    key: 'getState',
    value: function getState(conversationId) {
      var stateEntry = this.state[conversationId];
      if (stateEntry) {
        return {
          typing: stateEntry.typing.map(function (id) {
            return stateEntry.users[id].identity.toObject();
          }),
          paused: stateEntry.paused.map(function (id) {
            return stateEntry.users[id].identity.toObject();
          })
        };
      } else {
        return {
          typing: [],
          paused: []
        };
      }
    }

    /**
     * Updates the state of a single stateEntry; a stateEntry
     * represents a single Conversation's typing indicator data.
     *
     * Updates typing and paused arrays following immutable strategies
     * in hope that this will help Flex based architectures.
     *
     * @method _updateState
     * @private
     * @param  {Object} stateEntry - A Conversation's typing indicator state
     * @param  {string} newState   - started, paused or finished
     * @param  {string} identityId     - ID of the user whose state has changed
     */

  }, {
    key: '_updateState',
    value: function _updateState(stateEntry, newState, identityId) {
      var typingIndex = stateEntry.typing.indexOf(identityId);
      if (newState !== STARTED && typingIndex !== -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing.slice(0, typingIndex)), _toConsumableArray(stateEntry.typing.slice(typingIndex + 1)));
      }
      var pausedIndex = stateEntry.paused.indexOf(identityId);
      if (newState !== PAUSED && pausedIndex !== -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused.slice(0, pausedIndex)), _toConsumableArray(stateEntry.paused.slice(pausedIndex + 1)));
      }

      if (newState === STARTED && typingIndex === -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing), [identityId]);
      } else if (newState === PAUSED && pausedIndex === -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused), [identityId]);
      }
    }

    /**
     * Any time a state change becomes more than 6 seconds stale,
     * assume that the user is 'finished'.
     *
     * In theory, we should
     * receive a new event every 2.5 seconds.  If the current user
     * has gone offline, lack of this code would cause the people
     * currently flagged as typing as still typing hours from now.
     *
     * For this first pass, we just mark the user as 'finished'
     * but a future pass may move from 'started' to 'paused'
     * and 'paused to 'finished'
     *
     * @method _startPolling
     * @private
     */

  }, {
    key: '_startPolling',
    value: function _startPolling() {
      var _this3 = this;

      if (this._pollId) return;
      this._pollId = setInterval(function () {
        return _this3._poll();
      }, 5000);
    }
  }, {
    key: '_poll',
    value: function _poll() {
      var _this4 = this;

      var conversationIds = Object.keys(this.state);

      conversationIds.forEach(function (id) {
        var state = _this4.state[id];
        Object.keys(state.users).forEach(function (identityId) {
          if (Date.now() >= state.users[identityId].startTime + 6000) {
            _this4._updateState(state, FINISHED, identityId);
            delete state.users[identityId];
            _this4.trigger('typing-indicator-change', {
              conversationId: id,
              typing: state.typing.map(function (aIdentityId) {
                return state.users[aIdentityId].identity.toObject();
              }),
              paused: state.paused.map(function (aIdentityId) {
                return state.users[aIdentityId].identity.toObject();
              })
            });
          }
        });
      });
    }

    /**
     * Get the Client associated with this class.  Uses the clientId
     * property.
     *
     * @method _getClient
     * @protected
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }
  }]);

  return TypingIndicatorListener;
}(Root);

/**
 * setTimeout ID for polling for states to transition
 * @type {Number}
 * @private
 */


TypingIndicatorListener.prototype._pollId = 0;

/**
 * ID of the client this instance is associated with
 * @type {String}
 */
TypingIndicatorListener.prototype.clientId = '';

TypingIndicatorListener.bubbleEventParent = '_getClient';

TypingIndicatorListener._supportedEvents = [
/**
 * There has been a change in typing indicator state of other users.
 * @event change
 * @param {layer.LayerEvent} evt
 * @param {layer.Identity[]} evt.typing - Array of Identities of people who are typing
 * @param {layer.Identity[]} evt.paused - Array of Identities of people who are paused
 * @param {string} evt.conversationId - ID of the Conversation that has changed typing indicator state
 */
'typing-indicator-change'].concat(Root._supportedEvents);

Root.initClass.apply(TypingIndicatorListener, [TypingIndicatorListener, 'TypingIndicatorListener']);
module.exports = TypingIndicatorListener;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctaW5kaWNhdG9yLWxpc3RlbmVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiO0FBQ0EsSUFBTSxpQkFBaUIsUUFBUSxvQkFBUixDQUF2Qjs7ZUFDc0MsUUFBUSxxQkFBUixDOztJQUE5QixPLFlBQUEsTztJQUFTLE0sWUFBQSxNO0lBQVEsUSxZQUFBLFE7O0lBRW5CLHVCOzs7QUFFSjs7Ozs7Ozs7QUFRQSxtQ0FBWSxJQUFaLEVBQWtCO0FBQUE7O0FBR2hCOzs7Ozs7QUFIZ0IsMkdBQ1YsSUFEVTs7QUFTaEIsVUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLFVBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxRQUFNLFNBQVMsTUFBSyxVQUFMLEVBQWY7QUFDQSxXQUFPLEVBQVAsQ0FBVSxPQUFWLEVBQW1CO0FBQUEsYUFBTSxNQUFLLFlBQUwsRUFBTjtBQUFBLEtBQW5CO0FBWmdCO0FBYWpCOztBQUVEOzs7Ozs7Ozs7O21DQU1lO0FBQ2IsVUFBTSxTQUFTLEtBQUssVUFBTCxFQUFmO0FBQ0EsV0FBSyxJQUFMLEdBQVksT0FBTyxJQUFuQjtBQUNBLFVBQU0sS0FBSyxPQUFPLGFBQWxCO0FBQ0EsU0FBRyxFQUFILENBQU0sU0FBTixFQUFpQixLQUFLLGtCQUF0QixFQUEwQyxJQUExQztBQUNBLFdBQUssYUFBTDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O3FDQVVpQixHLEVBQUs7QUFDcEIsYUFBTyxJQUFJLElBQUosS0FBYSxRQUFiLElBQ0wsSUFBSSxJQUFKLENBQVMsSUFBVCxLQUFrQixrQkFEYixJQUVMLElBQUksSUFBSixDQUFTLElBQVQsQ0FBYyxNQUFkLENBQXFCLEVBQXJCLEtBQTRCLEtBQUssSUFBTCxDQUFVLEVBRnhDO0FBR0Q7O0FBRUQ7Ozs7Ozs7Ozs7O3VDQVFtQixLLEVB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QixFQUF5QixRQUF6QixFQUFtQyxVQUFuQztBQUNBLG1CQUFPLE1BQU0sS0FBTixDQUFZLFVBQVosQ0FBUDtBQUNBLG1CQUFLLE9BQUwsQ0FBYSx5QkFBYixFQUF3QztBQUN0Qyw4QkFBZ0IsRUFEc0I7QUFFdEMsc0JBQVEsTUFBTSxNQUFOLENBQWEsR0FBYixDQUFpQjtBQUFBLHVCQUFlLE1BQU0sS0FBTixDQUFZLFdBQVosRUFBeUIsUUFBekIsQ0FBa0MsUUFBbEMsRUFBZjtBQUFBLGVBQWpCLENBRjhCO0FBR3RDLHNCQUFRLE1BQU0sTUFBTixDQUFhLEdBQWIsQ0FBaUI7QUFBQSx1QkFBZSxNQUFNLEtBQU4sQ0FBWSxXQUFaLEVBQXlCLFFBQXpCLENBQWtDLFFBQWxDLEVBQWY7QUFBQSxlQUFqQjtBQUg4QixhQUF4QztBQUtEO0FBQ0YsU0FYSDtBQVlELE9BZEQ7QUFlRDs7QUFFRDs7Ozs7Ozs7Ozs7aUNBUWE7QUFDWCxhQUFPLGVBQWUsR0FBZixDQUFtQixLQUFLLFFBQXhCLENBQVA7QUFDRDs7OztFQXBObUMsSTs7QUF1TnRDOzs7Ozs7O0FBS0Esd0JBQXdCLFNBQXhCLENBQWtDLE9BQWxDLEdBQTRDLENBQTVDOztBQUVBOzs7O0FBSUEsd0JBQXdCLFNBQXhCLENBQWtDLFFBQWxDLEdBQTZDLEVBQTdDOztBQUVBLHdCQUF3QixpQkFBeEIsR0FBNEMsWUFBNUM7O0FBR0Esd0JBQXdCLGdCQUF4QixHQUEyQztBQUN6Qzs7Ozs7Ozs7QUFRQSx5QkFUeUMsRUFVekMsTUFWeUMsQ0FVbEMsS0FBSyxnQkFWNkIsQ0FBM0M7O0FBWUEsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQix1QkFBckIsRUFBOEMsQ0FBQyx1QkFBRCxFQUEwQix5QkFBMUIsQ0FBOUM7QUFDQSxPQUFPLE9BQVAsR0FBaUIsdUJBQWpCIiwiZmlsZSI6InR5cGluZy1pbmRpY2F0b3ItbGlzdGVuZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBUeXBpbmdJbmRpY2F0b3JMaXN0ZW5lciByZWNlaXZlcyBUeXBpbmcgSW5kaWNhdG9yIHN0YXRlXG4gKiBmb3Igb3RoZXIgdXNlcnMgdmlhIGEgd2Vic29ja2V0LCBhbmQgbm90aWZpZXNcbiAqIHRoZSBjbGllbnQgb2YgdGhlIHVwZGF0ZWQgc3RhdGUuICBUeXBpY2FsIGFwcGxpY2F0aW9uc1xuICogZG8gbm90IGFjY2VzcyB0aGlzIGNvbXBvbmVudCBkaXJlY3RseSwgYnV0IERPIHN1YnNjcmliZVxuICogdG8gZXZlbnRzIHByb2R1Y2VkIGJ5IHRoaXMgY29tcG9uZW50OlxuICpcbiAqICAgICAgY2xpZW50Lm9uKCd0eXBpbmctaW5kaWNhdG9yLWNoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICogICAgICAgIGlmIChldnQuY29udmVyc2F0aW9uSWQgPT0gY29udmVyc2F0aW9uSUNhcmVBYm91dCkge1xuICogICAgICAgICAgY29uc29sZS5sb2coJ1RoZSBmb2xsb3dpbmcgdXNlcnMgYXJlIHR5cGluZzogJyArIGV2dC50eXBpbmcuam9pbignLCAnKSk7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIGZvbGxvd2luZyB1c2VycyBhcmUgcGF1c2VkOiAnICsgZXZ0LnBhdXNlZC5qb2luKCcsICcpKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBjbGFzcyBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ0luZGljYXRvckxpc3RlbmVyXG4gKiBAZXh0ZW5kcyB7bGF5ZXIuUm9vdH1cbiAqL1xuXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi4vcm9vdCcpO1xuY29uc3QgQ2xpZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuLi9jbGllbnQtcmVnaXN0cnknKTtcbmNvbnN0IHsgU1RBUlRFRCwgUEFVU0VELCBGSU5JU0hFRCB9ID0gcmVxdWlyZSgnLi90eXBpbmctaW5kaWNhdG9ycycpO1xuXG5jbGFzcyBUeXBpbmdJbmRpY2F0b3JMaXN0ZW5lciBleHRlbmRzIFJvb3Qge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgVHlwaW5nIEluZGljYXRvciBMaXN0ZW5lciBmb3IgdGhpcyBDbGllbnQuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY2xpZW50SWQgLSBJRCBvZiB0aGUgY2xpZW50IHRoaXMgYmVsb25ncyB0b1xuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBzdGF0ZSBvZiBhbGwgQ29udmVyc2F0aW9ucywgaW5kaWNhdGluZyB3aG8gaXMgdHlwaW5nIGFuZCB3aG8gaXMgcGF1c2VkLlxuICAgICAqXG4gICAgICogUGVvcGxlIHdobyBhcmUgc3RvcHBlZCBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0YXRlXG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMuX3BvbGxJZCA9IDA7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fZ2V0Q2xpZW50KCk7XG4gICAgY2xpZW50Lm9uKCdyZWFkeScsICgpID0+IHRoaXMuX2NsaWVudFJlYWR5KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBjbGllbnQgaXMgcmVhZHlcbiAgICpcbiAgICogQG1ldGhvZCBfY2xpZW50UmVhZHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGllbnRSZWFkeSgpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9nZXRDbGllbnQoKTtcbiAgICB0aGlzLnVzZXIgPSBjbGllbnQudXNlcjtcbiAgICBjb25zdCB3cyA9IGNsaWVudC5zb2NrZXRNYW5hZ2VyO1xuICAgIHdzLm9uKCdtZXNzYWdlJywgdGhpcy5faGFuZGxlU29ja2V0RXZlbnQsIHRoaXMpO1xuICAgIHRoaXMuX3N0YXJ0UG9sbGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhpcyBldmVudCBpcyByZWxldmFudCB0byByZXBvcnQgb24uXG4gICAqIE11c3QgYmUgYSB0eXBpbmcgaW5kaWNhdG9yIHNpZ25hbCB0aGF0IGlzIHJlcG9ydGluZyBvblxuICAgKiBzb21lb25lIG90aGVyIHRoYW4gdGhpcyB1c2VyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9pc1JlbGV2YW50RXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgV2Vic29ja2V0IGV2ZW50IGRhdGFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc1JlbGV2YW50RXZlbnQoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50eXBlID09PSAnc2lnbmFsJyAmJlxuICAgICAgZXZ0LmJvZHkudHlwZSA9PT0gJ3R5cGluZ19pbmRpY2F0b3InICYmXG4gICAgICBldnQuYm9keS5kYXRhLnNlbmRlci5pZCAhPT0gdGhpcy51c2VyLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlY2VpdmVzIHdlYnNvY2tldCBldmVudHMgYW5kXG4gICAqIGlmIHRoZXkgYXJlIHR5cGluZyBpbmRpY2F0b3IgZXZlbnRzLCB1cGRhdGVzIGl0cyBzdGF0ZS5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlU29ja2V0RXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRJbiAtIEFsbCB3ZWJzb2NrZXQgZXZlbnRzXG4gICAqL1xuICBfaGFuZGxlU29ja2V0RXZlbnQoZXZ0SW4pIHtcbiAgICBjb25zdCBldnQgPSBldnRJbi5kYXRhO1xuXG4gICAgaWYgKHRoaXMuX2lzUmVsZXZhbnRFdmVudChldnQpKSB7XG4gICAgICAvLyBDb3VsZCBqdXN0IGRvIF9jcmVhdGVPYmplY3QoKSBidXQgZm9yIGVwaGVtZXJhbCBldmVudHMsIGdvaW5nIHRocm91Z2ggX2NyZWF0ZU9iamVjdCBhbmQgdXBkYXRpbmdcbiAgICAgIC8vIG9iamVjdHMgZm9yIGV2ZXJ5IHR5cGluZyBpbmRpY2F0b3Igc2VlbXMgYSBiaXQgbXVjaC4gIFRyeSBnZXRJZGVudGl0eSBhbmQgb25seSBjcmVhdGUgaWYgbmVlZGVkLlxuICAgICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLl9nZXRDbGllbnQoKS5nZXRJZGVudGl0eShldnQuYm9keS5kYXRhLnNlbmRlci5pZCkgfHxcbiAgICAgICAgdGhpcy5fZ2V0Q2xpZW50KCkuX2NyZWF0ZU9iamVjdChldnQuYm9keS5kYXRhLnNlbmRlcik7XG4gICAgICBjb25zdCBzdGF0ZSA9IGV2dC5ib2R5LmRhdGEuYWN0aW9uO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uSWQgPSBldnQuYm9keS5vYmplY3QuaWQ7XG4gICAgICBsZXQgc3RhdGVFbnRyeSA9IHRoaXMuc3RhdGVbY29udmVyc2F0aW9uSWRdO1xuICAgICAgaWYgKCFzdGF0ZUVudHJ5KSB7XG4gICAgICAgIHN0YXRlRW50cnkgPSB0aGlzLnN0YXRlW2NvbnZlcnNhdGlvbklkXSA9IHtcbiAgICAgICAgICB1c2Vyczoge30sXG4gICAgICAgICAgdHlwaW5nOiBbXSxcbiAgICAgICAgICBwYXVzZWQ6IFtdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGVFbnRyeS51c2Vyc1tpZGVudGl0eS5pZF0gPSB7XG4gICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGlkZW50aXR5LFxuICAgICAgfTtcbiAgICAgIGlmIChzdGF0ZUVudHJ5LnVzZXJzW2lkZW50aXR5LmlkXS5zdGF0ZSA9PT0gRklOSVNIRUQpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlRW50cnkudXNlcnNbaWRlbnRpdHkuaWRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZShzdGF0ZUVudHJ5LCBzdGF0ZSwgaWRlbnRpdHkuaWQpO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3R5cGluZy1pbmRpY2F0b3ItY2hhbmdlJywge1xuICAgICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgdHlwaW5nOiBzdGF0ZUVudHJ5LnR5cGluZy5tYXAoaWQgPT4gc3RhdGVFbnRyeS51c2Vyc1tpZF0uaWRlbnRpdHkudG9PYmplY3QoKSksXG4gICAgICAgIHBhdXNlZDogc3RhdGVFbnRyeS5wYXVzZWQubWFwKGlkID0+IHN0YXRlRW50cnkudXNlcnNbaWRdLmlkZW50aXR5LnRvT2JqZWN0KCkpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlIG9mIGEgc3BlY2lmaWVkIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogVHlwaWNhbGx5IHVzZWQgdG8gc2VlIGlmIGFueW9uZSBpcyBjdXJyZW50bHkgdHlwaW5nIHdoZW4gZmlyc3Qgb3BlbmluZyBhIENvbnZlcnNhdGlvbi5cbiAgICogVHlwaWNhbGx5IGFjY2Vzc2VkIHZpYSBgY2xpZW50LmdldFR5cGluZ1N0YXRlKGNvbnZlcnNhdGlvbklkKWBcbiAgICpcbiAgICogQG1ldGhvZCBnZXRTdGF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29udmVyc2F0aW9uSWRcbiAgICovXG4gIGdldFN0YXRlKGNvbnZlcnNhdGlvbklkKSB7XG4gICAgY29uc3Qgc3RhdGVFbnRyeSA9IHRoaXMuc3RhdGVbY29udmVyc2F0aW9uSWRdO1xuICAgIGlmIChzdGF0ZUVudHJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBpbmc6IHN0YXRlRW50cnkudHlwaW5nLm1hcChpZCA9PiBzdGF0ZUVudHJ5LnVzZXJzW2lkXS5pZGVudGl0eS50b09iamVjdCgpKSxcbiAgICAgICAgcGF1c2VkOiBzdGF0ZUVudHJ5LnBhdXNlZC5tYXAoaWQgPT4gc3RhdGVFbnRyeS51c2Vyc1tpZF0uaWRlbnRpdHkudG9PYmplY3QoKSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBpbmc6IFtdLFxuICAgICAgICBwYXVzZWQ6IFtdLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgYSBzaW5nbGUgc3RhdGVFbnRyeTsgYSBzdGF0ZUVudHJ5XG4gICAqIHJlcHJlc2VudHMgYSBzaW5nbGUgQ29udmVyc2F0aW9uJ3MgdHlwaW5nIGluZGljYXRvciBkYXRhLlxuICAgKlxuICAgKiBVcGRhdGVzIHR5cGluZyBhbmQgcGF1c2VkIGFycmF5cyBmb2xsb3dpbmcgaW1tdXRhYmxlIHN0cmF0ZWdpZXNcbiAgICogaW4gaG9wZSB0aGF0IHRoaXMgd2lsbCBoZWxwIEZsZXggYmFzZWQgYXJjaGl0ZWN0dXJlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfdXBkYXRlU3RhdGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZUVudHJ5IC0gQSBDb252ZXJzYXRpb24ncyB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmV3U3RhdGUgICAtIHN0YXJ0ZWQsIHBhdXNlZCBvciBmaW5pc2hlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkZW50aXR5SWQgICAgIC0gSUQgb2YgdGhlIHVzZXIgd2hvc2Ugc3RhdGUgaGFzIGNoYW5nZWRcbiAgICovXG4gIF91cGRhdGVTdGF0ZShzdGF0ZUVudHJ5LCBuZXdTdGF0ZSwgaWRlbnRpdHlJZCkge1xuICAgIGNvbnN0IHR5cGluZ0luZGV4ID0gc3RhdGVFbnRyeS50eXBpbmcuaW5kZXhPZihpZGVudGl0eUlkKTtcbiAgICBpZiAobmV3U3RhdGUgIT09IFNUQVJURUQgJiYgdHlwaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICBzdGF0ZUVudHJ5LnR5cGluZyA9IFtcbiAgICAgICAgLi4uc3RhdGVFbnRyeS50eXBpbmcuc2xpY2UoMCwgdHlwaW5nSW5kZXgpLFxuICAgICAgICAuLi5zdGF0ZUVudHJ5LnR5cGluZy5zbGljZSh0eXBpbmdJbmRleCArIDEpLFxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcGF1c2VkSW5kZXggPSBzdGF0ZUVudHJ5LnBhdXNlZC5pbmRleE9mKGlkZW50aXR5SWQpO1xuICAgIGlmIChuZXdTdGF0ZSAhPT0gUEFVU0VEICYmIHBhdXNlZEluZGV4ICE9PSAtMSkge1xuICAgICAgc3RhdGVFbnRyeS5wYXVzZWQgPSBbXG4gICAgICAgIC4uLnN0YXRlRW50cnkucGF1c2VkLnNsaWNlKDAsIHBhdXNlZEluZGV4KSxcbiAgICAgICAgLi4uc3RhdGVFbnRyeS5wYXVzZWQuc2xpY2UocGF1c2VkSW5kZXggKyAxKSxcbiAgICAgIF07XG4gICAgfVxuXG5cbiAgICBpZiAobmV3U3RhdGUgPT09IFNUQVJURUQgJiYgdHlwaW5nSW5kZXggPT09IC0xKSB7XG4gICAgICBzdGF0ZUVudHJ5LnR5cGluZyA9IFsuLi5zdGF0ZUVudHJ5LnR5cGluZywgaWRlbnRpdHlJZF07XG4gICAgfSBlbHNlIGlmIChuZXdTdGF0ZSA9PT0gUEFVU0VEICYmIHBhdXNlZEluZGV4ID09PSAtMSkge1xuICAgICAgc3RhdGVFbnRyeS5wYXVzZWQgPSBbLi4uc3RhdGVFbnRyeS5wYXVzZWQsIGlkZW50aXR5SWRdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgdGltZSBhIHN0YXRlIGNoYW5nZSBiZWNvbWVzIG1vcmUgdGhhbiA2IHNlY29uZHMgc3RhbGUsXG4gICAqIGFzc3VtZSB0aGF0IHRoZSB1c2VyIGlzICdmaW5pc2hlZCcuXG4gICAqXG4gICAqIEluIHRoZW9yeSwgd2Ugc2hvdWxkXG4gICAqIHJlY2VpdmUgYSBuZXcgZXZlbnQgZXZlcnkgMi41IHNlY29uZHMuICBJZiB0aGUgY3VycmVudCB1c2VyXG4gICAqIGhhcyBnb25lIG9mZmxpbmUsIGxhY2sgb2YgdGhpcyBjb2RlIHdvdWxkIGNhdXNlIHRoZSBwZW9wbGVcbiAgICogY3VycmVudGx5IGZsYWdnZWQgYXMgdHlwaW5nIGFzIHN0aWxsIHR5cGluZyBob3VycyBmcm9tIG5vdy5cbiAgICpcbiAgICogRm9yIHRoaXMgZmlyc3QgcGFzcywgd2UganVzdCBtYXJrIHRoZSB1c2VyIGFzICdmaW5pc2hlZCdcbiAgICogYnV0IGEgZnV0dXJlIHBhc3MgbWF5IG1vdmUgZnJvbSAnc3RhcnRlZCcgdG8gJ3BhdXNlZCdcbiAgICogYW5kICdwYXVzZWQgdG8gJ2ZpbmlzaGVkJ1xuICAgKlxuICAgKiBAbWV0aG9kIF9zdGFydFBvbGxpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydFBvbGxpbmcoKSB7XG4gICAgaWYgKHRoaXMuX3BvbGxJZCkgcmV0dXJuO1xuICAgIHRoaXMuX3BvbGxJZCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3BvbGwoKSwgNTAwMCk7XG4gIH1cblxuICBfcG9sbCgpIHtcbiAgICBjb25zdCBjb252ZXJzYXRpb25JZHMgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlKTtcblxuICAgIGNvbnZlcnNhdGlvbklkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlW2lkXTtcbiAgICAgIE9iamVjdC5rZXlzKHN0YXRlLnVzZXJzKVxuICAgICAgICAuZm9yRWFjaCgoaWRlbnRpdHlJZCkgPT4ge1xuICAgICAgICAgIGlmIChEYXRlLm5vdygpID49IHN0YXRlLnVzZXJzW2lkZW50aXR5SWRdLnN0YXJ0VGltZSArIDYwMDApIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlKHN0YXRlLCBGSU5JU0hFRCwgaWRlbnRpdHlJZCk7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUudXNlcnNbaWRlbnRpdHlJZF07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3R5cGluZy1pbmRpY2F0b3ItY2hhbmdlJywge1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZDogaWQsXG4gICAgICAgICAgICAgIHR5cGluZzogc3RhdGUudHlwaW5nLm1hcChhSWRlbnRpdHlJZCA9PiBzdGF0ZS51c2Vyc1thSWRlbnRpdHlJZF0uaWRlbnRpdHkudG9PYmplY3QoKSksXG4gICAgICAgICAgICAgIHBhdXNlZDogc3RhdGUucGF1c2VkLm1hcChhSWRlbnRpdHlJZCA9PiBzdGF0ZS51c2Vyc1thSWRlbnRpdHlJZF0uaWRlbnRpdHkudG9PYmplY3QoKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgQ2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNsYXNzLiAgVXNlcyB0aGUgY2xpZW50SWRcbiAgICogcHJvcGVydHkuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldENsaWVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudH1cbiAgICovXG4gIF9nZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIENsaWVudFJlZ2lzdHJ5LmdldCh0aGlzLmNsaWVudElkKTtcbiAgfVxufVxuXG4vKipcbiAqIHNldFRpbWVvdXQgSUQgZm9yIHBvbGxpbmcgZm9yIHN0YXRlcyB0byB0cmFuc2l0aW9uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVHlwaW5nSW5kaWNhdG9yTGlzdGVuZXIucHJvdG90eXBlLl9wb2xsSWQgPSAwO1xuXG4vKipcbiAqIElEIG9mIHRoZSBjbGllbnQgdGhpcyBpbnN0YW5jZSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblR5cGluZ0luZGljYXRvckxpc3RlbmVyLnByb3RvdHlwZS5jbGllbnRJZCA9ICcnO1xuXG5UeXBpbmdJbmRpY2F0b3JMaXN0ZW5lci5idWJibGVFdmVudFBhcmVudCA9ICdfZ2V0Q2xpZW50JztcblxuXG5UeXBpbmdJbmRpY2F0b3JMaXN0ZW5lci5fc3VwcG9ydGVkRXZlbnRzID0gW1xuICAvKipcbiAgICogVGhlcmUgaGFzIGJlZW4gYSBjaGFuZ2UgaW4gdHlwaW5nIGluZGljYXRvciBzdGF0ZSBvZiBvdGhlciB1c2Vycy5cbiAgICogQGV2ZW50IGNoYW5nZVxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLklkZW50aXR5W119IGV2dC50eXBpbmcgLSBBcnJheSBvZiBJZGVudGl0aWVzIG9mIHBlb3BsZSB3aG8gYXJlIHR5cGluZ1xuICAgKiBAcGFyYW0ge2xheWVyLklkZW50aXR5W119IGV2dC5wYXVzZWQgLSBBcnJheSBvZiBJZGVudGl0aWVzIG9mIHBlb3BsZSB3aG8gYXJlIHBhdXNlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0LmNvbnZlcnNhdGlvbklkIC0gSUQgb2YgdGhlIENvbnZlcnNhdGlvbiB0aGF0IGhhcyBjaGFuZ2VkIHR5cGluZyBpbmRpY2F0b3Igc3RhdGVcbiAgICovXG4gICd0eXBpbmctaW5kaWNhdG9yLWNoYW5nZScsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShUeXBpbmdJbmRpY2F0b3JMaXN0ZW5lciwgW1R5cGluZ0luZGljYXRvckxpc3RlbmVyLCAnVHlwaW5nSW5kaWNhdG9yTGlzdGVuZXInXSk7XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGluZ0luZGljYXRvckxpc3RlbmVyO1xuIl19
