'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TypingPublisher = require('./typing-publisher');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

/**
 * The Typing Listener Class listens to keyboard events on
 * your text field, and uses the layer.TypingPublisher to
 * send state based on keyboard behavior.
 *
 *      var typingListener = client.createTypingListener(document.getElementById('mytextarea'));
 *
 *  You change what Conversation
 *  the typing indicator reports your user to be typing
 *  in by calling:
 *
 *      typingListener.setConversation(mySelectedConversation);
 *
 * There are two ways of cleaning up all pointers to your input so it can be garbage collected:
 *
 * 1. Destroy the listener:
 *
 *        typingListener.destroy();
 *
 * 2. Remove or replace the input:
 *
 *        typingListener.setInput(null);
 *        typingListener.setInput(newInput);
 *
 * @class  layer.TypingIndicators.TypingListener
 */

var TypingListener = function () {

  /**
   * Create a TypingListener that listens for the user's typing.
   *
   * The TypingListener needs
   * to know what Conversation the user is typing into... but it does not require that parameter during initialization.
   *
   * @method constructor
   * @param  {Object} args
   * @param {string} args.clientId - The ID of the client; used so that the TypingPublisher can access its websocket manager*
   * @param {HTMLElement} [args.input=null] - A Text editor dom node that will have typing indicators
   * @param {Object} [args.conversation=null] - The Conversation Object or Instance that the input will send messages to
   */
  function TypingListener(args) {
    _classCallCheck(this, TypingListener);

    this.clientId = args.clientId;
    this.conversation = args.conversation;
    this.publisher = new TypingPublisher({
      clientId: this.clientId,
      conversation: this.conversation
    });

    this.intervalId = 0;
    this.lastKeyId = 0;

    this._handleKeyPress = this._handleKeyPress.bind(this);
    this._handleKeyDown = this._handleKeyDown.bind(this);
    this.setInput(args.input);
  }

  _createClass(TypingListener, [{
    key: 'destroy',
    value: function destroy() {
      this._removeInput(this.input);
      this.publisher.destroy();
    }

    /**
     * Change the input being tracked by your TypingListener.
     *
     * If you are removing your input from the DOM, you can simply call
     *
     *     typingListener.setInput(null);
     *
     * And all event handlers will be removed, allowing for garbage collection
     * to cleanup your input.
     *
     * You can also call setInput with a newly created input:
     *
     *     var input = document.createElement('input');
     *     typingListener.setInput(input);
     *
     * @method setInput
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: 'setInput',
    value: function setInput(input) {
      if (input !== this.input) {
        this._removeInput(this.input);
        this.input = input;

        // Use keypress rather than keydown because the user hitting alt-tab to change
        // windows, and other meta keys should not result in typing indicators
        this.input.addEventListener('keypress', this._handleKeyPress);
        this.input.addEventListener('keydown', this._handleKeyDown);
      }
    }

    /**
     * Cleanup and remove all links and callbacks keeping input from being garbage collected.
     *
     * @method _removeInput
     * @private
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: '_removeInput',
    value: function _removeInput(input) {
      if (input) {
        input.removeEventListener('keypress', this._handleKeyPress);
        input.removeEventListener('keydown', this._handleKeyDown);
        this.input = null;
      }
    }

    /**
     * Change the Conversation; this should set the state of the old Conversation to "finished".
     *
     * Use this when the user has changed Conversations and you want to report on typing to a new
     * Conversation.
     *
     * @method setConversation
     * @param  {Object} conv - The new Conversation Object or Instance
     */

  }, {
    key: 'setConversation',
    value: function setConversation(conv) {
      if (conv !== this.conversation) {
        this.conversation = conv;
        this.publisher.setConversation(conv);
      }
    }

    /**
     * Whenever the key is pressed, send a "started" or "finished" event.
     *
     * @method _handleKeyPress
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyPress',
    value: function _handleKeyPress(evt) {
      var _this = this;

      if (this.lastKeyId) window.clearTimeout(this.lastKeyId);
      this.lastKeyId = window.setTimeout(function () {
        _this.lastKeyId = 0;
        var isEmpty = !_this.input.value;
        _this.send(isEmpty ? FINISHED : STARTED);
      }, 50);
    }

    /**
     * Handles keyboard keys not reported by on by keypress events.
     *
     * These keys can be detected with keyDown event handlers. The ones
     * currently handled here are backspace, delete and enter.
     * We may add more later.
     *
     * @method _handleKeyDown
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(evt) {
      if ([8, 46, 13].indexOf(evt.keyCode) !== -1) this._handleKeyPress();
    }

    /**
     * Send the state to the publisher.
     *
     * If your application requires
     * you to directly control the state, you can call this method;
     * however, as long as you use this TypingListener, keyboard
     * events will overwrite any state changes you send.
     *
     * Common use case for this: After a message is sent, you want to clear any typing indicators:
     *
     *      function send() {
     *        message.send();
     *        typingIndicators.send(layer.TypingIndicators.FINISHED);
     *      }
     *
     * @method send
     * @param  {string} state - One of "started", "paused", "finished"
     */

  }, {
    key: 'send',
    value: function send(state) {
      this.publisher.setState(state);
    }
  }]);

  return TypingListener;
}();

module.exports = TypingListener;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctbGlzdGVuZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBTSxrQkFBa0IsUUFBUSxvQkFBUixDQUF4Qjs7ZUFDb0MsUUFBUSxxQkFBUixDOztJQUE3QixPLFlBQUEsTztJQUFTLE0sWUFBQSxNO0lBQVEsUSxZQUFBLFE7O0FBRXhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQk0sYzs7QUFFSjs7Ozs7Ozs7Ozs7O0FBWUEsMEJBQVksSUFBWixFQUFrQjtBQUFBOztBQUNoQixTQUFLLFFBQUwsR0FBZ0IsS0FBSyxRQUFyQjtBQUNBLFNBQUssWUFBTCxHQUFvQixLQUFLLFlBQXpCO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLElBQUksZUFBSixDQUFvQjtBQUNuQyxnQkFBVSxLQUFLLFFBRG9CO0FBRW5DLG9CQUFjLEtBQUs7QUFGZ0IsS0FBcEIsQ0FBakI7O0FBS0EsU0FBSyxVQUFMLEdBQWtCLENBQWxCO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLENBQWpCOztBQUVBLFNBQUssZUFBTCxHQUF1QixLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsQ0FBdkI7QUFDQSxTQUFLLGNBQUwsR0FBc0IsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLENBQXRCO0FBQ0EsU0FBSyxRQUFMLENBQWMsS0FBSyxLQUFuQjtBQUNEOzs7OzhCQUVTO0FBQ1IsV0FBSyxZQUFMLENBQWtCLEtBQUssS0FBdkI7QUFDQSxXQUFLLFNBQUwsQ0FBZSxPQUFmO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFrQlMsSyxFQUFPO0FBQ2QsVUFBSSxVQUFVLEtBQUssS0FBbkIsRUFBMEI7QUFDeEIsYUFBSyxZQUFMLENBQWtCLEtBQUssS0FBdkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiOztBQUVBO0FBQ0E7QUFDQSxhQUFLLEtBQUwsQ0FBVyxnQkFBWCxDQUE0QixVQUE1QixFQUF3QyxLQUFLLGVBQTdDO0FBQ0EsYUFBSyxLQUFMLENBQVcsZ0JBQVgsQ0FBNEIsU0FBNUIsRUFBdUMsS0FBSyxjQUE1QztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7aUNBT2EsSyxFQUFPO0FBQ2xCLFVBQUksS0FBSixFQUFXO0FBQ1QsY0FBTSxtQkFBTixDQUEwQixVQUExQixFQUFzQyxLQUFLLGVBQTNDO0FBQ0EsY0FBTSxtQkFBTixDQUEwQixTQUExQixFQUFxQyxLQUFLLGNBQTFDO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7OztvQ0FTZ0IsSSxFQUFNO0FBQ3BCLFVBQUksU0FBUyxLQUFLLFlBQWxCLEVBQWdDO0FBQzlCLGFBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLGFBQUssU0FBTCxDQUFlLGVBQWYsQ0FBK0IsSUFBL0I7QUFDRDtBQUNGOztBQUdEOzs7Ozs7Ozs7O29DQU9nQixHLEVBQUs7QUFBQTs7QUFDbkIsVUFBSSxLQUFLLFNBQVQsRUFBb0IsT0FBTyxZQUFQLENBQW9CLEtBQUssU0FBekI7QUFDcEIsV0FBSyxTQUFMLEdBQWlCLE9BQU8sVUFBUCxDQUFrQixZQUFNO0FBQ3ZDLGNBQUssU0FBTCxHQUFpQixDQUFqQjtBQUNBLFlBQU0sVUFBVSxDQUFDLE1BQUssS0FBTCxDQUFXLEtBQTVCO0FBQ0EsY0FBSyxJQUFMLENBQVUsVUFBVSxRQUFWLEdBQXFCLE9BQS9CO0FBQ0QsT0FKZ0IsRUFJZCxFQUpjLENBQWpCO0FBS0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O21DQVdlLEcsRUFBSztBQUNsQixVQUFJLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxFQUFSLEVBQVksT0FBWixDQUFvQixJQUFJLE9BQXhCLE1BQXFDLENBQUMsQ0FBMUMsRUFBNkMsS0FBSyxlQUFMO0FBQzlDOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBa0JLLEssRUFBTztBQUNWLFdBQUssU0FBTCxDQUFlLFFBQWYsQ0FBd0IsS0FBeEI7QUFDRDs7Ozs7O0FBR0gsT0FBTyxPQUFQLEdBQWlCLGNBQWpCIiwiZmlsZSI6InR5cGluZy1saXN0ZW5lci5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFR5cGluZ1B1Ymxpc2hlciA9IHJlcXVpcmUoJy4vdHlwaW5nLXB1Ymxpc2hlcicpO1xuY29uc3Qge1NUQVJURUQsIFBBVVNFRCwgRklOSVNIRUR9ID0gcmVxdWlyZSgnLi90eXBpbmctaW5kaWNhdG9ycycpO1xuXG4vKipcbiAqIFRoZSBUeXBpbmcgTGlzdGVuZXIgQ2xhc3MgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb25cbiAqIHlvdXIgdGV4dCBmaWVsZCwgYW5kIHVzZXMgdGhlIGxheWVyLlR5cGluZ1B1Ymxpc2hlciB0b1xuICogc2VuZCBzdGF0ZSBiYXNlZCBvbiBrZXlib2FyZCBiZWhhdmlvci5cbiAqXG4gKiAgICAgIHZhciB0eXBpbmdMaXN0ZW5lciA9IGNsaWVudC5jcmVhdGVUeXBpbmdMaXN0ZW5lcihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXl0ZXh0YXJlYScpKTtcbiAqXG4gKiAgWW91IGNoYW5nZSB3aGF0IENvbnZlcnNhdGlvblxuICogIHRoZSB0eXBpbmcgaW5kaWNhdG9yIHJlcG9ydHMgeW91ciB1c2VyIHRvIGJlIHR5cGluZ1xuICogIGluIGJ5IGNhbGxpbmc6XG4gKlxuICogICAgICB0eXBpbmdMaXN0ZW5lci5zZXRDb252ZXJzYXRpb24obXlTZWxlY3RlZENvbnZlcnNhdGlvbik7XG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIG9mIGNsZWFuaW5nIHVwIGFsbCBwb2ludGVycyB0byB5b3VyIGlucHV0IHNvIGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZDpcbiAqXG4gKiAxLiBEZXN0cm95IHRoZSBsaXN0ZW5lcjpcbiAqXG4gKiAgICAgICAgdHlwaW5nTGlzdGVuZXIuZGVzdHJveSgpO1xuICpcbiAqIDIuIFJlbW92ZSBvciByZXBsYWNlIHRoZSBpbnB1dDpcbiAqXG4gKiAgICAgICAgdHlwaW5nTGlzdGVuZXIuc2V0SW5wdXQobnVsbCk7XG4gKiAgICAgICAgdHlwaW5nTGlzdGVuZXIuc2V0SW5wdXQobmV3SW5wdXQpO1xuICpcbiAqIEBjbGFzcyAgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdMaXN0ZW5lclxuICovXG5jbGFzcyBUeXBpbmdMaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFR5cGluZ0xpc3RlbmVyIHRoYXQgbGlzdGVucyBmb3IgdGhlIHVzZXIncyB0eXBpbmcuXG4gICAqXG4gICAqIFRoZSBUeXBpbmdMaXN0ZW5lciBuZWVkc1xuICAgKiB0byBrbm93IHdoYXQgQ29udmVyc2F0aW9uIHRoZSB1c2VyIGlzIHR5cGluZyBpbnRvLi4uIGJ1dCBpdCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgcGFyYW1ldGVyIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY2xpZW50SWQgLSBUaGUgSUQgb2YgdGhlIGNsaWVudDsgdXNlZCBzbyB0aGF0IHRoZSBUeXBpbmdQdWJsaXNoZXIgY2FuIGFjY2VzcyBpdHMgd2Vic29ja2V0IG1hbmFnZXIqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFthcmdzLmlucHV0PW51bGxdIC0gQSBUZXh0IGVkaXRvciBkb20gbm9kZSB0aGF0IHdpbGwgaGF2ZSB0eXBpbmcgaW5kaWNhdG9yc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3MuY29udmVyc2F0aW9uPW51bGxdIC0gVGhlIENvbnZlcnNhdGlvbiBPYmplY3Qgb3IgSW5zdGFuY2UgdGhhdCB0aGUgaW5wdXQgd2lsbCBzZW5kIG1lc3NhZ2VzIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5jbGllbnRJZCA9IGFyZ3MuY2xpZW50SWQ7XG4gICAgdGhpcy5jb252ZXJzYXRpb24gPSBhcmdzLmNvbnZlcnNhdGlvbjtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBUeXBpbmdQdWJsaXNoZXIoe1xuICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICBjb252ZXJzYXRpb246IHRoaXMuY29udmVyc2F0aW9uLFxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnRlcnZhbElkID0gMDtcbiAgICB0aGlzLmxhc3RLZXlJZCA9IDA7XG5cbiAgICB0aGlzLl9oYW5kbGVLZXlQcmVzcyA9IHRoaXMuX2hhbmRsZUtleVByZXNzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlS2V5RG93biA9IHRoaXMuX2hhbmRsZUtleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldElucHV0KGFyZ3MuaW5wdXQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVJbnB1dCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLnB1Ymxpc2hlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBpbnB1dCBiZWluZyB0cmFja2VkIGJ5IHlvdXIgVHlwaW5nTGlzdGVuZXIuXG4gICAqXG4gICAqIElmIHlvdSBhcmUgcmVtb3ZpbmcgeW91ciBpbnB1dCBmcm9tIHRoZSBET00sIHlvdSBjYW4gc2ltcGx5IGNhbGxcbiAgICpcbiAgICogICAgIHR5cGluZ0xpc3RlbmVyLnNldElucHV0KG51bGwpO1xuICAgKlxuICAgKiBBbmQgYWxsIGV2ZW50IGhhbmRsZXJzIHdpbGwgYmUgcmVtb3ZlZCwgYWxsb3dpbmcgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgKiB0byBjbGVhbnVwIHlvdXIgaW5wdXQuXG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBjYWxsIHNldElucHV0IHdpdGggYSBuZXdseSBjcmVhdGVkIGlucHV0OlxuICAgKlxuICAgKiAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICogICAgIHR5cGluZ0xpc3RlbmVyLnNldElucHV0KGlucHV0KTtcbiAgICpcbiAgICogQG1ldGhvZCBzZXRJbnB1dFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCAtIFRleHRhcmVhIG9yIHRleHQgaW5wdXRcbiAgICovXG4gIHNldElucHV0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0ICE9PSB0aGlzLmlucHV0KSB7XG4gICAgICB0aGlzLl9yZW1vdmVJbnB1dCh0aGlzLmlucHV0KTtcbiAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICAgICAgLy8gVXNlIGtleXByZXNzIHJhdGhlciB0aGFuIGtleWRvd24gYmVjYXVzZSB0aGUgdXNlciBoaXR0aW5nIGFsdC10YWIgdG8gY2hhbmdlXG4gICAgICAvLyB3aW5kb3dzLCBhbmQgb3RoZXIgbWV0YSBrZXlzIHNob3VsZCBub3QgcmVzdWx0IGluIHR5cGluZyBpbmRpY2F0b3JzXG4gICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5faGFuZGxlS2V5UHJlc3MpO1xuICAgICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlS2V5RG93bik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFudXAgYW5kIHJlbW92ZSBhbGwgbGlua3MgYW5kIGNhbGxiYWNrcyBrZWVwaW5nIGlucHV0IGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgX3JlbW92ZUlucHV0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gVGV4dGFyZWEgb3IgdGV4dCBpbnB1dFxuICAgKi9cbiAgX3JlbW92ZUlucHV0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX2hhbmRsZUtleVByZXNzKTtcbiAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlEb3duKTtcbiAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIENvbnZlcnNhdGlvbjsgdGhpcyBzaG91bGQgc2V0IHRoZSBzdGF0ZSBvZiB0aGUgb2xkIENvbnZlcnNhdGlvbiB0byBcImZpbmlzaGVkXCIuXG4gICAqXG4gICAqIFVzZSB0aGlzIHdoZW4gdGhlIHVzZXIgaGFzIGNoYW5nZWQgQ29udmVyc2F0aW9ucyBhbmQgeW91IHdhbnQgdG8gcmVwb3J0IG9uIHR5cGluZyB0byBhIG5ld1xuICAgKiBDb252ZXJzYXRpb24uXG4gICAqXG4gICAqIEBtZXRob2Qgc2V0Q29udmVyc2F0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udiAtIFRoZSBuZXcgQ29udmVyc2F0aW9uIE9iamVjdCBvciBJbnN0YW5jZVxuICAgKi9cbiAgc2V0Q29udmVyc2F0aW9uKGNvbnYpIHtcbiAgICBpZiAoY29udiAhPT0gdGhpcy5jb252ZXJzYXRpb24pIHtcbiAgICAgIHRoaXMuY29udmVyc2F0aW9uID0gY29udjtcbiAgICAgIHRoaXMucHVibGlzaGVyLnNldENvbnZlcnNhdGlvbihjb252KTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUga2V5IGlzIHByZXNzZWQsIHNlbmQgYSBcInN0YXJ0ZWRcIiBvciBcImZpbmlzaGVkXCIgZXZlbnQuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZUtleVByZXNzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge0tleWJvYXJkRXZlbnR9IGV2dFxuICAgKi9cbiAgX2hhbmRsZUtleVByZXNzKGV2dCkge1xuICAgIGlmICh0aGlzLmxhc3RLZXlJZCkgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmxhc3RLZXlJZCk7XG4gICAgdGhpcy5sYXN0S2V5SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxhc3RLZXlJZCA9IDA7XG4gICAgICBjb25zdCBpc0VtcHR5ID0gIXRoaXMuaW5wdXQudmFsdWU7XG4gICAgICB0aGlzLnNlbmQoaXNFbXB0eSA/IEZJTklTSEVEIDogU1RBUlRFRCk7XG4gICAgfSwgNTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5Ym9hcmQga2V5cyBub3QgcmVwb3J0ZWQgYnkgb24gYnkga2V5cHJlc3MgZXZlbnRzLlxuICAgKlxuICAgKiBUaGVzZSBrZXlzIGNhbiBiZSBkZXRlY3RlZCB3aXRoIGtleURvd24gZXZlbnQgaGFuZGxlcnMuIFRoZSBvbmVzXG4gICAqIGN1cnJlbnRseSBoYW5kbGVkIGhlcmUgYXJlIGJhY2tzcGFjZSwgZGVsZXRlIGFuZCBlbnRlci5cbiAgICogV2UgbWF5IGFkZCBtb3JlIGxhdGVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge0tleWJvYXJkRXZlbnR9IGV2dFxuICAgKi9cbiAgX2hhbmRsZUtleURvd24oZXZ0KSB7XG4gICAgaWYgKFs4LCA0NiwgMTNdLmluZGV4T2YoZXZ0LmtleUNvZGUpICE9PSAtMSkgdGhpcy5faGFuZGxlS2V5UHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBzdGF0ZSB0byB0aGUgcHVibGlzaGVyLlxuICAgKlxuICAgKiBJZiB5b3VyIGFwcGxpY2F0aW9uIHJlcXVpcmVzXG4gICAqIHlvdSB0byBkaXJlY3RseSBjb250cm9sIHRoZSBzdGF0ZSwgeW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kO1xuICAgKiBob3dldmVyLCBhcyBsb25nIGFzIHlvdSB1c2UgdGhpcyBUeXBpbmdMaXN0ZW5lciwga2V5Ym9hcmRcbiAgICogZXZlbnRzIHdpbGwgb3ZlcndyaXRlIGFueSBzdGF0ZSBjaGFuZ2VzIHlvdSBzZW5kLlxuICAgKlxuICAgKiBDb21tb24gdXNlIGNhc2UgZm9yIHRoaXM6IEFmdGVyIGEgbWVzc2FnZSBpcyBzZW50LCB5b3Ugd2FudCB0byBjbGVhciBhbnkgdHlwaW5nIGluZGljYXRvcnM6XG4gICAqXG4gICAqICAgICAgZnVuY3Rpb24gc2VuZCgpIHtcbiAgICogICAgICAgIG1lc3NhZ2Uuc2VuZCgpO1xuICAgKiAgICAgICAgdHlwaW5nSW5kaWNhdG9ycy5zZW5kKGxheWVyLlR5cGluZ0luZGljYXRvcnMuRklOSVNIRUQpO1xuICAgKiAgICAgIH1cbiAgICpcbiAgICogQG1ldGhvZCBzZW5kXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgLSBPbmUgb2YgXCJzdGFydGVkXCIsIFwicGF1c2VkXCIsIFwiZmluaXNoZWRcIlxuICAgKi9cbiAgc2VuZChzdGF0ZSkge1xuICAgIHRoaXMucHVibGlzaGVyLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGluZ0xpc3RlbmVyO1xuIl19
