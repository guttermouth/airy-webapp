'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.RequestManager
 * @private
 *
 * This class allows one to send requests to the websocket server, and provide a callback,
 * And have that callback either called by the correct websocket server response, or
 * be called with a timeout.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var LayerError = require('../layer-error');

// Wait 15 seconds for a response and then give up
var DELAY_UNTIL_TIMEOUT = 15 * 1000;

var WebsocketRequestManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketRequestManager = new layer.Websockets.RequestManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.RequestManager}
   */
  function WebsocketRequestManager(options) {
    _classCallCheck(this, WebsocketRequestManager);

    this.client = options.client;
    this.socketManager = options.socketManager;
    this.socketManager.on({
      message: this._handleResponse,
      disconnected: this._reset
    }, this);

    this._requestCallbacks = {};
  }

  _createClass(WebsocketRequestManager, [{
    key: '_reset',
    value: function _reset() {
      this._requestCallbacks = {};
    }

    /**
     * This is an imprecise method; it will cancel ALL requests of a given type.
     *
     * @method cancelOperation
     * @param {String} methodName    `Message.create`, `Event.sync`, etc...
     */

  }, {
    key: 'cancelOperation',
    value: function cancelOperation(methodName) {
      var _this = this;

      Object.keys(this._requestCallbacks).forEach(function (key) {
        var requestConfig = _this._requestCallbacks[key];
        if (requestConfig.method === methodName) delete _this._requestCallbacks[key];
      });
    }

    /**
     * Handle a response to a request.
     *
     * @method _handleResponse
     * @private
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_handleResponse',
    value: function _handleResponse(evt) {
      if (evt.data.type === 'response') {
        var msg = evt.data.body;
        var requestId = msg.request_id;
        logger.debug('Websocket response ' + requestId + ' ' + (msg.success ? 'Successful' : 'Failed'));

        if (requestId && this._requestCallbacks[requestId]) {
          this._processResponse(requestId, evt);
        }
      }
    }

    /**
     * Process a response to a request; used by _handleResponse.
     *
     * Refactored out of _handleResponse so that unit tests can easily
     * use it to trigger completion of a request.
     *
     * @method _processResponse
     * @private
     * @param {String} requestId
     * @param {Object} evt   Data from the server
     */

  }, {
    key: '_processResponse',
    value: function _processResponse(requestId, evt) {
      var request = this._requestCallbacks[requestId];
      var msg = evt.data.body;
      var data = (msg.success ? msg.data : new LayerError(msg.data)) || {};

      if (msg.success) {
        if (request.isChangesArray) {
          this._handleChangesArray(data.changes);
        }
        if ('batch' in data) {
          request.batchTotal = data.batch.count;
          request.batchIndex = data.batch.index;
          if (request.isChangesArray) {
            request.results = request.results.concat(data.changes);
          } else if ('results' in data && Array.isArray(data.results)) {
            request.results = request.results.concat(data.results);
          }
          if (data.batch.index < data.batch.count - 1) return;
        }
      }
      request.callback({
        success: msg.success,
        fullData: 'batch' in data ? request.results : evt.data,
        data: data
      });
      delete this._requestCallbacks[requestId];
    }

    /**
     * Any request that contains an array of changes should deliver each change
     * to the socketChangeManager.
     *
     * @method _handleChangesArray
     * @private
     * @param {Object[]} changes   "create", "update", and "delete" requests from server.
     */

  }, {
    key: '_handleChangesArray',
    value: function _handleChangesArray(changes) {
      var _this2 = this;

      changes.forEach(function (change) {
        return _this2.client.socketChangeManager._processChange(change);
      });
    }

    /**
     * Shortcut for sending a request; builds in handling for callbacks
     *
     *    manager.sendRequest({
     *      data: {
     *        operation: "delete",
     *        object: {id: "layer:///conversations/uuid"},
     *        data: {deletion_mode: "all_participants"}
     *      },
     *      callback: function(result) {
     *        alert(result.success ? "Yay" : "Boo");
     *      },
     *      isChangesArray: false
     *    });
     *
     * @method sendRequest
     * @param  {Object} options
     * @param  {Object} otions.data                     Data to send to the server
     * @param  {Function} [options.callback=null]       Handler for success/failure callback
     * @param  {Boolean} [options.isChangesArray=false] Response contains a changes array that can be fed directly to change-manager.
     * @returns the request callback object if there is one; primarily for use in testing.
     */

  }, {
    key: 'sendRequest',
    value: function sendRequest(_ref) {
      var data = _ref.data;
      var callback = _ref.callback;
      var _ref$isChangesArray = _ref.isChangesArray;
      var isChangesArray = _ref$isChangesArray === undefined ? false : _ref$isChangesArray;

      if (!this._isOpen()) {
        return !callback ? undefined : callback(new LayerError({
          success: false,
          data: { id: 'not_connected', code: 0, message: 'WebSocket not connected' }
        }));
      }
      var body = Utils.clone(data);
      body.request_id = 'r' + this._nextRequestId++;
      logger.debug('Request ' + body.request_id + ' is sending');
      if (callback) {
        this._requestCallbacks[body.request_id] = {
          request_id: body.request_id,
          date: Date.now(),
          callback: callback,
          isChangesArray: isChangesArray,
          method: data.method,
          batchIndex: -1,
          batchTotal: -1,
          results: []
        };
      }

      this.socketManager.send({
        type: 'request',
        body: body
      });
      this._scheduleCallbackCleanup();
      if (body.request_id) return this._requestCallbacks[body.request_id];
    }

    /**
     * Flags a request as having failed if no response within 2 minutes
     *
     * @method _scheduleCallbackCleanup
     * @private
     */

  }, {
    key: '_scheduleCallbackCleanup',
    value: function _scheduleCallbackCleanup() {
      if (!this._callbackCleanupId) {
        this._callbackCleanupId = setTimeout(this._runCallbackCleanup.bind(this), DELAY_UNTIL_TIMEOUT + 50);
      }
    }

    /**
     * Calls callback with an error.
     *
     * NOTE: Because we call requests that expect responses serially instead of in parallel,
     * currently there should only ever be a single entry in _requestCallbacks.  This may change in the future.
     *
     * @method _runCallbackCleanup
     * @private
     */

  }, {
    key: '_runCallbackCleanup',
    value: function _runCallbackCleanup() {
      var _this3 = this;

      this._callbackCleanupId = 0;
      // If the websocket is closed, ignore all callbacks.  The Sync Manager will reissue these requests as soon as it gets
      // a 'connected' event... they have not failed.  May need to rethink this for cases where third parties are directly
      // calling the websocket manager bypassing the sync manager.
      if (this.isDestroyed || !this._isOpen()) return;
      var count = 0,
          abort = false;
      var now = Date.now();
      Object.keys(this._requestCallbacks).forEach(function (requestId) {
        var callbackConfig = _this3._requestCallbacks[requestId];
        if (abort) return;

        // If the request hasn't expired, we'll need to reschedule callback cleanup; else if its expired...
        if (callbackConfig && now < callbackConfig.date + DELAY_UNTIL_TIMEOUT) {
          count++;
        }

        // If there has been no data from the server, there's probably a problem with the websocket; reconnect.
        else if (now > _this3.socketManager._lastDataFromServerTimestamp + DELAY_UNTIL_TIMEOUT) {
            // Retrying isn't currently handled here; its handled by the caller (typically sync-manager); so clear out all requests,
            // notifying the callers that they have failed.
            abort = true;
            _this3._failAll();
            _this3.socketManager._reconnect(false);
          } else {
            // The request isn't responding and the socket is good; fail the request.
            _this3._timeoutRequest(requestId);
          }
      });
      if (count) this._scheduleCallbackCleanup();
    }

    /**
     * Any requests that have not had responses are considered as failed if we disconnect without a response.
     *
     * Call all callbacks with a `server_unavailable` error.  The caller may retry,
     * but this component does not have built-in retry.
     *
     * @method
     * @private
     */

  }, {
    key: '_failAll',
    value: function _failAll() {
      var _this4 = this;

      Object.keys(this._requestCallbacks).forEach(function (requestId) {
        try {
          logger.warn('Websocket request aborted due to reconnect');
          _this4._requestCallbacks[requestId].callback({
            success: false,
            status: 503,
            data: new LayerError({
              id: 'socket_dead',
              message: 'Websocket appears to be dead. Reconnecting.',
              url: 'https:/developer.layer.com/docs/websdk',
              code: 0,
              status: 503,
              httpStatus: 503
            })
          });
        } catch (err) {
          // Do nothing
        }
        delete _this4._requestCallbacks[requestId];
      });
    }
  }, {
    key: '_timeoutRequest',
    value: function _timeoutRequest(requestId) {
      try {
        logger.warn('Websocket request timeout');
        this._requestCallbacks[requestId].callback({
          success: false,
          data: new LayerError({
            id: 'request_timeout',
            message: 'The server is not responding. We know how much that sucks.',
            url: 'https:/developer.layer.com/docs/websdk',
            code: 0,
            status: 408,
            httpStatus: 408
          })
        });
      } catch (err) {
        // Do nothing
      }
      delete this._requestCallbacks[requestId];
    }
  }, {
    key: '_isOpen',
    value: function _isOpen() {
      return this.socketManager._isOpen();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.isDestroyed = true;
      if (this._callbackCleanupId) clearTimeout(this._callbackCleanupId);
      this._requestCallbacks = null;
    }
  }]);

  return WebsocketRequestManager;
}();

WebsocketRequestManager.prototype._nextRequestId = 1;

/**
 * The Client that owns this.
 * @type {layer.Client}
 */
WebsocketRequestManager.prototype.client = null;

WebsocketRequestManager.prototype._requestCallbacks = null;

WebsocketRequestManager.prototype._callbackCleanupId = 0;

WebsocketRequestManager.prototype.socketManager = null;

module.exports = WebsocketRequestManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJzb2NrZXRzL3JlcXVlc3QtbWFuYWdlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQSxJQUFNLFFBQVEsUUFBUSxpQkFBUixDQUFkO0FBQ0EsSUFBTSxTQUFTLFFBQVEsV0FBUixDQUFmO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7O0FBRUE7QUFDQSxJQUFNLHNCQUFzQixLQUFLLElBQWpDOztJQUVNLHVCO0FBQ0o7Ozs7Ozs7Ozs7Ozs7O0FBY0EsbUNBQVksT0FBWixFQUFxQjtBQUFBOztBQUNuQixTQUFLLE1BQUwsR0FBYyxRQUFRLE1BQXRCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLFFBQVEsYUFBN0I7QUFDQSxTQUFLLGFBQUwsQ0FBbUIsRUFBbkIsQ0FBc0I7QUFDcEIsZUFBUyxLQUFLLGVBRE07QUFFcEIsb0JBQWMsS0FBSztBQUZDLEtBQXRCLEVBR0csSUFISDs7QUFLQSxTQUFLLGlCQUFMLEdBQXlCLEVBQXpCO0FBQ0Q7Ozs7NkJBRVE7QUFDUCxXQUFLLGlCQUFMLEdBQXlCLEVBQXpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztvQ0FNZ0IsVSxFQUFZO0FBQUE7O0FBQzFCLGFBQU8sSUFBUCxDQUFZLEtBQUssaUJBQWpCLEVBQW9DLE9BQXBDLENBQTRDLFVBQUMsR0FBRCxFQUFTO0FBQ25ELFlBQU0sZ0JBQWdCLE1BQUssaUJBQUwsQ0FBdUIsR0FBdkIsQ0FBdEI7QUFDQSxZQUFJLGNBQWMsTUFBZCxLQUF5QixVQUE3QixFQUF5QyxPQUFPLE1BQUssaUJBQUwsQ0FBdUIsR0FBdkIsQ0FBUDtBQUMxQyxPQUhEO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7b0NBT2dCLEcsRUFBSztBQUNuQixVQUFJLElBQUksSUFBSixDQUFTLElBQVQsS0FBa0IsVUFBdEIsRUFBa0M7QUFDaEMsWUFBTSxNQUFNLElBQUksSUFBSixDQUFTLElBQXJCO0FBQ0EsWUFBTSxZQUFZLElBQUksVUFBdEI7QUFD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T0FBTyxHQUFQLEVBQVk7QUFDWjtBQUNEO0FBQ0QsYUFBTyxLQUFLLGlCQUFMLENBQXVCLFNBQXZCLENBQVA7QUFDRDs7OzhCQUVTO0FBQ1IsYUFBTyxLQUFLLGFBQUwsQ0FBbUIsT0FBbkIsRUFBUDtBQUNEOzs7OEJBRVM7QUFDUixXQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxVQUFJLEtBQUssa0JBQVQsRUFBNkIsYUFBYSxLQUFLLGtCQUFsQjtBQUM3QixXQUFLLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0Q7Ozs7OztBQUdILHdCQUF3QixTQUF4QixDQUFrQyxjQUFsQyxHQUFtRCxDQUFuRDs7QUFFQTs7OztBQUlBLHdCQUF3QixTQUF4QixDQUFrQyxNQUFsQyxHQUEyQyxJQUEzQzs7QUFFQSx3QkFBd0IsU0FBeEIsQ0FBa0MsaUJBQWxDLEdBQXNELElBQXREOztBQUVBLHdCQUF3QixTQUF4QixDQUFrQyxrQkFBbEMsR0FBdUQsQ0FBdkQ7O0FBRUEsd0JBQXdCLFNBQXhCLENBQWtDLGFBQWxDLEdBQWtELElBQWxEOztBQUVBLE9BQU8sT0FBUCxHQUFpQix1QkFBakIiLCJmaWxlIjoicmVxdWVzdC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAY2xhc3MgIGxheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXJcbiAqIEBwcml2YXRlXG4gKlxuICogVGhpcyBjbGFzcyBhbGxvd3Mgb25lIHRvIHNlbmQgcmVxdWVzdHMgdG8gdGhlIHdlYnNvY2tldCBzZXJ2ZXIsIGFuZCBwcm92aWRlIGEgY2FsbGJhY2ssXG4gKiBBbmQgaGF2ZSB0aGF0IGNhbGxiYWNrIGVpdGhlciBjYWxsZWQgYnkgdGhlIGNvcnJlY3Qgd2Vic29ja2V0IHNlcnZlciByZXNwb25zZSwgb3JcbiAqIGJlIGNhbGxlZCB3aXRoIGEgdGltZW91dC5cbiAqL1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi9jbGllbnQtdXRpbHMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4uL2xheWVyLWVycm9yJyk7XG5cbi8vIFdhaXQgMTUgc2Vjb25kcyBmb3IgYSByZXNwb25zZSBhbmQgdGhlbiBnaXZlIHVwXG5jb25zdCBERUxBWV9VTlRJTF9USU1FT1VUID0gMTUgKiAxMDAwO1xuXG5jbGFzcyBXZWJzb2NrZXRSZXF1ZXN0TWFuYWdlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IGNoYW5nZSBtYW5hZ2VyXG4gICAqXG4gICAqICAgICAgdmFyIHdlYnNvY2tldFJlcXVlc3RNYW5hZ2VyID0gbmV3IGxheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXIoe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICAgICAgc29ja2V0TWFuYWdlcjogY2xpZW50LldlYnNvY2tldHMuU29ja2V0TWFuYWdlclxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyfSBzb2NrZXRNYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtsYXllci5XZWJzb2NrZXRzLlJlcXVlc3RNYW5hZ2VyfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgdGhpcy5zb2NrZXRNYW5hZ2VyID0gb3B0aW9ucy5zb2NrZXRNYW5hZ2VyO1xuICAgIHRoaXMuc29ja2V0TWFuYWdlci5vbih7XG4gICAgICBtZXNzYWdlOiB0aGlzLl9oYW5kbGVSZXNwb25zZSxcbiAgICAgIGRpc2Nvbm5lY3RlZDogdGhpcy5fcmVzZXQsXG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzID0ge307XG4gIH1cblxuICBfcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVxdWVzdENhbGxiYWNrcyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wcmVjaXNlIG1ldGhvZDsgaXQgd2lsbCBjYW5jZWwgQUxMIHJlcXVlc3RzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQG1ldGhvZCBjYW5jZWxPcGVyYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgICAgYE1lc3NhZ2UuY3JlYXRlYCwgYEV2ZW50LnN5bmNgLCBldGMuLi5cbiAgICovXG4gIGNhbmNlbE9wZXJhdGlvbihtZXRob2ROYW1lKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdENhbGxiYWNrcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0gdGhpcy5fcmVxdWVzdENhbGxiYWNrc1trZXldO1xuICAgICAgaWYgKHJlcXVlc3RDb25maWcubWV0aG9kID09PSBtZXRob2ROYW1lKSBkZWxldGUgdGhpcy5fcmVxdWVzdENhbGxiYWNrc1trZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHJlc3BvbnNlIHRvIGEgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlUmVzcG9uc2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICBfaGFuZGxlUmVzcG9uc2UoZXZ0KSB7XG4gICAgaWYgKGV2dC5kYXRhLnR5cGUgPT09ICdyZXNwb25zZScpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGV2dC5kYXRhLmJvZHk7XG4gICAgICBjb25zdCByZXF1ZXN0SWQgPSBtc2cucmVxdWVzdF9pZDtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgV2Vic29ja2V0IHJlc3BvbnNlICR7cmVxdWVzdElkfSAke21zZy5zdWNjZXNzID8gJ1N1Y2Nlc3NmdWwnIDogJ0ZhaWxlZCd9YCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0SWQgJiYgdGhpcy5fcmVxdWVzdENhbGxiYWNrc1tyZXF1ZXN0SWRdKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NSZXNwb25zZShyZXF1ZXN0SWQsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSByZXNwb25zZSB0byBhIHJlcXVlc3Q7IHVzZWQgYnkgX2hhbmRsZVJlc3BvbnNlLlxuICAgKlxuICAgKiBSZWZhY3RvcmVkIG91dCBvZiBfaGFuZGxlUmVzcG9uc2Ugc28gdGhhdCB1bml0IHRlc3RzIGNhbiBlYXNpbHlcbiAgICogdXNlIGl0IHRvIHRyaWdnZXIgY29tcGxldGlvbiBvZiBhIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgX3Byb2Nlc3NSZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdElkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldnQgICBEYXRhIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgX3Byb2Nlc3NSZXNwb25zZShyZXF1ZXN0SWQsIGV2dCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF07XG4gICAgY29uc3QgbXNnID0gZXZ0LmRhdGEuYm9keTtcbiAgICBjb25zdCBkYXRhID0gKG1zZy5zdWNjZXNzID8gbXNnLmRhdGEgOiBuZXcgTGF5ZXJFcnJvcihtc2cuZGF0YSkpIHx8IHt9O1xuXG4gICAgaWYgKG1zZy5zdWNjZXNzKSB7XG4gICAgICBpZiAocmVxdWVzdC5pc0NoYW5nZXNBcnJheSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVDaGFuZ2VzQXJyYXkoZGF0YS5jaGFuZ2VzKTtcbiAgICAgIH1cbiAgICAgIGlmICgnYmF0Y2gnIGluIGRhdGEpIHtcbiAgICAgICAgcmVxdWVzdC5iYXRjaFRvdGFsID0gZGF0YS5iYXRjaC5jb3VudDtcbiAgICAgICAgcmVxdWVzdC5iYXRjaEluZGV4ID0gZGF0YS5iYXRjaC5pbmRleDtcbiAgICAgICAgaWYgKHJlcXVlc3QuaXNDaGFuZ2VzQXJyYXkpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlc3VsdHMgPSByZXF1ZXN0LnJlc3VsdHMuY29uY2F0KGRhdGEuY2hhbmdlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoJ3Jlc3VsdHMnIGluIGRhdGEgJiYgQXJyYXkuaXNBcnJheShkYXRhLnJlc3VsdHMpKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZXN1bHRzID0gcmVxdWVzdC5yZXN1bHRzLmNvbmNhdChkYXRhLnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmJhdGNoLmluZGV4IDwgZGF0YS5iYXRjaC5jb3VudCAtIDEpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdC5jYWxsYmFjayh7XG4gICAgICBzdWNjZXNzOiBtc2cuc3VjY2VzcyxcbiAgICAgIGZ1bGxEYXRhOiAnYmF0Y2gnIGluIGRhdGEgPyByZXF1ZXN0LnJlc3VsdHMgOiBldnQuZGF0YSxcbiAgICAgIGRhdGEsXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RDYWxsYmFja3NbcmVxdWVzdElkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgcmVxdWVzdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGNoYW5nZXMgc2hvdWxkIGRlbGl2ZXIgZWFjaCBjaGFuZ2VcbiAgICogdG8gdGhlIHNvY2tldENoYW5nZU1hbmFnZXIuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZUNoYW5nZXNBcnJheVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBjaGFuZ2VzICAgXCJjcmVhdGVcIiwgXCJ1cGRhdGVcIiwgYW5kIFwiZGVsZXRlXCIgcmVxdWVzdHMgZnJvbSBzZXJ2ZXIuXG4gICAqL1xuICBfaGFuZGxlQ2hhbmdlc0FycmF5KGNoYW5nZXMpIHtcbiAgICBjaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHRoaXMuY2xpZW50LnNvY2tldENoYW5nZU1hbmFnZXIuX3Byb2Nlc3NDaGFuZ2UoY2hhbmdlKSk7XG4gIH1cblxuICAvKipcbiAgICogU2hvcnRjdXQgZm9yIHNlbmRpbmcgYSByZXF1ZXN0OyBidWlsZHMgaW4gaGFuZGxpbmcgZm9yIGNhbGxiYWNrc1xuICAgKlxuICAgKiAgICBtYW5hZ2VyLnNlbmRSZXF1ZXN0KHtcbiAgICogICAgICBkYXRhOiB7XG4gICAqICAgICAgICBvcGVyYXRpb246IFwiZGVsZXRlXCIsXG4gICAqICAgICAgICBvYmplY3Q6IHtpZDogXCJsYXllcjovLy9jb252ZXJzYXRpb25zL3V1aWRcIn0sXG4gICAqICAgICAgICBkYXRhOiB7ZGVsZXRpb25fbW9kZTogXCJhbGxfcGFydGljaXBhbnRzXCJ9XG4gICAqICAgICAgfSxcbiAgICogICAgICBjYWxsYmFjazogZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAqICAgICAgICBhbGVydChyZXN1bHQuc3VjY2VzcyA/IFwiWWF5XCIgOiBcIkJvb1wiKTtcbiAgICogICAgICB9LFxuICAgKiAgICAgIGlzQ2hhbmdlc0FycmF5OiBmYWxzZVxuICAgKiAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBzZW5kUmVxdWVzdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvdGlvbnMuZGF0YSAgICAgICAgICAgICAgICAgICAgIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFjaz1udWxsXSAgICAgICBIYW5kbGVyIGZvciBzdWNjZXNzL2ZhaWx1cmUgY2FsbGJhY2tcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuaXNDaGFuZ2VzQXJyYXk9ZmFsc2VdIFJlc3BvbnNlIGNvbnRhaW5zIGEgY2hhbmdlcyBhcnJheSB0aGF0IGNhbiBiZSBmZWQgZGlyZWN0bHkgdG8gY2hhbmdlLW1hbmFnZXIuXG4gICAqIEByZXR1cm5zIHRoZSByZXF1ZXN0IGNhbGxiYWNrIG9iamVjdCBpZiB0aGVyZSBpcyBvbmU7IHByaW1hcmlseSBmb3IgdXNlIGluIHRlc3RpbmcuXG4gICAqL1xuICBzZW5kUmVxdWVzdCh7IGRhdGEsIGNhbGxiYWNrLCBpc0NoYW5nZXNBcnJheSA9IGZhbHNlIH0pIHtcbiAgICBpZiAoIXRoaXMuX2lzT3BlbigpKSB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrID8gdW5kZWZpbmVkIDogY2FsbGJhY2sobmV3IExheWVyRXJyb3Ioe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZGF0YTogeyBpZDogJ25vdF9jb25uZWN0ZWQnLCBjb2RlOiAwLCBtZXNzYWdlOiAnV2ViU29ja2V0IG5vdCBjb25uZWN0ZWQnIH0sXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBVdGlscy5jbG9uZShkYXRhKTtcbiAgICBib2R5LnJlcXVlc3RfaWQgPSAncicgKyB0aGlzLl9uZXh0UmVxdWVzdElkKys7XG4gICAgbG9nZ2VyLmRlYnVnKGBSZXF1ZXN0ICR7Ym9keS5yZXF1ZXN0X2lkfSBpcyBzZW5kaW5nYCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW2JvZHkucmVxdWVzdF9pZF0gPSB7XG4gICAgICAgIHJlcXVlc3RfaWQ6IGJvZHkucmVxdWVzdF9pZCxcbiAgICAgICAgZGF0ZTogRGF0ZS5ub3coKSxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIGlzQ2hhbmdlc0FycmF5LFxuICAgICAgICBtZXRob2Q6IGRhdGEubWV0aG9kLFxuICAgICAgICBiYXRjaEluZGV4OiAtMSxcbiAgICAgICAgYmF0Y2hUb3RhbDogLTEsXG4gICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNvY2tldE1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICBib2R5LFxuICAgIH0pO1xuICAgIHRoaXMuX3NjaGVkdWxlQ2FsbGJhY2tDbGVhbnVwKCk7XG4gICAgaWYgKGJvZHkucmVxdWVzdF9pZCkgcmV0dXJuIHRoaXMuX3JlcXVlc3RDYWxsYmFja3NbYm9keS5yZXF1ZXN0X2lkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFncyBhIHJlcXVlc3QgYXMgaGF2aW5nIGZhaWxlZCBpZiBubyByZXNwb25zZSB3aXRoaW4gMiBtaW51dGVzXG4gICAqXG4gICAqIEBtZXRob2QgX3NjaGVkdWxlQ2FsbGJhY2tDbGVhbnVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2NoZWR1bGVDYWxsYmFja0NsZWFudXAoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWxsYmFja0NsZWFudXBJZCkge1xuICAgICAgdGhpcy5fY2FsbGJhY2tDbGVhbnVwSWQgPSBzZXRUaW1lb3V0KHRoaXMuX3J1bkNhbGxiYWNrQ2xlYW51cC5iaW5kKHRoaXMpLCBERUxBWV9VTlRJTF9USU1FT1VUICsgNTApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBjYWxsYmFjayB3aXRoIGFuIGVycm9yLlxuICAgKlxuICAgKiBOT1RFOiBCZWNhdXNlIHdlIGNhbGwgcmVxdWVzdHMgdGhhdCBleHBlY3QgcmVzcG9uc2VzIHNlcmlhbGx5IGluc3RlYWQgb2YgaW4gcGFyYWxsZWwsXG4gICAqIGN1cnJlbnRseSB0aGVyZSBzaG91bGQgb25seSBldmVyIGJlIGEgc2luZ2xlIGVudHJ5IGluIF9yZXF1ZXN0Q2FsbGJhY2tzLiAgVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gICAqXG4gICAqIEBtZXRob2QgX3J1bkNhbGxiYWNrQ2xlYW51cFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3J1bkNhbGxiYWNrQ2xlYW51cCgpIHtcbiAgICB0aGlzLl9jYWxsYmFja0NsZWFudXBJZCA9IDA7XG4gICAgLy8gSWYgdGhlIHdlYnNvY2tldCBpcyBjbG9zZWQsIGlnbm9yZSBhbGwgY2FsbGJhY2tzLiAgVGhlIFN5bmMgTWFuYWdlciB3aWxsIHJlaXNzdWUgdGhlc2UgcmVxdWVzdHMgYXMgc29vbiBhcyBpdCBnZXRzXG4gICAgLy8gYSAnY29ubmVjdGVkJyBldmVudC4uLiB0aGV5IGhhdmUgbm90IGZhaWxlZC4gIE1heSBuZWVkIHRvIHJldGhpbmsgdGhpcyBmb3IgY2FzZXMgd2hlcmUgdGhpcmQgcGFydGllcyBhcmUgZGlyZWN0bHlcbiAgICAvLyBjYWxsaW5nIHRoZSB3ZWJzb2NrZXQgbWFuYWdlciBieXBhc3NpbmcgdGhlIHN5bmMgbWFuYWdlci5cbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCB8fCAhdGhpcy5faXNPcGVuKCkpIHJldHVybjtcbiAgICBsZXQgY291bnQgPSAwLFxuICAgICAgYWJvcnQgPSBmYWxzZTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RDYWxsYmFja3MpLmZvckVhY2goKHJlcXVlc3RJZCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tDb25maWcgPSB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF07XG4gICAgICBpZiAoYWJvcnQpIHJldHVybjtcblxuICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaGFzbid0IGV4cGlyZWQsIHdlJ2xsIG5lZWQgdG8gcmVzY2hlZHVsZSBjYWxsYmFjayBjbGVhbnVwOyBlbHNlIGlmIGl0cyBleHBpcmVkLi4uXG4gICAgICBpZiAoY2FsbGJhY2tDb25maWcgJiYgbm93IDwgY2FsbGJhY2tDb25maWcuZGF0ZSArIERFTEFZX1VOVElMX1RJTUVPVVQpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbm8gZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHRoZXJlJ3MgcHJvYmFibHkgYSBwcm9ibGVtIHdpdGggdGhlIHdlYnNvY2tldDsgcmVjb25uZWN0LlxuICAgICAgZWxzZSBpZiAobm93ID4gdGhpcy5zb2NrZXRNYW5hZ2VyLl9sYXN0RGF0YUZyb21TZXJ2ZXJUaW1lc3RhbXAgKyBERUxBWV9VTlRJTF9USU1FT1VUKSB7XG4gICAgICAgIC8vIFJldHJ5aW5nIGlzbid0IGN1cnJlbnRseSBoYW5kbGVkIGhlcmU7IGl0cyBoYW5kbGVkIGJ5IHRoZSBjYWxsZXIgKHR5cGljYWxseSBzeW5jLW1hbmFnZXIpOyBzbyBjbGVhciBvdXQgYWxsIHJlcXVlc3RzLFxuICAgICAgICAvLyBub3RpZnlpbmcgdGhlIGNhbGxlcnMgdGhhdCB0aGV5IGhhdmUgZmFpbGVkLlxuICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZhaWxBbGwoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRNYW5hZ2VyLl9yZWNvbm5lY3QoZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgaXNuJ3QgcmVzcG9uZGluZyBhbmQgdGhlIHNvY2tldCBpcyBnb29kOyBmYWlsIHRoZSByZXF1ZXN0LlxuICAgICAgICB0aGlzLl90aW1lb3V0UmVxdWVzdChyZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjb3VudCkgdGhpcy5fc2NoZWR1bGVDYWxsYmFja0NsZWFudXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgcmVxdWVzdHMgdGhhdCBoYXZlIG5vdCBoYWQgcmVzcG9uc2VzIGFyZSBjb25zaWRlcmVkIGFzIGZhaWxlZCBpZiB3ZSBkaXNjb25uZWN0IHdpdGhvdXQgYSByZXNwb25zZS5cbiAgICpcbiAgICogQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggYSBgc2VydmVyX3VuYXZhaWxhYmxlYCBlcnJvci4gIFRoZSBjYWxsZXIgbWF5IHJldHJ5LFxuICAgKiBidXQgdGhpcyBjb21wb25lbnQgZG9lcyBub3QgaGF2ZSBidWlsdC1pbiByZXRyeS5cbiAgICpcbiAgICogQG1ldGhvZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZhaWxBbGwoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdENhbGxiYWNrcykuZm9yRWFjaCgocmVxdWVzdElkKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2dnZXIud2FybignV2Vic29ja2V0IHJlcXVlc3QgYWJvcnRlZCBkdWUgdG8gcmVjb25uZWN0Jyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RDYWxsYmFja3NbcmVxdWVzdElkXS5jYWxsYmFjayh7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgc3RhdHVzOiA1MDMsXG4gICAgICAgICAgZGF0YTogbmV3IExheWVyRXJyb3Ioe1xuICAgICAgICAgICAgaWQ6ICdzb2NrZXRfZGVhZCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnV2Vic29ja2V0IGFwcGVhcnMgdG8gYmUgZGVhZC4gUmVjb25uZWN0aW5nLicsXG4gICAgICAgICAgICB1cmw6ICdodHRwczovZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3dlYnNkaycsXG4gICAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgICAgc3RhdHVzOiA1MDMsXG4gICAgICAgICAgICBodHRwU3RhdHVzOiA1MDMsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF07XG4gICAgfSk7XG4gIH1cblxuICBfdGltZW91dFJlcXVlc3QocmVxdWVzdElkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci53YXJuKCdXZWJzb2NrZXQgcmVxdWVzdCB0aW1lb3V0Jyk7XG4gICAgICB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF0uY2FsbGJhY2soe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZGF0YTogbmV3IExheWVyRXJyb3Ioe1xuICAgICAgICAgIGlkOiAncmVxdWVzdF90aW1lb3V0JyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIHNlcnZlciBpcyBub3QgcmVzcG9uZGluZy4gV2Uga25vdyBob3cgbXVjaCB0aGF0IHN1Y2tzLicsXG4gICAgICAgICAgdXJsOiAnaHR0cHM6L2RldmVsb3Blci5sYXllci5jb20vZG9jcy93ZWJzZGsnLFxuICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgc3RhdHVzOiA0MDgsXG4gICAgICAgICAgaHR0cFN0YXR1czogNDA4LFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fcmVxdWVzdENhbGxiYWNrc1tyZXF1ZXN0SWRdO1xuICB9XG5cbiAgX2lzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb2NrZXRNYW5hZ2VyLl9pc09wZW4oKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrQ2xlYW51cElkKSBjbGVhclRpbWVvdXQodGhpcy5fY2FsbGJhY2tDbGVhbnVwSWQpO1xuICAgIHRoaXMuX3JlcXVlc3RDYWxsYmFja3MgPSBudWxsO1xuICB9XG59XG5cbldlYnNvY2tldFJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5fbmV4dFJlcXVlc3RJZCA9IDE7XG5cbi8qKlxuICogVGhlIENsaWVudCB0aGF0IG93bnMgdGhpcy5cbiAqIEB0eXBlIHtsYXllci5DbGllbnR9XG4gKi9cbldlYnNvY2tldFJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG5XZWJzb2NrZXRSZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuX3JlcXVlc3RDYWxsYmFja3MgPSBudWxsO1xuXG5XZWJzb2NrZXRSZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuX2NhbGxiYWNrQ2xlYW51cElkID0gMDtcblxuV2Vic29ja2V0UmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnNvY2tldE1hbmFnZXIgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYnNvY2tldFJlcXVlc3RNYW5hZ2VyO1xuXG4iXX0=
