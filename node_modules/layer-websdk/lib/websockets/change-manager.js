'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.ChangeManager
 * @private
 *
 * This class listens for `change` events from the websocket server,
 * and processes them.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var Message = require('../models/message');
var Conversation = require('../models/conversation');
var Channel = require('../models/channel');

var WebsocketChangeManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketChangeManager = new layer.Websockets.ChangeManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.ChangeManager}
   */
  function WebsocketChangeManager(options) {
    _classCallCheck(this, WebsocketChangeManager);

    this.client = options.client;
    options.socketManager.on('message', this._handleChange, this);
  }

  /**
   * Handles a Change packet from the server.
   *
   * @method _handleChange
   * @private
   * @param  {layer.LayerEvent} evt
   */


  _createClass(WebsocketChangeManager, [{
    key: '_handleChange',
    value: function _handleChange(evt) {
      if (evt.data.type === 'change') {
        this._processChange(evt.data.body);
      }
    }

    /**
     * Process changes from a change packet.
     *
     * Called both by _handleChange, and by the requestManager on getting a changes array.
     *
     * @method _processChanage
     * @private
     * @param {Object} msg
     */

  }, {
    key: '_processChange',
    value: function _processChange(msg) {
      switch (msg.operation) {
        case 'create':
          logger.info('Websocket Change Event: Create ' + msg.object.type + ' ' + msg.object.id);
          logger.debug(msg.data);
          this._handleCreate(msg);
          break;
        case 'delete':
          logger.info('Websocket Change Event: Delete ' + msg.object.type + ' ' + msg.object.id);
          logger.debug(msg.data);
          this._handleDelete(msg);
          break;
        case 'update':
          logger.info('Websocket Change Event: Patch ' + msg.object.type + ' ' + msg.object.id + ': ' + msg.data.map(function (op) {
            return op.property;
          }).join(', '));
          logger.debug(msg.data);
          this._handlePatch(msg);
          break;
      }
    }

    /**
     * Process a create object message from the server
     *
     * @method _handleCreate
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleCreate',
    value: function _handleCreate(msg) {
      msg.data.fromWebsocket = true;
      this.client._createObject(msg.data);
    }

    /**
     * Handles delete object messages from the server.
     * All objects that can be deleted from the server should
     * provide a _deleted() method to be called prior to destroy().
     *
     * @method _handleDelete
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleDelete',
    value: function _handleDelete(msg) {
      var entity = this.getObject(msg);
      if (entity) {
        entity._handleWebsocketDelete(msg.data);
      }
    }

    /**
     * On receiving an update/patch message from the server
     * run the LayerParser on the data.
     *
     * @method _handlePatch
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handlePatch',
    value: function _handlePatch(msg) {
      // Can only patch a cached object
      var entity = this.getObject(msg);
      if (entity) {
        try {
          entity._inLayerParser = true;
          Utils.layerParse({
            object: entity,
            type: msg.object.type,
            operations: msg.data,
            client: this.client
          });
          entity._inLayerParser = false;
        } catch (err) {
          logger.error('websocket-manager: Failed to handle event', msg.data);
        }
      } else {
        switch (Utils.typeFromID(msg.object.id)) {
          case 'channels':
            if (Channel._loadResourceForPatch(msg.data)) this.client.getObject(msg.object.id, true);
            break;
          case 'conversations':
            if (Conversation._loadResourceForPatch(msg.data)) this.client.getObject(msg.object.id, true);
            break;
          case 'messages':
            if (Message._loadResourceForPatch(msg.data)) this.client.getMessage(msg.object.id, true);
            break;
          case 'announcements':
            break;
        }
      }
    }

    /**
     * Get the object specified by the `object` property of the websocket packet.
     *
     * @method getObject
     * @private
     * @param  {Object} msg
     * @return {layer.Root}
     */

  }, {
    key: 'getObject',
    value: function getObject(msg) {
      return this.client.getObject(msg.object.id);
    }

    /**
     * Not required, but destroy is best practice
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.client = null;
    }
  }]);

  return WebsocketChangeManager;
}();

/**
 * The Client that owns this.
 * @type {layer.Client}
 */


WebsocketChangeManager.prototype.client = null;

module.exports = WebsocketChangeManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93ZWJzb2NrZXRzL2NoYW5nZS1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7O0FBT0EsSUFBTSxRQUFRLFFBQVEsaUJBQVIsQ0FBZDtBQUNBLElBQU0sU0FBUyxRQUFRLFdBQVIsQ0FBZjtBQUNBLElBQU0sVUFBVSxRQUFRLG1CQUFSLENBQWhCO0FBQ0EsSUFBTSxlQUFlLFFBQVEsd0JBQVIsQ0FBckI7QUFDQSxJQUFNLFVBQVUsUUFBUSxtQkFBUixDQUFoQjs7SUFHTSxzQjtBQUNKOzs7Ozs7Ozs7Ozs7OztBQWNBLGtDQUFZLE9BQVosRUFBcUI7QUFBQTs7QUFDbkIsU0FBSyxNQUFMLEdBQWMsUUFBUSxNQUF0QjtBQUNBLFlBQVEsYUFBUixDQUFzQixFQUF0QixDQUF5QixTQUF6QixFQUFvQyxLQUFLLGFBQXpDLEVBQXdELElBQXhEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O2tDQU9jLEcsRUFBSztBQUNqQixVQUFJLElBQUksSUFBSixDQUFTLElBQVQsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsYUFBSyxjQUFMLENBQW9CLElBQUksSUFBSixDQUFTLElBQTdCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7O21DQVNlLEcsRUFBSztBQUNsQixjQUFRLElBQUksU0FBWjtBQUNFLGFBQUssUUFBTDtBQUNFLGlCQUFPLElBQVAscUNBQThDLElBQUksTUFBSixDQUFXLElBQXpELFNBQWlFLElBQUksTUFBSixDQUFXLEVBQTVFO0FBQ0EsaUJBQU8sS0FBUCxDQUFhLElBQUksSUFBakI7QUFDQSxlQUFLLGFBQUwsQ0FBbUIsR0FBbkI7QUFDQTtBQUNGLGFBQUssUUFBTDtBQUNFLGlCQUFPLElBQVAscUNBQThDLElBQUksTUFBSixDQUFXLElBQXpELFNBQWlFLElBQUksTUFBSixDQUFXLEVBQTVFO0FBQ0EsaUJBQU8sS0FBUCxDQUFhLElBQUksSUFBakI7QUFDQSxlQUFLLGFBQUwsQ0FBbUIsR0FBbkI7QUFDQTtBQUNGLGFBQUssUUFBTDtBQUNFLGlCQUFPLElBQVAsb0NBQTZDLElBQUksTUFBSixDQUFXLElBQXhELFNBQWdFLElBQUksTUFBSixDQUFXLEVBQTNFLFVBQWtGLElBQUksSUFBSixDQUFTLEdBQVQsQ0FBYTtBQUFBLG1CQUFNLEdBQUcsUUFBVDtBQUFBLFdBQWIsRUFBZ0MsSUFBaEMsQ0FBcUMsSUFBckMsQ0FBbEY7QUFDQSxpQkFBTyxLQUFQLENBQWEsSUFBSSxJQUFqQjtBQUNBLGVBQUssWUFBTCxDQUFrQixHQUFsQjtBQUNBO0FBZko7QUFpQkQ7O0FBRUQ7Ozs7Ozs7Ozs7a0NBT2MsRyxFQUFLO0FBQ2pCLFVBQUksSUFBSixDQUFTLGFBQVQsR0FBeUIsSUFBekI7QUFDQSxXQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTBCLElBQUksSUFBOUI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O2tDQVNjLEcsRUFBSztBQUNqQixVQUFNLFNBQVMsS0FBSyxTQUFMLENBQWUsR0FBZixDQUFmO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVixlQUFPLHNCQUFQLENBQThCLElBQUksSUFBbEM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRYSxHLEVBQUs7QUFDaEI7QUFDQSxVQUFNLFNBQVMsS0FBSyxTQUFMLENBQWUsR0FBZixDQUFmO0FBQ0EsVUFBSSxNQUFKLEVBQVk7QUFDVixZQUFJO0FBQ0YsaUJBQU8sY0FBUCxHQUF3QixJQUF4QjtBQUNBLGdCQUFNLFVBQU4sQ0FBaUI7QUFDZixvQkFBUSxNQURPO0FBRWYsa0JBQU0sSUFBSSxNQUFKLENBQVcsSUFGRjtBQUdmLHdCQUFZLElBQUksSUFIRDtBQUlmLG9CQUFRLEtBQUs7QUFKRSxXQUFqQjtBQU1BLGlCQUFPLGNBQVAsR0FBd0IsS0FBeEI7QUFDRCxTQVRELENBU0UsT0FBTyxHQUFQLEVBQVk7QUFDWixpQkFBTyxLQUFQLENBQWEsMkNBQWIsRUFBMEQsSUFBSSxJQUE5RDtBQUNEO0FBQ0YsT0FiRCxNQWFPO0FBQ0wsZ0JBQVEsTUFBTSxVQUFOLENBQWlCLElBQUksTUFBSixDQUFXLEVBQTVCLENBQVI7QUFDRSxlQUFLLFVBQUw7QUFDRSxnQkFBSSxRQUFRLHFCQUFSLENBQThCLElBQUksSUFBbEMsQ0FBSixFQUE2QyxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLElBQUksTUFBSixDQUFXLEVBQWpDLEVBQXFDLElBQXJDO0FBQzdDO0FBQ0YsZUFBSyxlQUFMO0FBQ0UsZ0JBQUksYUFBYSxxQkFBYixDQUFtQyxJQUFJLElBQXZDLENBQUosRUFBa0QsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixJQUFJLE1BQUosQ0FBVyxFQUFqQyxFQUFxQyxJQUFyQztBQUNsRDtBQUNGLGVBQUssVUFBTDtBQUNFLGdCQUFJLFFBQVEscUJBQVIsQ0FBOEIsSUFBSSxJQUFsQyxDQUFKLEVBQTZDLEtBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsSUFBSSxNQUFKLENBQVcsRUFBbEMsRUFBc0MsSUFBdEM7QUFDN0M7QUFDRixlQUFLLGVBQUw7QUFDRTtBQVhKO0FBYUQ7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OEJBUVUsRyxFQUFLO0FBQ2IsYUFBTyxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLElBQUksTUFBSixDQUFXLEVBQWpDLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs4QkFJVTtBQUNSLFdBQUssTUFBTCxHQUFjLElBQWQ7QUFDRDs7Ozs7O0FBR0g7Ozs7OztBQUlBLHVCQUF1QixTQUF2QixDQUFpQyxNQUFqQyxHQUEwQyxJQUExQzs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsc0JBQWpCIiwiZmlsZSI6ImNoYW5nZS1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAY2xhc3MgIGxheWVyLldlYnNvY2tldHMuQ2hhbmdlTWFuYWdlclxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGNsYXNzIGxpc3RlbnMgZm9yIGBjaGFuZ2VgIGV2ZW50cyBmcm9tIHRoZSB3ZWJzb2NrZXQgc2VydmVyLFxuICogYW5kIHByb2Nlc3NlcyB0aGVtLlxuICovXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uL2NsaWVudC11dGlscycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vbW9kZWxzL21lc3NhZ2UnKTtcbmNvbnN0IENvbnZlcnNhdGlvbiA9IHJlcXVpcmUoJy4uL21vZGVscy9jb252ZXJzYXRpb24nKTtcbmNvbnN0IENoYW5uZWwgPSByZXF1aXJlKCcuLi9tb2RlbHMvY2hhbm5lbCcpO1xuXG5cbmNsYXNzIFdlYnNvY2tldENoYW5nZU1hbmFnZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHdlYnNvY2tldCBjaGFuZ2UgbWFuYWdlclxuICAgKlxuICAgKiAgICAgIHZhciB3ZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyID0gbmV3IGxheWVyLldlYnNvY2tldHMuQ2hhbmdlTWFuYWdlcih7XG4gICAqICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgKiAgICAgICAgICBzb2NrZXRNYW5hZ2VyOiBjbGllbnQuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXJ9IHNvY2tldE1hbmFnZXJcbiAgICogQHJldHVybnMge2xheWVyLldlYnNvY2tldHMuQ2hhbmdlTWFuYWdlcn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsaWVudCA9IG9wdGlvbnMuY2xpZW50O1xuICAgIG9wdGlvbnMuc29ja2V0TWFuYWdlci5vbignbWVzc2FnZScsIHRoaXMuX2hhbmRsZUNoYW5nZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIENoYW5nZSBwYWNrZXQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVDaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICBfaGFuZGxlQ2hhbmdlKGV2dCkge1xuICAgIGlmIChldnQuZGF0YS50eXBlID09PSAnY2hhbmdlJykge1xuICAgICAgdGhpcy5fcHJvY2Vzc0NoYW5nZShldnQuZGF0YS5ib2R5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBjaGFuZ2VzIGZyb20gYSBjaGFuZ2UgcGFja2V0LlxuICAgKlxuICAgKiBDYWxsZWQgYm90aCBieSBfaGFuZGxlQ2hhbmdlLCBhbmQgYnkgdGhlIHJlcXVlc3RNYW5hZ2VyIG9uIGdldHRpbmcgYSBjaGFuZ2VzIGFycmF5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9wcm9jZXNzQ2hhbmFnZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbXNnXG4gICAqL1xuICBfcHJvY2Vzc0NoYW5nZShtc2cpIHtcbiAgICBzd2l0Y2ggKG1zZy5vcGVyYXRpb24pIHtcbiAgICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgICAgIGxvZ2dlci5pbmZvKGBXZWJzb2NrZXQgQ2hhbmdlIEV2ZW50OiBDcmVhdGUgJHttc2cub2JqZWN0LnR5cGV9ICR7bXNnLm9iamVjdC5pZH1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKG1zZy5kYXRhKTtcbiAgICAgICAgdGhpcy5faGFuZGxlQ3JlYXRlKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgbG9nZ2VyLmluZm8oYFdlYnNvY2tldCBDaGFuZ2UgRXZlbnQ6IERlbGV0ZSAke21zZy5vYmplY3QudHlwZX0gJHttc2cub2JqZWN0LmlkfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcobXNnLmRhdGEpO1xuICAgICAgICB0aGlzLl9oYW5kbGVEZWxldGUobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICBsb2dnZXIuaW5mbyhgV2Vic29ja2V0IENoYW5nZSBFdmVudDogUGF0Y2ggJHttc2cub2JqZWN0LnR5cGV9ICR7bXNnLm9iamVjdC5pZH06ICR7bXNnLmRhdGEubWFwKG9wID0+IG9wLnByb3BlcnR5KS5qb2luKCcsICcpfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcobXNnLmRhdGEpO1xuICAgICAgICB0aGlzLl9oYW5kbGVQYXRjaChtc2cpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBhIGNyZWF0ZSBvYmplY3QgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlQ3JlYXRlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbXNnXG4gICAqL1xuICBfaGFuZGxlQ3JlYXRlKG1zZykge1xuICAgIG1zZy5kYXRhLmZyb21XZWJzb2NrZXQgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50Ll9jcmVhdGVPYmplY3QobXNnLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGVsZXRlIG9iamVjdCBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIEFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyIHNob3VsZFxuICAgKiBwcm92aWRlIGEgX2RlbGV0ZWQoKSBtZXRob2QgdG8gYmUgY2FsbGVkIHByaW9yIHRvIGRlc3Ryb3koKS5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlRGVsZXRlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbXNnXG4gICAqL1xuICBfaGFuZGxlRGVsZXRlKG1zZykge1xuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZ2V0T2JqZWN0KG1zZyk7XG4gICAgaWYgKGVudGl0eSkge1xuICAgICAgZW50aXR5Ll9oYW5kbGVXZWJzb2NrZXREZWxldGUobXNnLmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiByZWNlaXZpbmcgYW4gdXBkYXRlL3BhdGNoIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAqIHJ1biB0aGUgTGF5ZXJQYXJzZXIgb24gdGhlIGRhdGEuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZVBhdGNoXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbXNnXG4gICAqL1xuICBfaGFuZGxlUGF0Y2gobXNnKSB7XG4gICAgLy8gQ2FuIG9ubHkgcGF0Y2ggYSBjYWNoZWQgb2JqZWN0XG4gICAgY29uc3QgZW50aXR5ID0gdGhpcy5nZXRPYmplY3QobXNnKTtcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbnRpdHkuX2luTGF5ZXJQYXJzZXIgPSB0cnVlO1xuICAgICAgICBVdGlscy5sYXllclBhcnNlKHtcbiAgICAgICAgICBvYmplY3Q6IGVudGl0eSxcbiAgICAgICAgICB0eXBlOiBtc2cub2JqZWN0LnR5cGUsXG4gICAgICAgICAgb3BlcmF0aW9uczogbXNnLmRhdGEsXG4gICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGVudGl0eS5faW5MYXllclBhcnNlciA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignd2Vic29ja2V0LW1hbmFnZXI6IEZhaWxlZCB0byBoYW5kbGUgZXZlbnQnLCBtc2cuZGF0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoVXRpbHMudHlwZUZyb21JRChtc2cub2JqZWN0LmlkKSkge1xuICAgICAgICBjYXNlICdjaGFubmVscyc6XG4gICAgICAgICAgaWYgKENoYW5uZWwuX2xvYWRSZXNvdXJjZUZvclBhdGNoKG1zZy5kYXRhKSkgdGhpcy5jbGllbnQuZ2V0T2JqZWN0KG1zZy5vYmplY3QuaWQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb252ZXJzYXRpb25zJzpcbiAgICAgICAgICBpZiAoQ29udmVyc2F0aW9uLl9sb2FkUmVzb3VyY2VGb3JQYXRjaChtc2cuZGF0YSkpIHRoaXMuY2xpZW50LmdldE9iamVjdChtc2cub2JqZWN0LmlkLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWVzc2FnZXMnOlxuICAgICAgICAgIGlmIChNZXNzYWdlLl9sb2FkUmVzb3VyY2VGb3JQYXRjaChtc2cuZGF0YSkpIHRoaXMuY2xpZW50LmdldE1lc3NhZ2UobXNnLm9iamVjdC5pZCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fubm91bmNlbWVudHMnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9iamVjdCBzcGVjaWZpZWQgYnkgdGhlIGBvYmplY3RgIHByb3BlcnR5IG9mIHRoZSB3ZWJzb2NrZXQgcGFja2V0LlxuICAgKlxuICAgKiBAbWV0aG9kIGdldE9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1zZ1xuICAgKiBAcmV0dXJuIHtsYXllci5Sb290fVxuICAgKi9cbiAgZ2V0T2JqZWN0KG1zZykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5nZXRPYmplY3QobXNnLm9iamVjdC5pZCk7XG4gIH1cblxuICAvKipcbiAgICogTm90IHJlcXVpcmVkLCBidXQgZGVzdHJveSBpcyBiZXN0IHByYWN0aWNlXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgQ2xpZW50IHRoYXQgb3ducyB0aGlzLlxuICogQHR5cGUge2xheWVyLkNsaWVudH1cbiAqL1xuV2Vic29ja2V0Q2hhbmdlTWFuYWdlci5wcm90b3R5cGUuY2xpZW50ID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyO1xuIl19
