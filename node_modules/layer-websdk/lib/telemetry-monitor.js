'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Metrics gathering component.
 *
 * 1. Should never broadcast any personally identifiable information
 * 2. Should never broadcast any values actually sent/received by users
 * 3. It can send how long any type of operation took to perform
 * 4. It can send how many times an operation was performed
 *
 * This is currently setup to run once per hour, sending hourly updates to the server.
 *
 * @class layer.TelemetryMonitor
 * @extends layer.Root
 * @private
 */

var Root = require('./root');
var Xhr = require('./xhr');
var Util = require('./client-utils');

var TelemetryMonitor = function (_Root) {
  _inherits(TelemetryMonitor, _Root);

  /**
   * Creates a new Monitor.
   *
   * An Application is expected to only have one Monitor.
   *
   * @method constructor
   * @param {Object} options
   * @param {layer.Client} options.client
   * @param {Boolean} [options.enabled=true]   Set to false to disable telemetry reporting
   * @param {Number} [options.reportingInterval=1000 * 3600]   Defaults to 1 hour, but can be set to other intervals
   */
  function TelemetryMonitor(options) {
    _classCallCheck(this, TelemetryMonitor);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TelemetryMonitor).call(this, options));

    _this.client = options.client;
    _this.state = {
      id: _this.id,
      records: []
    };
    _this.tempState = {};
    _this.storageKey = 'layer-telemetry-' + _this.client.appId;

    if (!global.localStorage) {
      _this.enabled = false;
    } else {
      try {
        var oldState = localStorage[_this.storageKey];
        if (!oldState) {
          localStorage.setItem(_this.storageKey, JSON.stringify(_this.state));
        } else {
          _this.state = JSON.parse(oldState);
        }
      } catch (e) {
        _this.enabled = false;
      }
    }

    _this.client.on('state-change', _this.trackEvent, _this);
    Xhr.addConnectionListener(_this.trackRestPerformance.bind(_this));
    _this.setupReportingInterval();
    return _this;
  }

  /**
   * Given a `telemetryId` and an optional `id`, and a `started` or `ended` key,
   * track performance of the given telemetry statistic.
   *
   * @method
   */


  _createClass(TelemetryMonitor, [{
    key: 'trackEvent',
    value: function trackEvent(evt) {
      if (!this.enabled) return;
      var eventId = evt.telemetryId + '-' + (evt.id || 'noid');

      if (evt.started) {
        this.tempState[eventId] = Date.now();
      } else if (evt.ended) {
        var started = this.tempState[eventId];
        if (started) {
          delete this.tempState[eventId];
          var duration = Date.now() - started;
          this.writePerformance(evt.telemetryId, duration);
        }
      }
    }

    /**
     * Clear out any requests that were never completed.
     *
     * Currently we only track an id and a start time, so we don't know much about these events.
     *
     * @method clearEvents
     */

  }, {
    key: 'clearEvents',
    value: function clearEvents() {
      var _this2 = this;

      var now = Date.now();
      Object.keys(this.tempState).forEach(function (key) {
        if (_this2.tempState[key] + _this2.reportingInterval < now) delete _this2.tempState[key];
      });
    }

    /**
     * Any xhr request that was called with a `telemetry` key contains metrics to be logged.
     *
     * The `telemetry` object should contain `name` and `duration` keys
     *
     * @method
     */

  }, {
    key: 'trackRestPerformance',
    value: function trackRestPerformance(evt) {
      if (this.enabled && evt.request.telemetry) {
        this.writePerformance(evt.request.telemetry.name, evt.duration);
      }
    }

    /**
     * When writing performance, there are three inputs used:
     *
     * 1. The name of the metric being tracked
     * 2. The duration it took for the operation
     * 3. The current time (this is not a function input, but is still a dependency)
     *
     * Results of writing performance are to increment count, and total time for the operation.
     *
     * @method
     */

  }, {
    key: 'writePerformance',
    value: function writePerformance(name, timing) {
      var performance = this.getCurrentStateObject().performance;
      if (!performance[name]) {
        performance[name] = {
          count: 0,
          time: 0,
          max: 0
        };
      }
      performance[name].count++;
      performance[name].time += timing;
      if (timing > performance[name].max) performance[name].max = timing;
      this.writeState();
    }

    /**
     * When writing usage, we are simply incrementing the usage counter for the metric.
     *
     * @method
     */

  }, {
    key: 'writeUsage',
    value: function writeUsage(name) {
      var usage = this.getCurrentStateObject().usage;
      if (!usage[name]) usage[name] = 0;
      usage[name]++;
      this.writeState();
    }

    /**
     * Grab some environmental data to attach to the report.
     *
     * note that environmental data may change from hour to hour,
     * so we regather this information for each record we send to the server.
     *
     * @method
     */

  }, {
    key: 'getEnvironment',
    value: function getEnvironment() {
      var environment = {
        platform: 'web',
        locale: (navigator.language || '').replace(/-/g, '_'), // should match the en_us format that mobile devices are using rather than the much nicer en-us
        layer_sdk_version: this.client.constructor.version,
        domain: location.hostname
      };

      // This event allows other libraries to add information to the environment object; specifically: Layer UI
      this.trigger('telemetry-environment', {
        environment: environment
      });
      return environment;
    }

    /**
     * Grab some device data to attach to the report.
     *
     * note that device data may change from hour to hour,
     * so we regather this information for each record we send to the server.
     *
     * @method
     */

  }, {
    key: 'getDevice',
    value: function getDevice() {
      return {
        user_agent: navigator.userAgent,
        screen: {
          width: (typeof screen === 'undefined' ? 'undefined' : _typeof(screen)) === undefined ? 0 : screen.width,
          height: (typeof screen === 'undefined' ? 'undefined' : _typeof(screen)) === undefined ? 0 : screen.height
        },
        window: {
          width: window.innerWidth,
          height: window.innerHeight
        }
      };
    }

    /**
     * Return the state object used to track performance for the current time slot
     *
     * @method
     */

  }, {
    key: 'getCurrentStateObject',
    value: function getCurrentStateObject(doNotCreate) {
      var today = new Date();
      today.setUTCHours(0, 0, 0, 0);
      var currentDate = new Date(today);

      var now = Date.now();

      // If the reporting interval is less than 24 hours, iterate until we find the current time slice within our day
      if (this.reportingInterval < 60 * 60 * 1000 * 24) {
        while (currentDate.getTime() < now) {
          currentDate.setMilliseconds(currentDate.getMilliseconds() + this.reportingInterval);
        }
      }

      var currentStart = currentDate.toISOString();
      var currentEndDate = new Date(currentDate);
      currentEndDate.setMilliseconds(currentEndDate.getMilliseconds() + this.reportingInterval);
      var todayObj = this.state.records.filter(function (set) {
        return set.period.start === currentStart;
      })[0];

      if (!todayObj && !doNotCreate) {
        todayObj = {
          period: {
            start: currentStart,
            end: currentEndDate.toISOString()
          },
          environment: this.getEnvironment(),
          device: this.getDevice(),
          usage: {},
          performance: {},
          errors: {}
        };
        this.state.records.push(todayObj);
      }

      return todayObj;
    }

    /**
     * Write state to localStorage.
     *
     * Writing the state is an expensive operation that should be done less often,
     * and containing more changes rather than done immediatley and repeated with each change.
     *
     * @method
     */

  }, {
    key: 'writeState',
    value: function writeState() {
      var _this3 = this;

      if (this.enabled && !this._writeTimeoutId) {
        this._writeTimeoutId = setTimeout(function () {
          localStorage.setItem(_this3.storageKey, JSON.stringify(_this3.state));
          _this3._writeTimeoutId = 0;
        }, 1000);
      }
    }

    /**
     * Given a time slot's data, convert its data to what the server expects.
     *
     * @method
     */

  }, {
    key: 'convertRecord',
    value: function convertRecord(record) {
      var result = {
        period: record.period,
        device: record.device,
        environment: record.environment,
        usage: record.usage,
        performance: {}
      };

      Object.keys(record.performance).forEach(function (performanceKey) {
        var item = record.performance[performanceKey];
        result.performance[performanceKey] = {
          max: Math.round(item.max),
          count: item.count,
          mean: Math.round(item.time / item.count) };
      });
      return result;
    }

    /**
     * Send data to the server; do not send any data from the current hour.
     *
     * Remove any data successfully sent from our records.
     *
     * @method
     */

  }, {
    key: 'sendData',
    value: function sendData() {
      var _this4 = this;

      var doNotSendCurrentRecord = this.getCurrentStateObject(true);
      var records = this.state.records.filter(function (record) {
        return record !== doNotSendCurrentRecord;
      });
      if (records.length) {
        Xhr({
          sync: false,
          method: 'POST',
          url: this.telemetryUrl,
          headers: {
            'content-type': 'application/json'
          },
          data: {
            id: Util.uuid(this.state.id),
            layer_app_id: this.client.appId,
            records: records.map(function (record) {
              return _this4.convertRecord(record);
            })
          }
        }, function (result) {
          if (result.success) {
            // Remove any records that were sent from our state
            _this4.state.records = _this4.state.records.filter(function (record) {
              return records.indexOf(record) === -1;
            });
            _this4.writeState();
          }
        });
      }
      this.clearEvents();
    }

    /**
     * Periodicalily call sendData to send updates to the server.
     *
     * @method
     */

  }, {
    key: 'setupReportingInterval',
    value: function setupReportingInterval() {
      if (this.enabled) {
        // Send any stale data
        this.sendData();
        this._intervalId = setInterval(this.sendData.bind(this), this.reportingInterval);
      }
    }

    /**
     * If the enabled property is set, automatically clear or start the interval.
     *
     * ```
     * telemetryMonitor.enabled = false;
     * ```
     *
     * The above code will stop the telemetryMonitor from sending data.
     *
     * @method
     */

  }, {
    key: '__updateEnabled',
    value: function __updateEnabled() {
      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = 0;
      }
      if (this.enabled) this.setupReportingInterval();
    }
  }]);

  return TelemetryMonitor;
}(Root);

/**
 * The URL to `POST` telemetry data to.
 *
 * @property {String}
 */


TelemetryMonitor.prototype.telemetryUrl = 'https://telemetry.layer.com';

/**
 * ID for the `window.setInterval` operation
 *
 * @property {Number}
 */
TelemetryMonitor.prototype._intervalId = 0;

/**
 * The reporting interval controls how frequently the module tries to report on usage data.
 *
 * It also is used to determine how to segment data into time slices.
 *
 * Value should not excede 1 day.
 *
 * @property {Number} [reportingInterval=3,600,000]  Number of miliseconds between submitting usage reports; defaults to once per hour
 */
TelemetryMonitor.prototype.reportingInterval = 1000 * 60 * 60;

/**
 * To avoid performance issues, we only write changes asynchronously; this timeoutId tracks that this has been scheduled.
 *
 * @property {Number}
 */
TelemetryMonitor.prototype._writeTimeoutId = 0;

/**
 * Constructor sets this to be the key within localStorage for accessing the cached telemetry data.
 *
 * @property {String}
 */
TelemetryMonitor.prototype.storageKey = '';

/**
 * Current state object.
 *
 * Initialized with data from localStorage, and any changes to it are written
 * back to localStorage.
 *
 * Sending records causes them to be removed from the state.
 *
 * @property {Object}
 */
TelemetryMonitor.prototype.state = null;

/**
 * Cache of in-progress performance events.
 *
 * Each key has a value representing a timestamp.  Events are removed once they are completed.
 *
 * @property {Object}
 */
TelemetryMonitor.prototype.tempState = null;

/**
 * Telemetry defaults to enabled, but can be disabled by setting this to `false`
 *
 * @property {Boolean}
 */
TelemetryMonitor.prototype.enabled = true;

/**
 * Pointer to the layer.Client
 *
 * @property {layer.Client}
 */
TelemetryMonitor.prototype.client = null;

/**
 * The presence of this causes layer.Root to automatically generate an id if one isn't present.
 *
 * This id is written to localStorage so that it can persist across sessions.
 *
 * @static
 * @property {String}
 */
TelemetryMonitor.prefixUUID = 'layer:///telemetry/';

TelemetryMonitor._supportedEvents = Root._supportedEvents.concat(['telemetry-environment']);

Root.initClass.apply(TelemetryMonitor, [TelemetryMonitor, 'TelemetryMonitor']);
module.exports = TelemetryMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90ZWxlbWV0cnktbW9uaXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBTSxPQUFPLFFBQVEsUUFBUixDQUFiO0FBQ0EsSUFBTSxNQUFNLFFBQVEsT0FBUixDQUFaO0FBQ0EsSUFBTSxPQUFPLFFBQVEsZ0JBQVIsQ0FBYjs7SUFFTSxnQjs7O0FBQ0o7Ozs7Ozs7Ozs7O0FBV0EsNEJBQVksT0FBWixFQUFxQjtBQUFBOztBQUFBLG9HQUNiLE9BRGE7O0FBRW5CLFVBQUssTUFBTCxHQUFjLFFBQVEsTUFBdEI7QUFDQSxVQUFLLEtBQUwsR0FBYTtBQUNYLFVBQUksTUFBSyxFQURFO0FBRVgsZUFBUztBQUZFLEtBQWI7QUFJQSxVQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxVQUFLLFVBQUwsR0FBa0IscUJBQXFCLE1BQUssTUFBTCxDQUFZLEtBQW5EOztBQUVBLFFBQUksQ0FBQyxPQUFPLFlBQVosRUFBMEI7QUFDeEIsWUFBSyxPQUFMLEdBQWUsS0FBZjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUk7QUFDRixZQUFNLFdBQVcsYUFBYSxNQUFLLFVBQWxCLENBQWpCO0FBQ0EsWUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNiLHVCQUFhLE9BQWIsQ0FBcUIsTUFBSyxVQUExQixFQUFzQyxLQUFLLFNBQUwsQ0FBZSxNQUFLLEtBQXBCLENBQXRDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZ0JBQUssS0FBTCxHQUFhLEtBQUssS0FBTCxDQUFXLFFBQVgsQ0FBYjtBQUNEO0FBQ0YsT0FQRCxDQU9FLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsY0FBSyxPQUFMLEdBQWUsS0FBZjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSyxNQUFMLENBQVksRUFBWixDQUFlLGNBQWYsRUFBK0IsTUFBSyxVQUFwQztBQUNBLFFBQUkscUJBQUosQ0FBMEIsTUFBSyxvQkFBTCxDQUEwQixJQUExQixPQUExQjtBQUNBLFVBQUss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LFdBQW5CO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQ0Q7QUFDRCxVQUFJLEtBQUssT0FBVCxFQUFrQixLQUFLLHNCQUFMO0FBQ25COzs7O0VBclU0QixJOztBQXdVL0I7Ozs7Ozs7QUFLQSxpQkFBaUIsU0FBakIsQ0FBMkIsWUFBM0IsR0FBMEMsNkJBQTFDOztBQUVBOzs7OztBQUtBLGlCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxDQUF6Qzs7QUFFQTs7Ozs7Ozs7O0FBU0EsaUJBQWlCLFNBQWpCLENBQTJCLGlCQUEzQixHQUErQyxPQUFPLEVBQVAsR0FBWSxFQUEzRDs7QUFFQTs7Ozs7QUFLQSxpQkFBaUIsU0FBakIsQ0FBMkIsZUFBM0IsR0FBNkMsQ0FBN0M7O0FBRUE7Ozs7O0FBS0EsaUJBQWlCLFNBQWpCLENBQTJCLFVBQTNCLEdBQXdDLEVBQXhDOztBQUVBOzs7Ozs7Ozs7O0FBVUEsaUJBQWlCLFNBQWpCLENBQTJCLEtBQTNCLEdBQW1DLElBQW5DOztBQUVBOzs7Ozs7O0FBT0EsaUJBQWlCLFNBQWpCLENBQTJCLFNBQTNCLEdBQXVDLElBQXZDOztBQUVBOzs7OztBQUtBLGlCQUFpQixTQUFqQixDQUEyQixPQUEzQixHQUFxQyxJQUFyQzs7QUFFQTs7Ozs7QUFLQSxpQkFBaUIsU0FBakIsQ0FBMkIsTUFBM0IsR0FBb0MsSUFBcEM7O0FBRUE7Ozs7Ozs7O0FBUUEsaUJBQWlCLFVBQWpCLEdBQThCLHFCQUE5Qjs7QUFFQSxpQkFBaUIsZ0JBQWpCLEdBQW9DLEtBQUssZ0JBQUwsQ0FBc0IsTUFBdEIsQ0FBNkIsQ0FDL0QsdUJBRCtELENBQTdCLENBQXBDOztBQUlBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsZ0JBQXJCLEVBQXVDLENBQUMsZ0JBQUQsRUFBbUIsa0JBQW5CLENBQXZDO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLGdCQUFqQiIsImZpbGUiOiJ0ZWxlbWV0cnktbW9uaXRvci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0cmljcyBnYXRoZXJpbmcgY29tcG9uZW50LlxuICpcbiAqIDEuIFNob3VsZCBuZXZlciBicm9hZGNhc3QgYW55IHBlcnNvbmFsbHkgaWRlbnRpZmlhYmxlIGluZm9ybWF0aW9uXG4gKiAyLiBTaG91bGQgbmV2ZXIgYnJvYWRjYXN0IGFueSB2YWx1ZXMgYWN0dWFsbHkgc2VudC9yZWNlaXZlZCBieSB1c2Vyc1xuICogMy4gSXQgY2FuIHNlbmQgaG93IGxvbmcgYW55IHR5cGUgb2Ygb3BlcmF0aW9uIHRvb2sgdG8gcGVyZm9ybVxuICogNC4gSXQgY2FuIHNlbmQgaG93IG1hbnkgdGltZXMgYW4gb3BlcmF0aW9uIHdhcyBwZXJmb3JtZWRcbiAqXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBzZXR1cCB0byBydW4gb25jZSBwZXIgaG91ciwgc2VuZGluZyBob3VybHkgdXBkYXRlcyB0byB0aGUgc2VydmVyLlxuICpcbiAqIEBjbGFzcyBsYXllci5UZWxlbWV0cnlNb25pdG9yXG4gKiBAZXh0ZW5kcyBsYXllci5Sb290XG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IFhociA9IHJlcXVpcmUoJy4veGhyJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcblxuY2xhc3MgVGVsZW1ldHJ5TW9uaXRvciBleHRlbmRzIFJvb3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBNb25pdG9yLlxuICAgKlxuICAgKiBBbiBBcHBsaWNhdGlvbiBpcyBleHBlY3RlZCB0byBvbmx5IGhhdmUgb25lIE1vbml0b3IuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IG9wdGlvbnMuY2xpZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZD10cnVlXSAgIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRlbGVtZXRyeSByZXBvcnRpbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlcG9ydGluZ0ludGVydmFsPTEwMDAgKiAzNjAwXSAgIERlZmF1bHRzIHRvIDEgaG91ciwgYnV0IGNhbiBiZSBzZXQgdG8gb3RoZXIgaW50ZXJ2YWxzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICByZWNvcmRzOiBbXSxcbiAgICB9O1xuICAgIHRoaXMudGVtcFN0YXRlID0ge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gJ2xheWVyLXRlbGVtZXRyeS0nICsgdGhpcy5jbGllbnQuYXBwSWQ7XG5cbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvbGRTdGF0ZSA9IGxvY2FsU3RvcmFnZVt0aGlzLnN0b3JhZ2VLZXldO1xuICAgICAgICBpZiAoIW9sZFN0YXRlKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IEpTT04ucGFyc2Uob2xkU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2xpZW50Lm9uKCdzdGF0ZS1jaGFuZ2UnLCB0aGlzLnRyYWNrRXZlbnQsIHRoaXMpO1xuICAgIFhoci5hZGRDb25uZWN0aW9uTGlzdGVuZXIodGhpcy50cmFja1Jlc3RQZXJmb3JtYW5jZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNldHVwUmVwb3J0aW5nSW50ZXJ2YWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGB0ZWxlbWV0cnlJZGAgYW5kIGFuIG9wdGlvbmFsIGBpZGAsIGFuZCBhIGBzdGFydGVkYCBvciBgZW5kZWRgIGtleSxcbiAgICogdHJhY2sgcGVyZm9ybWFuY2Ugb2YgdGhlIGdpdmVuIHRlbGVtZXRyeSBzdGF0aXN0aWMuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHRyYWNrRXZlbnQoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCBldmVudElkID0gYCR7ZXZ0LnRlbGVtZXRyeUlkfS0ke2V2dC5pZCB8fCAnbm9pZCd9YDtcblxuICAgIGlmIChldnQuc3RhcnRlZCkge1xuICAgICAgdGhpcy50ZW1wU3RhdGVbZXZlbnRJZF0gPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAoZXZ0LmVuZGVkKSB7XG4gICAgICBjb25zdCBzdGFydGVkID0gdGhpcy50ZW1wU3RhdGVbZXZlbnRJZF07XG4gICAgICBpZiAoc3RhcnRlZCkge1xuICAgICAgICBkZWxldGUgdGhpcy50ZW1wU3RhdGVbZXZlbnRJZF07XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0ZWQ7XG4gICAgICAgIHRoaXMud3JpdGVQZXJmb3JtYW5jZShldnQudGVsZW1ldHJ5SWQsIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGFueSByZXF1ZXN0cyB0aGF0IHdlcmUgbmV2ZXIgY29tcGxldGVkLlxuICAgKlxuICAgKiBDdXJyZW50bHkgd2Ugb25seSB0cmFjayBhbiBpZCBhbmQgYSBzdGFydCB0aW1lLCBzbyB3ZSBkb24ndCBrbm93IG11Y2ggYWJvdXQgdGhlc2UgZXZlbnRzLlxuICAgKlxuICAgKiBAbWV0aG9kIGNsZWFyRXZlbnRzXG4gICAqL1xuICBjbGVhckV2ZW50cygpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMudGVtcFN0YXRlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnRlbXBTdGF0ZVtrZXldICsgdGhpcy5yZXBvcnRpbmdJbnRlcnZhbCA8IG5vdykgZGVsZXRlIHRoaXMudGVtcFN0YXRlW2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQW55IHhociByZXF1ZXN0IHRoYXQgd2FzIGNhbGxlZCB3aXRoIGEgYHRlbGVtZXRyeWAga2V5IGNvbnRhaW5zIG1ldHJpY3MgdG8gYmUgbG9nZ2VkLlxuICAgKlxuICAgKiBUaGUgYHRlbGVtZXRyeWAgb2JqZWN0IHNob3VsZCBjb250YWluIGBuYW1lYCBhbmQgYGR1cmF0aW9uYCBrZXlzXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHRyYWNrUmVzdFBlcmZvcm1hbmNlKGV2dCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgZXZ0LnJlcXVlc3QudGVsZW1ldHJ5KSB7XG4gICAgICB0aGlzLndyaXRlUGVyZm9ybWFuY2UoZXZ0LnJlcXVlc3QudGVsZW1ldHJ5Lm5hbWUsIGV2dC5kdXJhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gd3JpdGluZyBwZXJmb3JtYW5jZSwgdGhlcmUgYXJlIHRocmVlIGlucHV0cyB1c2VkOlxuICAgKlxuICAgKiAxLiBUaGUgbmFtZSBvZiB0aGUgbWV0cmljIGJlaW5nIHRyYWNrZWRcbiAgICogMi4gVGhlIGR1cmF0aW9uIGl0IHRvb2sgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogMy4gVGhlIGN1cnJlbnQgdGltZSAodGhpcyBpcyBub3QgYSBmdW5jdGlvbiBpbnB1dCwgYnV0IGlzIHN0aWxsIGEgZGVwZW5kZW5jeSlcbiAgICpcbiAgICogUmVzdWx0cyBvZiB3cml0aW5nIHBlcmZvcm1hbmNlIGFyZSB0byBpbmNyZW1lbnQgY291bnQsIGFuZCB0b3RhbCB0aW1lIGZvciB0aGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICB3cml0ZVBlcmZvcm1hbmNlKG5hbWUsIHRpbWluZykge1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlID0gdGhpcy5nZXRDdXJyZW50U3RhdGVPYmplY3QoKS5wZXJmb3JtYW5jZTtcbiAgICBpZiAoIXBlcmZvcm1hbmNlW25hbWVdKSB7XG4gICAgICBwZXJmb3JtYW5jZVtuYW1lXSA9IHtcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIG1heDogMCxcbiAgICAgIH07XG4gICAgfVxuICAgIHBlcmZvcm1hbmNlW25hbWVdLmNvdW50Kys7XG4gICAgcGVyZm9ybWFuY2VbbmFtZV0udGltZSArPSB0aW1pbmc7XG4gICAgaWYgKHRpbWluZyA+IHBlcmZvcm1hbmNlW25hbWVdLm1heCkgcGVyZm9ybWFuY2VbbmFtZV0ubWF4ID0gdGltaW5nO1xuICAgIHRoaXMud3JpdGVTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gd3JpdGluZyB1c2FnZSwgd2UgYXJlIHNpbXBseSBpbmNyZW1lbnRpbmcgdGhlIHVzYWdlIGNvdW50ZXIgZm9yIHRoZSBtZXRyaWMuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHdyaXRlVXNhZ2UobmFtZSkge1xuICAgIGNvbnN0IHVzYWdlID0gdGhpcy5nZXRDdXJyZW50U3RhdGVPYmplY3QoKS51c2FnZTtcbiAgICBpZiAoIXVzYWdlW25hbWVdKSB1c2FnZVtuYW1lXSA9IDA7XG4gICAgdXNhZ2VbbmFtZV0rKztcbiAgICB0aGlzLndyaXRlU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcmFiIHNvbWUgZW52aXJvbm1lbnRhbCBkYXRhIHRvIGF0dGFjaCB0byB0aGUgcmVwb3J0LlxuICAgKlxuICAgKiBub3RlIHRoYXQgZW52aXJvbm1lbnRhbCBkYXRhIG1heSBjaGFuZ2UgZnJvbSBob3VyIHRvIGhvdXIsXG4gICAqIHNvIHdlIHJlZ2F0aGVyIHRoaXMgaW5mb3JtYXRpb24gZm9yIGVhY2ggcmVjb3JkIHdlIHNlbmQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgZ2V0RW52aXJvbm1lbnQoKSB7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSB7XG4gICAgICBwbGF0Zm9ybTogJ3dlYicsXG4gICAgICBsb2NhbGU6IChuYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgJycpLnJlcGxhY2UoLy0vZywgJ18nKSwgLy8gc2hvdWxkIG1hdGNoIHRoZSBlbl91cyBmb3JtYXQgdGhhdCBtb2JpbGUgZGV2aWNlcyBhcmUgdXNpbmcgcmF0aGVyIHRoYW4gdGhlIG11Y2ggbmljZXIgZW4tdXNcbiAgICAgIGxheWVyX3Nka192ZXJzaW9uOiB0aGlzLmNsaWVudC5jb25zdHJ1Y3Rvci52ZXJzaW9uLFxuICAgICAgZG9tYWluOiBsb2NhdGlvbi5ob3N0bmFtZSxcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBldmVudCBhbGxvd3Mgb3RoZXIgbGlicmFyaWVzIHRvIGFkZCBpbmZvcm1hdGlvbiB0byB0aGUgZW52aXJvbm1lbnQgb2JqZWN0OyBzcGVjaWZpY2FsbHk6IExheWVyIFVJXG4gICAgdGhpcy50cmlnZ2VyKCd0ZWxlbWV0cnktZW52aXJvbm1lbnQnLCB7XG4gICAgICBlbnZpcm9ubWVudFxuICAgIH0pO1xuICAgIHJldHVybiBlbnZpcm9ubWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcmFiIHNvbWUgZGV2aWNlIGRhdGEgdG8gYXR0YWNoIHRvIHRoZSByZXBvcnQuXG4gICAqXG4gICAqIG5vdGUgdGhhdCBkZXZpY2UgZGF0YSBtYXkgY2hhbmdlIGZyb20gaG91ciB0byBob3VyLFxuICAgKiBzbyB3ZSByZWdhdGhlciB0aGlzIGluZm9ybWF0aW9uIGZvciBlYWNoIHJlY29yZCB3ZSBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGdldERldmljZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcl9hZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIHNjcmVlbjoge1xuICAgICAgICB3aWR0aDogdHlwZW9mIHNjcmVlbiA9PT0gdW5kZWZpbmVkID8gMCA6IHNjcmVlbi53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0eXBlb2Ygc2NyZWVuID09PSB1bmRlZmluZWQgPyAwIDogc2NyZWVuLmhlaWdodCxcbiAgICAgIH0sXG4gICAgICB3aW5kb3c6IHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0YXRlIG9iamVjdCB1c2VkIHRvIHRyYWNrIHBlcmZvcm1hbmNlIGZvciB0aGUgY3VycmVudCB0aW1lIHNsb3RcbiAgICpcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgZ2V0Q3VycmVudFN0YXRlT2JqZWN0KGRvTm90Q3JlYXRlKSB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIHRvZGF5LnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUodG9kYXkpO1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIHRoZSByZXBvcnRpbmcgaW50ZXJ2YWwgaXMgbGVzcyB0aGFuIDI0IGhvdXJzLCBpdGVyYXRlIHVudGlsIHdlIGZpbmQgdGhlIGN1cnJlbnQgdGltZSBzbGljZSB3aXRoaW4gb3VyIGRheVxuICAgIGlmICh0aGlzLnJlcG9ydGluZ0ludGVydmFsIDwgNjAgKiA2MCAqIDEwMDAgKiAyNCkge1xuICAgICAgd2hpbGUgKGN1cnJlbnREYXRlLmdldFRpbWUoKSA8IG5vdykge1xuICAgICAgICBjdXJyZW50RGF0ZS5zZXRNaWxsaXNlY29uZHMoY3VycmVudERhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLnJlcG9ydGluZ0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50U3RhcnQgPSBjdXJyZW50RGF0ZS50b0lTT1N0cmluZygpO1xuICAgIGNvbnN0IGN1cnJlbnRFbmREYXRlID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xuICAgIGN1cnJlbnRFbmREYXRlLnNldE1pbGxpc2Vjb25kcyhjdXJyZW50RW5kRGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMucmVwb3J0aW5nSW50ZXJ2YWwpO1xuICAgIGxldCB0b2RheU9iaiA9IHRoaXMuc3RhdGUucmVjb3Jkcy5maWx0ZXIoc2V0ID0+IHNldC5wZXJpb2Quc3RhcnQgPT09IGN1cnJlbnRTdGFydClbMF07XG5cbiAgICBpZiAoIXRvZGF5T2JqICYmICFkb05vdENyZWF0ZSkge1xuICAgICAgdG9kYXlPYmogPSB7XG4gICAgICAgIHBlcmlvZDoge1xuICAgICAgICAgIHN0YXJ0OiBjdXJyZW50U3RhcnQsXG4gICAgICAgICAgZW5kOiBjdXJyZW50RW5kRGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICBlbnZpcm9ubWVudDogdGhpcy5nZXRFbnZpcm9ubWVudCgpLFxuICAgICAgICBkZXZpY2U6IHRoaXMuZ2V0RGV2aWNlKCksXG4gICAgICAgIHVzYWdlOiB7fSxcbiAgICAgICAgcGVyZm9ybWFuY2U6IHt9LFxuICAgICAgICBlcnJvcnM6IHt9LFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUucmVjb3Jkcy5wdXNoKHRvZGF5T2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9kYXlPYmo7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgc3RhdGUgdG8gbG9jYWxTdG9yYWdlLlxuICAgKlxuICAgKiBXcml0aW5nIHRoZSBzdGF0ZSBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHRoYXQgc2hvdWxkIGJlIGRvbmUgbGVzcyBvZnRlbixcbiAgICogYW5kIGNvbnRhaW5pbmcgbW9yZSBjaGFuZ2VzIHJhdGhlciB0aGFuIGRvbmUgaW1tZWRpYXRsZXkgYW5kIHJlcGVhdGVkIHdpdGggZWFjaCBjaGFuZ2UuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHdyaXRlU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiAhdGhpcy5fd3JpdGVUaW1lb3V0SWQpIHtcbiAgICAgIHRoaXMuX3dyaXRlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0ZSkpO1xuICAgICAgICB0aGlzLl93cml0ZVRpbWVvdXRJZCA9IDA7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSB0aW1lIHNsb3QncyBkYXRhLCBjb252ZXJ0IGl0cyBkYXRhIHRvIHdoYXQgdGhlIHNlcnZlciBleHBlY3RzLlxuICAgKlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBjb252ZXJ0UmVjb3JkKHJlY29yZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHBlcmlvZDogcmVjb3JkLnBlcmlvZCxcbiAgICAgIGRldmljZTogcmVjb3JkLmRldmljZSxcbiAgICAgIGVudmlyb25tZW50OiByZWNvcmQuZW52aXJvbm1lbnQsXG4gICAgICB1c2FnZTogcmVjb3JkLnVzYWdlLFxuICAgICAgcGVyZm9ybWFuY2U6IHt9LFxuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyhyZWNvcmQucGVyZm9ybWFuY2UpLmZvckVhY2goKHBlcmZvcm1hbmNlS2V5KSA9PiB7XG4gICAgICBjb25zdCBpdGVtID0gcmVjb3JkLnBlcmZvcm1hbmNlW3BlcmZvcm1hbmNlS2V5XTtcbiAgICAgIHJlc3VsdC5wZXJmb3JtYW5jZVtwZXJmb3JtYW5jZUtleV0gPSB7XG4gICAgICAgIG1heDogTWF0aC5yb3VuZChpdGVtLm1heCksXG4gICAgICAgIGNvdW50OiBpdGVtLmNvdW50LFxuICAgICAgICBtZWFuOiBNYXRoLnJvdW5kKGl0ZW0udGltZSAvIGl0ZW0uY291bnQpLCAvLyBjb252ZXJ0IHRvIG1lYW4gaW4gbWlsaXNlY29uZHMgZnJvbSB0b3RhbCB0aW1lIGluIG5hbm9zZWNvbmRzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBkYXRhIHRvIHRoZSBzZXJ2ZXI7IGRvIG5vdCBzZW5kIGFueSBkYXRhIGZyb20gdGhlIGN1cnJlbnQgaG91ci5cbiAgICpcbiAgICogUmVtb3ZlIGFueSBkYXRhIHN1Y2Nlc3NmdWxseSBzZW50IGZyb20gb3VyIHJlY29yZHMuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHNlbmREYXRhKCkge1xuICAgIGNvbnN0IGRvTm90U2VuZEN1cnJlbnRSZWNvcmQgPSB0aGlzLmdldEN1cnJlbnRTdGF0ZU9iamVjdCh0cnVlKTtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5zdGF0ZS5yZWNvcmRzXG4gICAgICAuZmlsdGVyKHJlY29yZCA9PiByZWNvcmQgIT09IGRvTm90U2VuZEN1cnJlbnRSZWNvcmQpO1xuICAgIGlmIChyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgWGhyKHtcbiAgICAgICAgc3luYzogZmFsc2UsXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB1cmw6IHRoaXMudGVsZW1ldHJ5VXJsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IFV0aWwudXVpZCh0aGlzLnN0YXRlLmlkKSxcbiAgICAgICAgICBsYXllcl9hcHBfaWQ6IHRoaXMuY2xpZW50LmFwcElkLFxuICAgICAgICAgIHJlY29yZHM6IHJlY29yZHMubWFwKHJlY29yZCA9PiB0aGlzLmNvbnZlcnRSZWNvcmQocmVjb3JkKSksXG4gICAgICAgIH0sXG4gICAgICB9LCAocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVjb3JkcyB0aGF0IHdlcmUgc2VudCBmcm9tIG91ciBzdGF0ZVxuICAgICAgICAgIHRoaXMuc3RhdGUucmVjb3JkcyA9IHRoaXMuc3RhdGUucmVjb3Jkcy5maWx0ZXIoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZHMuaW5kZXhPZihyZWNvcmQpID09PSAtMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLndyaXRlU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJFdmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJpb2RpY2FsaWx5IGNhbGwgc2VuZERhdGEgdG8gc2VuZCB1cGRhdGVzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICovXG4gIHNldHVwUmVwb3J0aW5nSW50ZXJ2YWwoKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgLy8gU2VuZCBhbnkgc3RhbGUgZGF0YVxuICAgICAgdGhpcy5zZW5kRGF0YSgpO1xuICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMuc2VuZERhdGEuYmluZCh0aGlzKSwgdGhpcy5yZXBvcnRpbmdJbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBlbmFibGVkIHByb3BlcnR5IGlzIHNldCwgYXV0b21hdGljYWxseSBjbGVhciBvciBzdGFydCB0aGUgaW50ZXJ2YWwuXG4gICAqXG4gICAqIGBgYFxuICAgKiB0ZWxlbWV0cnlNb25pdG9yLmVuYWJsZWQgPSBmYWxzZTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb2RlIHdpbGwgc3RvcCB0aGUgdGVsZW1ldHJ5TW9uaXRvciBmcm9tIHNlbmRpbmcgZGF0YS5cbiAgICpcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgX191cGRhdGVFbmFibGVkKCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnZhbElkKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHRoaXMuc2V0dXBSZXBvcnRpbmdJbnRlcnZhbCgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFVSTCB0byBgUE9TVGAgdGVsZW1ldHJ5IGRhdGEgdG8uXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJvdG90eXBlLnRlbGVtZXRyeVVybCA9ICdodHRwczovL3RlbGVtZXRyeS5sYXllci5jb20nO1xuXG4vKipcbiAqIElEIGZvciB0aGUgYHdpbmRvdy5zZXRJbnRlcnZhbGAgb3BlcmF0aW9uXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJvdG90eXBlLl9pbnRlcnZhbElkID0gMDtcblxuLyoqXG4gKiBUaGUgcmVwb3J0aW5nIGludGVydmFsIGNvbnRyb2xzIGhvdyBmcmVxdWVudGx5IHRoZSBtb2R1bGUgdHJpZXMgdG8gcmVwb3J0IG9uIHVzYWdlIGRhdGEuXG4gKlxuICogSXQgYWxzbyBpcyB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gc2VnbWVudCBkYXRhIGludG8gdGltZSBzbGljZXMuXG4gKlxuICogVmFsdWUgc2hvdWxkIG5vdCBleGNlZGUgMSBkYXkuXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyZXBvcnRpbmdJbnRlcnZhbD0zLDYwMCwwMDBdICBOdW1iZXIgb2YgbWlsaXNlY29uZHMgYmV0d2VlbiBzdWJtaXR0aW5nIHVzYWdlIHJlcG9ydHM7IGRlZmF1bHRzIHRvIG9uY2UgcGVyIGhvdXJcbiAqL1xuVGVsZW1ldHJ5TW9uaXRvci5wcm90b3R5cGUucmVwb3J0aW5nSW50ZXJ2YWwgPSAxMDAwICogNjAgKiA2MDtcblxuLyoqXG4gKiBUbyBhdm9pZCBwZXJmb3JtYW5jZSBpc3N1ZXMsIHdlIG9ubHkgd3JpdGUgY2hhbmdlcyBhc3luY2hyb25vdXNseTsgdGhpcyB0aW1lb3V0SWQgdHJhY2tzIHRoYXQgdGhpcyBoYXMgYmVlbiBzY2hlZHVsZWQuXG4gKlxuICogQHByb3BlcnR5IHtOdW1iZXJ9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJvdG90eXBlLl93cml0ZVRpbWVvdXRJZCA9IDA7XG5cbi8qKlxuICogQ29uc3RydWN0b3Igc2V0cyB0aGlzIHRvIGJlIHRoZSBrZXkgd2l0aGluIGxvY2FsU3RvcmFnZSBmb3IgYWNjZXNzaW5nIHRoZSBjYWNoZWQgdGVsZW1ldHJ5IGRhdGEuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJvdG90eXBlLnN0b3JhZ2VLZXkgPSAnJztcblxuLyoqXG4gKiBDdXJyZW50IHN0YXRlIG9iamVjdC5cbiAqXG4gKiBJbml0aWFsaXplZCB3aXRoIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UsIGFuZCBhbnkgY2hhbmdlcyB0byBpdCBhcmUgd3JpdHRlblxuICogYmFjayB0byBsb2NhbFN0b3JhZ2UuXG4gKlxuICogU2VuZGluZyByZWNvcmRzIGNhdXNlcyB0aGVtIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3RhdGUuXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJvdG90eXBlLnN0YXRlID0gbnVsbDtcblxuLyoqXG4gKiBDYWNoZSBvZiBpbi1wcm9ncmVzcyBwZXJmb3JtYW5jZSBldmVudHMuXG4gKlxuICogRWFjaCBrZXkgaGFzIGEgdmFsdWUgcmVwcmVzZW50aW5nIGEgdGltZXN0YW1wLiAgRXZlbnRzIGFyZSByZW1vdmVkIG9uY2UgdGhleSBhcmUgY29tcGxldGVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICovXG5UZWxlbWV0cnlNb25pdG9yLnByb3RvdHlwZS50ZW1wU3RhdGUgPSBudWxsO1xuXG4vKipcbiAqIFRlbGVtZXRyeSBkZWZhdWx0cyB0byBlbmFibGVkLCBidXQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgdGhpcyB0byBgZmFsc2VgXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufVxuICovXG5UZWxlbWV0cnlNb25pdG9yLnByb3RvdHlwZS5lbmFibGVkID0gdHJ1ZTtcblxuLyoqXG4gKiBQb2ludGVyIHRvIHRoZSBsYXllci5DbGllbnRcbiAqXG4gKiBAcHJvcGVydHkge2xheWVyLkNsaWVudH1cbiAqL1xuVGVsZW1ldHJ5TW9uaXRvci5wcm90b3R5cGUuY2xpZW50ID0gbnVsbDtcblxuLyoqXG4gKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBjYXVzZXMgbGF5ZXIuUm9vdCB0byBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuIGlkIGlmIG9uZSBpc24ndCBwcmVzZW50LlxuICpcbiAqIFRoaXMgaWQgaXMgd3JpdHRlbiB0byBsb2NhbFN0b3JhZ2Ugc28gdGhhdCBpdCBjYW4gcGVyc2lzdCBhY3Jvc3Mgc2Vzc2lvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9XG4gKi9cblRlbGVtZXRyeU1vbml0b3IucHJlZml4VVVJRCA9ICdsYXllcjovLy90ZWxlbWV0cnkvJztcblxuVGVsZW1ldHJ5TW9uaXRvci5fc3VwcG9ydGVkRXZlbnRzID0gUm9vdC5fc3VwcG9ydGVkRXZlbnRzLmNvbmNhdChbXG4gICd0ZWxlbWV0cnktZW52aXJvbm1lbnQnXG5dKTtcblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoVGVsZW1ldHJ5TW9uaXRvciwgW1RlbGVtZXRyeU1vbml0b3IsICdUZWxlbWV0cnlNb25pdG9yJ10pO1xubW9kdWxlLmV4cG9ydHMgPSBUZWxlbWV0cnlNb25pdG9yO1xuIl19
