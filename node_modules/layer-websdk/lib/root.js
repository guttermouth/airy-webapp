'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Utils = require('./client-utils');
var LayerEvent = require('./layer-event');
var LayerError = require('./layer-error');
var Events = require('backbone-events-standalone/backbone-events-standalone');
var Logger = require('./logger');

/*
 * Provides a system bus that can be accessed by all components of the system.
 * Currently used to listen to messages sent via postMessage, but envisioned to
 * do far more.
 */
function EventClass() {}
EventClass.prototype = Events;

var SystemBus = new EventClass();
if (typeof postMessage === 'function') {
  addEventListener('message', function (event) {
    if (event.data.type === 'layer-delayed-event') {
      SystemBus.trigger(event.data.internalId + '-delayed-event');
    }
  });
}

// Used to generate a unique internalId for every Root instance
var uniqueIds = {};

// Regex for splitting an event string such as obj.on('evtName1 evtName2 evtName3')
var eventSplitter = /\s+/;

/**
 * The root class of all layer objects. Provides the following utilities
 *
 * 1. Mixes in the Backbone event model
 *
 *        var person = new Person();
 *        person.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        });
 *
 *        // Fire the console log handler:
 *        person.trigger('destroy');
 *
 *        // Unsubscribe
 *        person.off('destroy');
 *
 * 2. Adds a subscriptions object so that any event handlers on an object can be quickly found and removed
 *
 *        var person1 = new Person();
 *        var person2 = new Person();
 *        person2.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        }, person1);
 *
 *        // Pointers to person1 held onto by person2 are removed
 *        person1.destroy();
 *
 * 3. Adds support for event listeners in the constructor
 *    Any event handler can be passed into the constructor
 *    just as though it were a property.
 *
 *        var person = new Person({
 *            age: 150,
 *            destroy: function() {
 *                console.log('I have been destroyed!');
 *            }
 *        });
 *
 * 4. A _disableEvents property
 *
 *        myMethod() {
 *          if (this.isInitializing) {
 *              this._disableEvents = true;
 *
 *              // Event only received if _disableEvents = false
 *              this.trigger('destroy');
 *              this._disableEvents = false;
 *          }
 *        }
 *
 * 5. A _supportedEvents static property for each class
 *
 *     This property defines which events can be triggered.
 *
 *     * Any attempt to trigger
 *       an event not in _supportedEvents will log an error.
 *     * Any attempt to register a listener for an event not in _supportedEvents will
 *     *throw* an error.
 *
 *     This allows us to insure developers only subscribe to valid events.
 *
 *     This allows us to control what events can be fired and which ones blocked.
 *
 * 6. Adds an internalId property
 *
 *        var person = new Person();
 *        console.log(person.internalId); // -> 'Person1'
 *
 * 7. Adds a toObject method to create a simplified Plain Old Javacript Object from your object
 *
 *        var person = new Person();
 *        var simplePerson = person.toObject();
 *
 * 8. Provides __adjustProperty method support
 *
 *     For any property of a class, an `__adjustProperty` method can be defined.  If its defined,
 *     it will be called prior to setting that property, allowing:
 *
 *     A. Modification of the value that is actually set
 *     B. Validation of the value; throwing errors if invalid.
 *
 * 9. Provides __udpateProperty method support
 *
 *     After setting any property for which there is an `__updateProperty` method defined,
 *     the method will be called, allowing the new property to be applied.
 *
 *     Typically used for
 *
 *     A. Triggering events
 *     B. Firing XHR requests
 *     C. Updating the UI to match the new property value
 *
 *
 * @class layer.Root
 * @abstract
 * @author Michael Kantor
 */

var Root = function (_EventClass) {
  _inherits(Root, _EventClass);

  /**
   * Superclass constructor handles copying in properties and registering event handlers.
   *
   * @method constructor
   * @param  {Object} options - a hash of properties and event handlers
   * @return {layer.Root}
   */
  function Root() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Root);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Root).call(this));

    _this._layerEventSubscriptions = [];
    _this._delayedTriggers = [];
    _this._lastDelayedTrigger = Date.now();
    _this._events = {};

    // Generate an internalId
    var name = _this.constructor.name;
    if (!uniqueIds[name]) uniqueIds[name] = 0;
    _this.internalId = name + uniqueIds[name]++;

    // Every component listens to the SystemBus for postMessage (triggerAsync) events
    SystemBus.on(_this.internalId + '-delayed-event', _this._processDelayedTriggers, _this);

    // Generate a temporary id if there isn't an id
    if (!_this.id && !options.id && _this.constructor.prefixUUID) {
      _this.id = _this.constructor.prefixUUID + Utils.generateUUID();
    }

    // Copy in all properties; setup all event handlers
    var key = void 0;
    for (key in options) {
      if (_this.constructor._supportedEvents.indexOf(key) !== -1) {
        _this.on(key, options[key]);
      } else if (key in _this && typeof _this[key] !== 'function') {
        _this[key] = options[key];
      }
    }
    _this.isInitializing = false;
    return _this;
  }

  /**
   * Destroys the object.
   *
   * Cleans up all events / subscriptions
   * and marks the object as isDestroyed.
   *
   * @method destroy
   */


  _createClass(Root, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      if (this.isDestroyed) throw new Error(LayerError.dictionary.alreadyDestroyed);

      // If anyone is listening, notify them
      this.trigger('destroy');

      // Cleanup pointers to SystemBus. Failure to call destroy
      // will have very serious consequences...
      SystemBus.off(this.internalId + '-delayed-event', null, this);

      // Remove all events, and all pointers passed to this object by other objects
      this.off();

      // Find all of the objects that this object has passed itself to in the form
      // of event handlers and remove all references to itself.
      this._layerEventSubscriptions.forEach(function (item) {
        return item.off(null, null, _this2);
      });

      this._layerEventSubscriptions = null;
      this._delayedTriggers = null;
      this.isDestroyed = true;
    }
  }, {
    key: 'toObject',


    /**
     * Convert class instance to Plain Javascript Object.
     *
     * Strips out all private members, and insures no datastructure loops.
     * Recursively converting all subobjects using calls to toObject.
     *
     *      console.dir(myobj.toObject());
     *
     * Note: While it would be tempting to have noChildren default to true,
     * this would result in Message.toObject() not outputing its MessageParts.
     *
     * Private data (_ prefixed properties) will not be output.
     *
     * @method toObject
     * @param  {boolean} [noChildren=false] Don't output sub-components
     * @return {Object}
     */
    value: function toObject() {
      var _this3 = this;

      var noChildren = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      this.__inToObject = true;
      var obj = {};

      // Iterate over all formally defined properties
      try {
        var keys = [];
        var aKey = void 0;
        for (aKey in this.constructor.prototype) {
          if (!(aKey in Root.prototype)) keys.push(aKey);
        }keys.forEach(function (key) {
          var v = _this3[key];

          // Ignore private/protected properties and functions
          if (key.indexOf('_') === 0) return;
          if (typeof v === 'function') return;

          // Generate arrays...
          if (Array.isArray(v)) {
            obj[key] = [];
            v.forEach(function (item) {
              if (item instanceof Root) {
                if (noChildren) {
                  delete obj[key];
                } else if (!item.__inToObject) {
                  obj[key].push(item.toObject());
                }
              } else {
                obj[key].push(item);
              }
            });
          }

          // Generate subcomponents
          else if (v instanceof Root) {
              if (!v.__inToObject && !noChildren) {
                obj[key] = v.toObject();
              }
            }

            // Generate dates (creates a copy to separate it from the source object)
            else if (v instanceof Date) {
                obj[key] = new Date(v);
              }

              // Generate simple properties
              else {
                  obj[key] = v;
                }
        });
      } catch (e) {
        // no-op
      }
      this.__inToObject = false;
      return obj;
    }

    /**
     * Log a warning for attempts to subscribe to unsupported events.
     *
     * @method _warnForEvent
     * @private
     */

  }, {
    key: '_warnForEvent',
    value: function _warnForEvent(eventName) {
      if (!Utils.includes(this.constructor._supportedEvents, eventName)) {
        throw new Error('Event ' + eventName + ' not defined for ' + this.toString());
      }
    }

    /**
     * Prepare for processing an event subscription call.
     *
     * If context is a Root class, add this object to the context's subscriptions.
     *
     * @method _prepareOn
     * @private
     */

  }, {
    key: '_prepareOn',
    value: function _prepareOn(name, handler, context) {
      var _this4 = this;

      if (context) {
        if (context instanceof Root) {
          if (context.isDestroyed) {
            throw new Error(LayerError.dictionary.isDestroyed);
          }
        }
        if (context._layerEventSubscriptions) {
          context._layerEventSubscriptions.push(this);
        }
      }
      if (typeof name === 'string' && name !== 'all') {
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          names.forEach(function (n) {
            return _this4._warnForEvent(n);
          });
        } else {
          this._warnForEvent(name);
        }
      } else if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        Object.keys(name).forEach(function (keyName) {
          return _this4._warnForEvent(keyName);
        });
      }
    }

    /**
     * Subscribe to events.
     *
     * Note that the context parameter serves double importance here:
     *
     * 1. It determines the context in which to execute the event handler
     * 2. Create a backlink so that if either subscriber or subscribee is destroyed,
     *    all pointers between them can be found and removed.
     *
     * ```
     * obj.on('someEventName someOtherEventName', mycallback, mycontext);
     * ```
     *
     * ```
     * obj.on({
     *    eventName1: callback1,
     *    eventName2: callback2
     * }, mycontext);
     * ```
     *
     * @method on
     * @param  {String} name - Name of the event
     * @param  {Function} handler - Event handler
     * @param  {layer.LayerEvent} handler.event - Event object delivered to the handler
     * @param  {Object} context - This pointer AND link to help with cleanup
     * @return {layer.Root} this
     */

  }, {
    key: 'on',
    value: function on(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.on.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Subscribe to the first occurance of the specified event.
     *
     * @method once
     * @return {layer.Root} this
     */

  }, {
    key: 'once',
    value: function once(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.once.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Unsubscribe from events.
     *
     * ```
     * // Removes all event handlers for this event:
     * obj.off('someEventName');
     *
     * // Removes all event handlers using this function pointer as callback
     * obj.off(null, f, null);
     *
     * // Removes all event handlers that `this` has subscribed to; requires
     * // obj.on to be called with `this` as its `context` parameter.
     * obj.off(null, null, this);
     * ```
     *
     * @method off
     * @param  {String} name - Name of the event; null for all event names
     * @param  {Function} handler - Event handler; null for all functions
     * @param  {Object} context - The context from the `on()` call to search for; null for all contexts
     * @return {layer.Root} this
     */

    /**
     * Trigger an event for any event listeners.
     *
     * Events triggered this way will be blocked if _disableEvents = true
     *
     * @method trigger
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: 'trigger',
    value: function trigger() {
      if (this._disableEvents) return this;
      return this._trigger.apply(this, arguments);
    }

    /**
     * Triggers an event.
     *
     * @method trigger
     * @private
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     */

  }, {
    key: '_trigger',
    value: function _trigger() {
      if (!Utils.includes(this.constructor._supportedEvents, arguments.length <= 0 ? undefined : arguments[0])) {
        if (!Utils.includes(this.constructor._ignoredEvents, arguments.length <= 0 ? undefined : arguments[0])) {
          Logger.error(this.toString() + ' ignored ' + (arguments.length <= 0 ? undefined : arguments[0]));
        }
        return;
      }

      var computedArgs = this._getTriggerArgs.apply(this, arguments);

      Events.trigger.apply(this, computedArgs);

      var parentProp = this.constructor.bubbleEventParent;
      if (parentProp && (arguments.length <= 0 ? undefined : arguments[0]) !== 'destroy') {
        var _parentValue;

        var parentValue = this[parentProp];
        parentValue = typeof parentValue === 'function' ? parentValue.apply(this) : parentValue;
        if (parentValue) (_parentValue = parentValue).trigger.apply(_parentValue, _toConsumableArray(computedArgs));
      }
    }

    /**
     * Generates a layer.LayerEvent from a trigger call's arguments.
     *
     * * If parameter is already a layer.LayerEvent, we're done.
     * * If parameter is an object, a `target` property is added to that object and its delivered to all subscribers
     * * If the parameter is non-object value, it is added to an object with a `target` property, and the value is put in
     *   the `data` property.
     *
     * @method _getTriggerArgs
     * @private
     * @return {Mixed[]} - First element of array is eventName, second element is layer.LayerEvent.
     */

  }, {
    key: '_getTriggerArgs',
    value: function _getTriggerArgs() {
      var _this5 = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var computedArgs = Array.prototype.slice.call(args);

      if (args[1]) {
        (function () {
          var newArg = { target: _this5 };

          if (computedArgs[1] instanceof LayerEvent) {
            // A LayerEvent will be an argument when bubbling events up; these args can be used as-is
          } else {
            if (_typeof(computedArgs[1]) === 'object') {
              Object.keys(computedArgs[1]).forEach(function (name) {
                return newArg[name] = computedArgs[1][name];
              });
            } else {
              newArg.data = computedArgs[1];
            }
            computedArgs[1] = new LayerEvent(newArg, computedArgs[0]);
          }
        })();
      } else {
        computedArgs[1] = new LayerEvent({ target: this }, computedArgs[0]);
      }

      return computedArgs;
    }

    /**
     * Same as _trigger() method, but delays briefly before firing.
     *
     * When would you want to delay an event?
     *
     * 1. There is an event rollup that may be needed for the event;
     *    this requires the framework to be able to see ALL events that have been
     *    generated, roll them up, and THEN fire them.
     * 2. The event is intended for UI rendering... which should not hold up the rest of
     *    this framework's execution.
     *
     * When NOT to delay an event?
     *
     * 1. Lifecycle events frequently require response at the time the event has fired
     *
     * @method _triggerAsync
     * @private
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: '_triggerAsync',
    value: function _triggerAsync() {
      var _this6 = this;

      var computedArgs = this._getTriggerArgs.apply(this, arguments);
      this._delayedTriggers.push(computedArgs);

      // NOTE: It is unclear at this time how it happens, but on very rare occasions, we see processDelayedTriggers
      // fail to get called when length = 1, and after that length just continuously grows.  So we add
      // the _lastDelayedTrigger test to insure that it will still run.
      var shouldScheduleTrigger = this._delayedTriggers.length === 1 || this._delayedTriggers.length && this._lastDelayedTrigger + 500 < Date.now();
      if (shouldScheduleTrigger) {
        this._lastDelayedTrigger = Date.now();
        if (typeof postMessage === 'function' && typeof jasmine === 'undefined') {
          var messageData = {
            type: 'layer-delayed-event',
            internalId: this.internalId
          };
          if (typeof document !== 'undefined') {
            window.postMessage(messageData, '*');
          } else {
            // React Native reportedly lacks a document, and throws errors on the second parameter
            window.postMessage(messageData);
          }
        } else {
          setTimeout(function () {
            return _this6._processDelayedTriggers();
          }, 0);
        }
      }
    }

    /**
     * Combines a set of events into a single event.
     *
     * Given an event structure of
     * ```
     *      {
     *          customName: [value1]
     *      }
     *      {
     *          customName: [value2]
     *      }
     *      {
     *          customName: [value3]
     *      }
     * ```
     *
     * Merge them into
     *
     * ```
     *      {
     *          customName: [value1, value2, value3]
     *      }
     * ```
     *
     * @method _foldEvents
     * @private
     * @param  {layer.LayerEvent[]} events
     * @param  {string} name      Name of the property (i.e. 'customName')
     * @param  {layer.Root}    newTarget Value of the target for the folded resulting event
     */

  }, {
    key: '_foldEvents',
    value: function _foldEvents(events, name, newTarget) {
      var _this7 = this;

      var firstEvt = events.length ? events[0][1] : null;
      var firstEvtProp = firstEvt ? firstEvt[name] : null;
      events.forEach(function (evt, i) {
        if (i > 0) {
          firstEvtProp.push(evt[1][name][0]);
          _this7._delayedTriggers.splice(_this7._delayedTriggers.indexOf(evt), 1);
        }
      });
      if (events.length && newTarget) events[0][1].target = newTarget;
    }

    /**
     * Fold a set of Change events into a single Change event.
     *
     * Given a set change events on this component,
     * fold all change events into a single event via
     * the layer.LayerEvent's changes array.
     *
     * @method _foldChangeEvents
     * @private
     */

  }, {
    key: '_foldChangeEvents',
    value: function _foldChangeEvents() {
      var _this8 = this;

      var events = this._delayedTriggers.filter(function (evt) {
        return evt[1].isChange;
      });
      events.forEach(function (evt, i) {
        if (i > 0) {
          events[0][1]._mergeChanges(evt[1]);
          _this8._delayedTriggers.splice(_this8._delayedTriggers.indexOf(evt), 1);
        }
      });
    }

    /**
     * Execute all delayed events for this compoennt.
     *
     * @method _processDelayedTriggers
     * @private
     */

  }, {
    key: '_processDelayedTriggers',
    value: function _processDelayedTriggers() {
      if (this.isDestroyed) return;
      this._foldChangeEvents();

      this._delayedTriggers.forEach(function (evt) {
        this.trigger.apply(this, _toConsumableArray(evt));
      }, this);
      this._delayedTriggers = [];
    }
  }, {
    key: '_runMixins',
    value: function _runMixins(mixinName, argArray) {
      var _this9 = this;

      this.constructor.mixins.forEach(function (mixin) {
        if (mixin.lifecycle[mixinName]) mixin.lifecycle[mixinName].apply(_this9, argArray);
      });
    }

    /**
     * Returns a string representation of the class that is nicer than `[Object]`.
     *
     * @method toString
     * @return {String}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.internalId;
    }
  }], [{
    key: 'isValidId',
    value: function isValidId(id) {
      return id.indexOf(this.prefixUUID) === 0;
    }
  }]);

  return Root;
}(EventClass);

function defineProperty(newClass, propertyName) {
  var pKey = '__' + propertyName;
  var camel = propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
  var hasDefinitions = newClass.prototype['__adjust' + camel] || newClass.prototype['__update' + camel] || newClass.prototype['__get' + camel];
  if (hasDefinitions) {
    // set default value
    newClass.prototype[pKey] = newClass.prototype[propertyName];

    Object.defineProperty(newClass.prototype, propertyName, {
      enumerable: true,
      get: function get() {
        return this['__get' + camel] ? this['__get' + camel](pKey) : this[pKey];
      },
      set: function set(inValue) {
        if (this.isDestroyed) return;
        var initial = this[pKey];
        if (inValue !== initial) {
          if (this['__adjust' + camel]) {
            var result = this['__adjust' + camel](inValue);
            if (result !== undefined) inValue = result;
          }
          this[pKey] = inValue;
        }
        if (inValue !== initial) {
          if (!this.isInitializing && this['__update' + camel]) {
            this['__update' + camel](inValue, initial);
          }
        }
      }
    });
  }
}

function initClass(newClass, className) {
  // Make sure our new class has a name property
  if (!newClass.name) newClass.name = className;

  // Make sure our new class has a _supportedEvents, _ignoredEvents, _inObjectIgnore and EVENTS properties
  if (!newClass._supportedEvents) newClass._supportedEvents = Root._supportedEvents;
  if (!newClass._ignoredEvents) newClass._ignoredEvents = Root._ignoredEvents;

  if (newClass.mixins) {
    newClass.mixins.forEach(function (mixin) {
      if (mixin.events) newClass._supportedEvents = newClass._supportedEvents.concat(mixin.events);
      if (mixin.properties) {
        Object.keys(mixin.properties).forEach(function (key) {
          newClass.prototype[key] = mixin.properties[key];
        });
      }
      if (mixin.methods) {
        Object.keys(mixin.methods).forEach(function (key) {
          newClass.prototype[key] = mixin.methods[key];
        });
      }
    });
  }

  // Generate a list of properties for this class; we don't include any
  // properties from layer.Root
  var keys = Object.keys(newClass.prototype).filter(function (key) {
    return newClass.prototype.hasOwnProperty(key) && !Root.prototype.hasOwnProperty(key) && typeof newClass.prototype[key] !== 'function';
  });

  // Define getters/setters for any property that has __adjust or __update methods defined
  keys.forEach(function (name) {
    return defineProperty(newClass, name);
  });
}

/**
 * Set to true once destroy() has been called.
 *
 * A destroyed object will likely cause errors in any attempt
 * to call methods on it, and will no longer trigger events.
 *
 * @type {boolean}
 * @readonly
 */
Root.prototype.isDestroyed = false;

/**
 * Every instance has its own internal ID.
 *
 * This ID is distinct from any IDs assigned by the server.
 * The internal ID is gaurenteed not to change within the lifetime of the Object/session;
 * it is possible, on creating a new object, for its `id` property to change.
 *
 * @type {string}
 * @readonly
 */
Root.prototype.internalId = '';

/**
 * True while we are in the constructor.
 *
 * @type {boolean}
 * @readonly
 */
Root.prototype.isInitializing = true;

/**
 * Objects that this object is listening for events from.
 *
 * @type {layer.Root[]}
 * @private
 */
Root.prototype._layerEventSubscriptions = null;

/**
 * Disable all events triggered on this object.
 * @type {boolean}
 * @private
 */
Root.prototype._disableEvents = false;

Root._supportedEvents = ['destroy', 'all'];
Root._ignoredEvents = [];
module.exports = Root;
module.exports.initClass = initClass;
//# sourceMappingURL=data:application/json;base64,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QUFLLE9BQUwsQ0FBYTtBQUFBLFdBQVEsZUFBZSxRQUFmLEVBQXlCLElBQXpCLENBQVI7QUFBQSxHQUFiO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLEtBQUssU0FBTCxDQUFlLFdBQWYsR0FBNkIsS0FBN0I7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxLQUFLLFNBQUwsQ0FBZSxVQUFmLEdBQTRCLEVBQTVCOztBQUVBOzs7Ozs7QUFNQSxLQUFLLFNBQUwsQ0FBZSxjQUFmLEdBQWdDLElBQWhDOztBQUVBOzs7Ozs7QUFNQSxLQUFLLFNBQUwsQ0FBZSx3QkFBZixHQUEwQyxJQUExQzs7QUFFQTs7Ozs7QUFLQSxLQUFLLFNBQUwsQ0FBZSxjQUFmLEdBQWdDLEtBQWhDOztBQUdBLEtBQUssZ0JBQUwsR0FBd0IsQ0FBQyxTQUFELEVBQVksS0FBWixDQUF4QjtBQUNBLEtBQUssY0FBTCxHQUFzQixFQUF0QjtBQUNBLE9BQU8sT0FBUCxHQUFpQixJQUFqQjtBQUNBLE9BQU8sT0FBUCxDQUFlLFNBQWYsR0FBMkIsU0FBM0IiLCJmaWxlIjoicm9vdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcbmNvbnN0IExheWVyRXZlbnQgPSByZXF1aXJlKCcuL2xheWVyLWV2ZW50Jyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi9sYXllci1lcnJvcicpO1xuY29uc3QgRXZlbnRzID0gcmVxdWlyZSgnYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUvYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbi8qXG4gKiBQcm92aWRlcyBhIHN5c3RlbSBidXMgdGhhdCBjYW4gYmUgYWNjZXNzZWQgYnkgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHN5c3RlbS5cbiAqIEN1cnJlbnRseSB1c2VkIHRvIGxpc3RlbiB0byBtZXNzYWdlcyBzZW50IHZpYSBwb3N0TWVzc2FnZSwgYnV0IGVudmlzaW9uZWQgdG9cbiAqIGRvIGZhciBtb3JlLlxuICovXG5mdW5jdGlvbiBFdmVudENsYXNzKCkgeyB9XG5FdmVudENsYXNzLnByb3RvdHlwZSA9IEV2ZW50cztcblxuY29uc3QgU3lzdGVtQnVzID0gbmV3IEV2ZW50Q2xhc3MoKTtcbmlmICh0eXBlb2YgcG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdsYXllci1kZWxheWVkLWV2ZW50Jykge1xuICAgICAgU3lzdGVtQnVzLnRyaWdnZXIoZXZlbnQuZGF0YS5pbnRlcm5hbElkICsgJy1kZWxheWVkLWV2ZW50Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gVXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlcm5hbElkIGZvciBldmVyeSBSb290IGluc3RhbmNlXG5jb25zdCB1bmlxdWVJZHMgPSB7fTtcblxuLy8gUmVnZXggZm9yIHNwbGl0dGluZyBhbiBldmVudCBzdHJpbmcgc3VjaCBhcyBvYmoub24oJ2V2dE5hbWUxIGV2dE5hbWUyIGV2dE5hbWUzJylcbmNvbnN0IGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbi8qKlxuICogVGhlIHJvb3QgY2xhc3Mgb2YgYWxsIGxheWVyIG9iamVjdHMuIFByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgdXRpbGl0aWVzXG4gKlxuICogMS4gTWl4ZXMgaW4gdGhlIEJhY2tib25lIGV2ZW50IG1vZGVsXG4gKlxuICogICAgICAgIHZhciBwZXJzb24gPSBuZXcgUGVyc29uKCk7XG4gKiAgICAgICAgcGVyc29uLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJIGhhdmUgYmVlbiBkZXN0cm95ZWQhJyk7XG4gKiAgICAgICAgfSk7XG4gKlxuICogICAgICAgIC8vIEZpcmUgdGhlIGNvbnNvbGUgbG9nIGhhbmRsZXI6XG4gKiAgICAgICAgcGVyc29uLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAqXG4gKiAgICAgICAgLy8gVW5zdWJzY3JpYmVcbiAqICAgICAgICBwZXJzb24ub2ZmKCdkZXN0cm95Jyk7XG4gKlxuICogMi4gQWRkcyBhIHN1YnNjcmlwdGlvbnMgb2JqZWN0IHNvIHRoYXQgYW55IGV2ZW50IGhhbmRsZXJzIG9uIGFuIG9iamVjdCBjYW4gYmUgcXVpY2tseSBmb3VuZCBhbmQgcmVtb3ZlZFxuICpcbiAqICAgICAgICB2YXIgcGVyc29uMSA9IG5ldyBQZXJzb24oKTtcbiAqICAgICAgICB2YXIgcGVyc29uMiA9IG5ldyBQZXJzb24oKTtcbiAqICAgICAgICBwZXJzb24yLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJIGhhdmUgYmVlbiBkZXN0cm95ZWQhJyk7XG4gKiAgICAgICAgfSwgcGVyc29uMSk7XG4gKlxuICogICAgICAgIC8vIFBvaW50ZXJzIHRvIHBlcnNvbjEgaGVsZCBvbnRvIGJ5IHBlcnNvbjIgYXJlIHJlbW92ZWRcbiAqICAgICAgICBwZXJzb24xLmRlc3Ryb3koKTtcbiAqXG4gKiAzLiBBZGRzIHN1cHBvcnQgZm9yIGV2ZW50IGxpc3RlbmVycyBpbiB0aGUgY29uc3RydWN0b3JcbiAqICAgIEFueSBldmVudCBoYW5kbGVyIGNhbiBiZSBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3JcbiAqICAgIGp1c3QgYXMgdGhvdWdoIGl0IHdlcmUgYSBwcm9wZXJ0eS5cbiAqXG4gKiAgICAgICAgdmFyIHBlcnNvbiA9IG5ldyBQZXJzb24oe1xuICogICAgICAgICAgICBhZ2U6IDE1MCxcbiAqICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSSBoYXZlIGJlZW4gZGVzdHJveWVkIScpO1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgfSk7XG4gKlxuICogNC4gQSBfZGlzYWJsZUV2ZW50cyBwcm9wZXJ0eVxuICpcbiAqICAgICAgICBteU1ldGhvZCgpIHtcbiAqICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6aW5nKSB7XG4gKiAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9IHRydWU7XG4gKlxuICogICAgICAgICAgICAgIC8vIEV2ZW50IG9ubHkgcmVjZWl2ZWQgaWYgX2Rpc2FibGVFdmVudHMgPSBmYWxzZVxuICogICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICogICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSBmYWxzZTtcbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKlxuICogNS4gQSBfc3VwcG9ydGVkRXZlbnRzIHN0YXRpYyBwcm9wZXJ0eSBmb3IgZWFjaCBjbGFzc1xuICpcbiAqICAgICBUaGlzIHByb3BlcnR5IGRlZmluZXMgd2hpY2ggZXZlbnRzIGNhbiBiZSB0cmlnZ2VyZWQuXG4gKlxuICogICAgICogQW55IGF0dGVtcHQgdG8gdHJpZ2dlclxuICogICAgICAgYW4gZXZlbnQgbm90IGluIF9zdXBwb3J0ZWRFdmVudHMgd2lsbCBsb2cgYW4gZXJyb3IuXG4gKiAgICAgKiBBbnkgYXR0ZW1wdCB0byByZWdpc3RlciBhIGxpc3RlbmVyIGZvciBhbiBldmVudCBub3QgaW4gX3N1cHBvcnRlZEV2ZW50cyB3aWxsXG4gKiAgICAgKnRocm93KiBhbiBlcnJvci5cbiAqXG4gKiAgICAgVGhpcyBhbGxvd3MgdXMgdG8gaW5zdXJlIGRldmVsb3BlcnMgb25seSBzdWJzY3JpYmUgdG8gdmFsaWQgZXZlbnRzLlxuICpcbiAqICAgICBUaGlzIGFsbG93cyB1cyB0byBjb250cm9sIHdoYXQgZXZlbnRzIGNhbiBiZSBmaXJlZCBhbmQgd2hpY2ggb25lcyBibG9ja2VkLlxuICpcbiAqIDYuIEFkZHMgYW4gaW50ZXJuYWxJZCBwcm9wZXJ0eVxuICpcbiAqICAgICAgICB2YXIgcGVyc29uID0gbmV3IFBlcnNvbigpO1xuICogICAgICAgIGNvbnNvbGUubG9nKHBlcnNvbi5pbnRlcm5hbElkKTsgLy8gLT4gJ1BlcnNvbjEnXG4gKlxuICogNy4gQWRkcyBhIHRvT2JqZWN0IG1ldGhvZCB0byBjcmVhdGUgYSBzaW1wbGlmaWVkIFBsYWluIE9sZCBKYXZhY3JpcHQgT2JqZWN0IGZyb20geW91ciBvYmplY3RcbiAqXG4gKiAgICAgICAgdmFyIHBlcnNvbiA9IG5ldyBQZXJzb24oKTtcbiAqICAgICAgICB2YXIgc2ltcGxlUGVyc29uID0gcGVyc29uLnRvT2JqZWN0KCk7XG4gKlxuICogOC4gUHJvdmlkZXMgX19hZGp1c3RQcm9wZXJ0eSBtZXRob2Qgc3VwcG9ydFxuICpcbiAqICAgICBGb3IgYW55IHByb3BlcnR5IG9mIGEgY2xhc3MsIGFuIGBfX2FkanVzdFByb3BlcnR5YCBtZXRob2QgY2FuIGJlIGRlZmluZWQuICBJZiBpdHMgZGVmaW5lZCxcbiAqICAgICBpdCB3aWxsIGJlIGNhbGxlZCBwcmlvciB0byBzZXR0aW5nIHRoYXQgcHJvcGVydHksIGFsbG93aW5nOlxuICpcbiAqICAgICBBLiBNb2RpZmljYXRpb24gb2YgdGhlIHZhbHVlIHRoYXQgaXMgYWN0dWFsbHkgc2V0XG4gKiAgICAgQi4gVmFsaWRhdGlvbiBvZiB0aGUgdmFsdWU7IHRocm93aW5nIGVycm9ycyBpZiBpbnZhbGlkLlxuICpcbiAqIDkuIFByb3ZpZGVzIF9fdWRwYXRlUHJvcGVydHkgbWV0aG9kIHN1cHBvcnRcbiAqXG4gKiAgICAgQWZ0ZXIgc2V0dGluZyBhbnkgcHJvcGVydHkgZm9yIHdoaWNoIHRoZXJlIGlzIGFuIGBfX3VwZGF0ZVByb3BlcnR5YCBtZXRob2QgZGVmaW5lZCxcbiAqICAgICB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkLCBhbGxvd2luZyB0aGUgbmV3IHByb3BlcnR5IHRvIGJlIGFwcGxpZWQuXG4gKlxuICogICAgIFR5cGljYWxseSB1c2VkIGZvclxuICpcbiAqICAgICBBLiBUcmlnZ2VyaW5nIGV2ZW50c1xuICogICAgIEIuIEZpcmluZyBYSFIgcmVxdWVzdHNcbiAqICAgICBDLiBVcGRhdGluZyB0aGUgVUkgdG8gbWF0Y2ggdGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZVxuICpcbiAqXG4gKiBAY2xhc3MgbGF5ZXIuUm9vdFxuICogQGFic3RyYWN0XG4gKiBAYXV0aG9yIE1pY2hhZWwgS2FudG9yXG4gKi9cbmNsYXNzIFJvb3QgZXh0ZW5kcyBFdmVudENsYXNzIHtcblxuICAvKipcbiAgICogU3VwZXJjbGFzcyBjb25zdHJ1Y3RvciBoYW5kbGVzIGNvcHlpbmcgaW4gcHJvcGVydGllcyBhbmQgcmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIC0gYSBoYXNoIG9mIHByb3BlcnRpZXMgYW5kIGV2ZW50IGhhbmRsZXJzXG4gICAqIEByZXR1cm4ge2xheWVyLlJvb3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2xheWVyRXZlbnRTdWJzY3JpcHRpb25zID0gW107XG4gICAgdGhpcy5fZGVsYXllZFRyaWdnZXJzID0gW107XG4gICAgdGhpcy5fbGFzdERlbGF5ZWRUcmlnZ2VyID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAgIC8vIEdlbmVyYXRlIGFuIGludGVybmFsSWRcbiAgICBjb25zdCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmICghdW5pcXVlSWRzW25hbWVdKSB1bmlxdWVJZHNbbmFtZV0gPSAwO1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IG5hbWUgKyB1bmlxdWVJZHNbbmFtZV0rKztcblxuICAgIC8vIEV2ZXJ5IGNvbXBvbmVudCBsaXN0ZW5zIHRvIHRoZSBTeXN0ZW1CdXMgZm9yIHBvc3RNZXNzYWdlICh0cmlnZ2VyQXN5bmMpIGV2ZW50c1xuICAgIFN5c3RlbUJ1cy5vbih0aGlzLmludGVybmFsSWQgKyAnLWRlbGF5ZWQtZXZlbnQnLCB0aGlzLl9wcm9jZXNzRGVsYXllZFRyaWdnZXJzLCB0aGlzKTtcblxuICAgIC8vIEdlbmVyYXRlIGEgdGVtcG9yYXJ5IGlkIGlmIHRoZXJlIGlzbid0IGFuIGlkXG4gICAgaWYgKCF0aGlzLmlkICYmICFvcHRpb25zLmlkICYmIHRoaXMuY29uc3RydWN0b3IucHJlZml4VVVJRCkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMuY29uc3RydWN0b3IucHJlZml4VVVJRCArIFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuICAgIH1cblxuICAgIC8vIENvcHkgaW4gYWxsIHByb3BlcnRpZXM7IHNldHVwIGFsbCBldmVudCBoYW5kbGVyc1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3N1cHBvcnRlZEV2ZW50cy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMub24oa2V5LCBvcHRpb25zW2tleV0pO1xuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdGhpcyAmJiB0eXBlb2YgdGhpc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIENsZWFucyB1cCBhbGwgZXZlbnRzIC8gc3Vic2NyaXB0aW9uc1xuICAgKiBhbmQgbWFya3MgdGhlIG9iamVjdCBhcyBpc0Rlc3Ryb3llZC5cbiAgICpcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmFscmVhZHlEZXN0cm95ZWQpO1xuXG4gICAgLy8gSWYgYW55b25lIGlzIGxpc3RlbmluZywgbm90aWZ5IHRoZW1cbiAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcblxuICAgIC8vIENsZWFudXAgcG9pbnRlcnMgdG8gU3lzdGVtQnVzLiBGYWlsdXJlIHRvIGNhbGwgZGVzdHJveVxuICAgIC8vIHdpbGwgaGF2ZSB2ZXJ5IHNlcmlvdXMgY29uc2VxdWVuY2VzLi4uXG4gICAgU3lzdGVtQnVzLm9mZih0aGlzLmludGVybmFsSWQgKyAnLWRlbGF5ZWQtZXZlbnQnLCBudWxsLCB0aGlzKTtcblxuICAgIC8vIFJlbW92ZSBhbGwgZXZlbnRzLCBhbmQgYWxsIHBvaW50ZXJzIHBhc3NlZCB0byB0aGlzIG9iamVjdCBieSBvdGhlciBvYmplY3RzXG4gICAgdGhpcy5vZmYoKTtcblxuICAgIC8vIEZpbmQgYWxsIG9mIHRoZSBvYmplY3RzIHRoYXQgdGhpcyBvYmplY3QgaGFzIHBhc3NlZCBpdHNlbGYgdG8gaW4gdGhlIGZvcm1cbiAgICAvLyBvZiBldmVudCBoYW5kbGVycyBhbmQgcmVtb3ZlIGFsbCByZWZlcmVuY2VzIHRvIGl0c2VsZi5cbiAgICB0aGlzLl9sYXllckV2ZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5vZmYobnVsbCwgbnVsbCwgdGhpcykpO1xuXG4gICAgdGhpcy5fbGF5ZXJFdmVudFN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgIHRoaXMuX2RlbGF5ZWRUcmlnZ2VycyA9IG51bGw7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICBzdGF0aWMgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLmluZGV4T2YodGhpcy5wcmVmaXhVVUlEKSA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNsYXNzIGluc3RhbmNlIHRvIFBsYWluIEphdmFzY3JpcHQgT2JqZWN0LlxuICAgKlxuICAgKiBTdHJpcHMgb3V0IGFsbCBwcml2YXRlIG1lbWJlcnMsIGFuZCBpbnN1cmVzIG5vIGRhdGFzdHJ1Y3R1cmUgbG9vcHMuXG4gICAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnRpbmcgYWxsIHN1Ym9iamVjdHMgdXNpbmcgY2FsbHMgdG8gdG9PYmplY3QuXG4gICAqXG4gICAqICAgICAgY29uc29sZS5kaXIobXlvYmoudG9PYmplY3QoKSk7XG4gICAqXG4gICAqIE5vdGU6IFdoaWxlIGl0IHdvdWxkIGJlIHRlbXB0aW5nIHRvIGhhdmUgbm9DaGlsZHJlbiBkZWZhdWx0IHRvIHRydWUsXG4gICAqIHRoaXMgd291bGQgcmVzdWx0IGluIE1lc3NhZ2UudG9PYmplY3QoKSBub3Qgb3V0cHV0aW5nIGl0cyBNZXNzYWdlUGFydHMuXG4gICAqXG4gICAqIFByaXZhdGUgZGF0YSAoXyBwcmVmaXhlZCBwcm9wZXJ0aWVzKSB3aWxsIG5vdCBiZSBvdXRwdXQuXG4gICAqXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW25vQ2hpbGRyZW49ZmFsc2VdIERvbid0IG91dHB1dCBzdWItY29tcG9uZW50c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChub0NoaWxkcmVuID0gZmFsc2UpIHtcbiAgICB0aGlzLl9faW5Ub09iamVjdCA9IHRydWU7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGZvcm1hbGx5IGRlZmluZWQgcHJvcGVydGllc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICBsZXQgYUtleTtcbiAgICAgIGZvciAoYUtleSBpbiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSkgaWYgKCEoYUtleSBpbiBSb290LnByb3RvdHlwZSkpIGtleXMucHVzaChhS2V5KTtcblxuICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXNba2V5XTtcblxuICAgICAgICAvLyBJZ25vcmUgcHJpdmF0ZS9wcm90ZWN0ZWQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignXycpID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFycmF5cy4uLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIG9ialtrZXldID0gW107XG4gICAgICAgICAgdi5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJvb3QpIHtcbiAgICAgICAgICAgICAgaWYgKG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uX19pblRvT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaChpdGVtLnRvT2JqZWN0KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpba2V5XS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgc3ViY29tcG9uZW50c1xuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgUm9vdCkge1xuICAgICAgICAgIGlmICghdi5fX2luVG9PYmplY3QgJiYgIW5vQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdi50b09iamVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGRhdGVzIChjcmVhdGVzIGEgY29weSB0byBzZXBhcmF0ZSBpdCBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0KVxuICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIG9ialtrZXldID0gbmV3IERhdGUodik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBzaW1wbGUgcHJvcGVydGllc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vLW9wXG4gICAgfVxuICAgIHRoaXMuX19pblRvT2JqZWN0ID0gZmFsc2U7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgYSB3YXJuaW5nIGZvciBhdHRlbXB0cyB0byBzdWJzY3JpYmUgdG8gdW5zdXBwb3J0ZWQgZXZlbnRzLlxuICAgKlxuICAgKiBAbWV0aG9kIF93YXJuRm9yRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93YXJuRm9yRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgaWYgKCFVdGlscy5pbmNsdWRlcyh0aGlzLmNvbnN0cnVjdG9yLl9zdXBwb3J0ZWRFdmVudHMsIGV2ZW50TmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgJyArIGV2ZW50TmFtZSArICcgbm90IGRlZmluZWQgZm9yICcgKyB0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGZvciBwcm9jZXNzaW5nIGFuIGV2ZW50IHN1YnNjcmlwdGlvbiBjYWxsLlxuICAgKlxuICAgKiBJZiBjb250ZXh0IGlzIGEgUm9vdCBjbGFzcywgYWRkIHRoaXMgb2JqZWN0IHRvIHRoZSBjb250ZXh0J3Mgc3Vic2NyaXB0aW9ucy5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJlcGFyZU9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJlcGFyZU9uKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBSb290KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pc0Rlc3Ryb3llZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0Ll9sYXllckV2ZW50U3Vic2NyaXB0aW9ucykge1xuICAgICAgICBjb250ZXh0Ll9sYXllckV2ZW50U3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUgIT09ICdhbGwnKSB7XG4gICAgICBpZiAoZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgICAgbmFtZXMuZm9yRWFjaChuID0+IHRoaXMuX3dhcm5Gb3JFdmVudChuKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93YXJuRm9yRXZlbnQobmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMobmFtZSkuZm9yRWFjaChrZXlOYW1lID0+IHRoaXMuX3dhcm5Gb3JFdmVudChrZXlOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBldmVudHMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGV4dCBwYXJhbWV0ZXIgc2VydmVzIGRvdWJsZSBpbXBvcnRhbmNlIGhlcmU6XG4gICAqXG4gICAqIDEuIEl0IGRldGVybWluZXMgdGhlIGNvbnRleHQgaW4gd2hpY2ggdG8gZXhlY3V0ZSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiAyLiBDcmVhdGUgYSBiYWNrbGluayBzbyB0aGF0IGlmIGVpdGhlciBzdWJzY3JpYmVyIG9yIHN1YnNjcmliZWUgaXMgZGVzdHJveWVkLFxuICAgKiAgICBhbGwgcG9pbnRlcnMgYmV0d2VlbiB0aGVtIGNhbiBiZSBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICpcbiAgICogYGBgXG4gICAqIG9iai5vbignc29tZUV2ZW50TmFtZSBzb21lT3RoZXJFdmVudE5hbWUnLCBteWNhbGxiYWNrLCBteWNvbnRleHQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogYGBgXG4gICAqIG9iai5vbih7XG4gICAqICAgIGV2ZW50TmFtZTE6IGNhbGxiYWNrMSxcbiAgICogICAgZXZlbnROYW1lMjogY2FsbGJhY2syXG4gICAqIH0sIG15Y29udGV4dCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50fSBoYW5kbGVyLmV2ZW50IC0gRXZlbnQgb2JqZWN0IGRlbGl2ZXJlZCB0byB0aGUgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHQgLSBUaGlzIHBvaW50ZXIgQU5EIGxpbmsgdG8gaGVscCB3aXRoIGNsZWFudXBcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH0gdGhpc1xuICAgKi9cbiAgb24obmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuX3ByZXBhcmVPbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICBFdmVudHMub24uYXBwbHkodGhpcywgW25hbWUsIGhhbmRsZXIsIGNvbnRleHRdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGZpcnN0IG9jY3VyYW5jZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIG9uY2VcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH0gdGhpc1xuICAgKi9cbiAgb25jZShuYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcHJlcGFyZU9uKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgIEV2ZW50cy5vbmNlLmFwcGx5KHRoaXMsIFtuYW1lLCBoYW5kbGVyLCBjb250ZXh0XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBldmVudHMuXG4gICAqXG4gICAqIGBgYFxuICAgKiAvLyBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBldmVudDpcbiAgICogb2JqLm9mZignc29tZUV2ZW50TmFtZScpO1xuICAgKlxuICAgKiAvLyBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyB1c2luZyB0aGlzIGZ1bmN0aW9uIHBvaW50ZXIgYXMgY2FsbGJhY2tcbiAgICogb2JqLm9mZihudWxsLCBmLCBudWxsKTtcbiAgICpcbiAgICogLy8gUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgdGhhdCBgdGhpc2AgaGFzIHN1YnNjcmliZWQgdG87IHJlcXVpcmVzXG4gICAqIC8vIG9iai5vbiB0byBiZSBjYWxsZWQgd2l0aCBgdGhpc2AgYXMgaXRzIGBjb250ZXh0YCBwYXJhbWV0ZXIuXG4gICAqIG9iai5vZmYobnVsbCwgbnVsbCwgdGhpcyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIG9mZlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBldmVudDsgbnVsbCBmb3IgYWxsIGV2ZW50IG5hbWVzXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlcjsgbnVsbCBmb3IgYWxsIGZ1bmN0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHQgLSBUaGUgY29udGV4dCBmcm9tIHRoZSBgb24oKWAgY2FsbCB0byBzZWFyY2ggZm9yOyBudWxsIGZvciBhbGwgY29udGV4dHNcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH0gdGhpc1xuICAgKi9cblxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFuIGV2ZW50IGZvciBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBFdmVudHMgdHJpZ2dlcmVkIHRoaXMgd2F5IHdpbGwgYmUgYmxvY2tlZCBpZiBfZGlzYWJsZUV2ZW50cyA9IHRydWVcbiAgICpcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgICAgTmFtZSBvZiB0aGUgZXZlbnQgdGhhdCBvbmUgc2hvdWxkIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byByZWNlaXZlIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gYXJnICAgICAgICAgICBWYWx1ZXMgdGhhdCB3aWxsIGJlIHBsYWNlZCB3aXRoaW4gYSBsYXllci5MYXllckV2ZW50XG4gICAqIEByZXR1cm4ge2xheWVyLlJvb3R9IHRoaXNcbiAgICovXG4gIHRyaWdnZXIoLi4uYXJncykge1xuICAgIGlmICh0aGlzLl9kaXNhYmxlRXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gdGhpcy5fdHJpZ2dlciguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiBldmVudC5cbiAgICpcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgICAgTmFtZSBvZiB0aGUgZXZlbnQgdGhhdCBvbmUgc2hvdWxkIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byByZWNlaXZlIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gYXJnICAgICAgICAgICBWYWx1ZXMgdGhhdCB3aWxsIGJlIHBsYWNlZCB3aXRoaW4gYSBsYXllci5MYXllckV2ZW50XG4gICAqL1xuICBfdHJpZ2dlciguLi5hcmdzKSB7XG4gICAgaWYgKCFVdGlscy5pbmNsdWRlcyh0aGlzLmNvbnN0cnVjdG9yLl9zdXBwb3J0ZWRFdmVudHMsIGFyZ3NbMF0pKSB7XG4gICAgICBpZiAoIVV0aWxzLmluY2x1ZGVzKHRoaXMuY29uc3RydWN0b3IuX2lnbm9yZWRFdmVudHMsIGFyZ3NbMF0pKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcih0aGlzLnRvU3RyaW5nKCkgKyAnIGlnbm9yZWQgJyArIGFyZ3NbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXB1dGVkQXJncyA9IHRoaXMuX2dldFRyaWdnZXJBcmdzKC4uLmFyZ3MpO1xuXG4gICAgRXZlbnRzLnRyaWdnZXIuYXBwbHkodGhpcywgY29tcHV0ZWRBcmdzKTtcblxuICAgIGNvbnN0IHBhcmVudFByb3AgPSB0aGlzLmNvbnN0cnVjdG9yLmJ1YmJsZUV2ZW50UGFyZW50O1xuICAgIGlmIChwYXJlbnRQcm9wICYmIGFyZ3NbMF0gIT09ICdkZXN0cm95Jykge1xuICAgICAgbGV0IHBhcmVudFZhbHVlID0gdGhpc1twYXJlbnRQcm9wXTtcbiAgICAgIHBhcmVudFZhbHVlID0gKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgPyBwYXJlbnRWYWx1ZS5hcHBseSh0aGlzKSA6IHBhcmVudFZhbHVlO1xuICAgICAgaWYgKHBhcmVudFZhbHVlKSBwYXJlbnRWYWx1ZS50cmlnZ2VyKC4uLmNvbXB1dGVkQXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGxheWVyLkxheWVyRXZlbnQgZnJvbSBhIHRyaWdnZXIgY2FsbCdzIGFyZ3VtZW50cy5cbiAgICpcbiAgICogKiBJZiBwYXJhbWV0ZXIgaXMgYWxyZWFkeSBhIGxheWVyLkxheWVyRXZlbnQsIHdlJ3JlIGRvbmUuXG4gICAqICogSWYgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCwgYSBgdGFyZ2V0YCBwcm9wZXJ0eSBpcyBhZGRlZCB0byB0aGF0IG9iamVjdCBhbmQgaXRzIGRlbGl2ZXJlZCB0byBhbGwgc3Vic2NyaWJlcnNcbiAgICogKiBJZiB0aGUgcGFyYW1ldGVyIGlzIG5vbi1vYmplY3QgdmFsdWUsIGl0IGlzIGFkZGVkIHRvIGFuIG9iamVjdCB3aXRoIGEgYHRhcmdldGAgcHJvcGVydHksIGFuZCB0aGUgdmFsdWUgaXMgcHV0IGluXG4gICAqICAgdGhlIGBkYXRhYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0VHJpZ2dlckFyZ3NcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TWl4ZWRbXX0gLSBGaXJzdCBlbGVtZW50IG9mIGFycmF5IGlzIGV2ZW50TmFtZSwgc2Vjb25kIGVsZW1lbnQgaXMgbGF5ZXIuTGF5ZXJFdmVudC5cbiAgICovXG4gIF9nZXRUcmlnZ2VyQXJncyguLi5hcmdzKSB7XG4gICAgY29uc3QgY29tcHV0ZWRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cbiAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgY29uc3QgbmV3QXJnID0geyB0YXJnZXQ6IHRoaXMgfTtcblxuICAgICAgaWYgKGNvbXB1dGVkQXJnc1sxXSBpbnN0YW5jZW9mIExheWVyRXZlbnQpIHtcbiAgICAgICAgLy8gQSBMYXllckV2ZW50IHdpbGwgYmUgYW4gYXJndW1lbnQgd2hlbiBidWJibGluZyBldmVudHMgdXA7IHRoZXNlIGFyZ3MgY2FuIGJlIHVzZWQgYXMtaXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcHV0ZWRBcmdzWzFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGNvbXB1dGVkQXJnc1sxXSkuZm9yRWFjaChuYW1lID0+IChuZXdBcmdbbmFtZV0gPSBjb21wdXRlZEFyZ3NbMV1bbmFtZV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdBcmcuZGF0YSA9IGNvbXB1dGVkQXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlZEFyZ3NbMV0gPSBuZXcgTGF5ZXJFdmVudChuZXdBcmcsIGNvbXB1dGVkQXJnc1swXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXB1dGVkQXJnc1sxXSA9IG5ldyBMYXllckV2ZW50KHsgdGFyZ2V0OiB0aGlzIH0sIGNvbXB1dGVkQXJnc1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGVkQXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIF90cmlnZ2VyKCkgbWV0aG9kLCBidXQgZGVsYXlzIGJyaWVmbHkgYmVmb3JlIGZpcmluZy5cbiAgICpcbiAgICogV2hlbiB3b3VsZCB5b3Ugd2FudCB0byBkZWxheSBhbiBldmVudD9cbiAgICpcbiAgICogMS4gVGhlcmUgaXMgYW4gZXZlbnQgcm9sbHVwIHRoYXQgbWF5IGJlIG5lZWRlZCBmb3IgdGhlIGV2ZW50O1xuICAgKiAgICB0aGlzIHJlcXVpcmVzIHRoZSBmcmFtZXdvcmsgdG8gYmUgYWJsZSB0byBzZWUgQUxMIGV2ZW50cyB0aGF0IGhhdmUgYmVlblxuICAgKiAgICBnZW5lcmF0ZWQsIHJvbGwgdGhlbSB1cCwgYW5kIFRIRU4gZmlyZSB0aGVtLlxuICAgKiAyLiBUaGUgZXZlbnQgaXMgaW50ZW5kZWQgZm9yIFVJIHJlbmRlcmluZy4uLiB3aGljaCBzaG91bGQgbm90IGhvbGQgdXAgdGhlIHJlc3Qgb2ZcbiAgICogICAgdGhpcyBmcmFtZXdvcmsncyBleGVjdXRpb24uXG4gICAqXG4gICAqIFdoZW4gTk9UIHRvIGRlbGF5IGFuIGV2ZW50P1xuICAgKlxuICAgKiAxLiBMaWZlY3ljbGUgZXZlbnRzIGZyZXF1ZW50bHkgcmVxdWlyZSByZXNwb25zZSBhdCB0aGUgdGltZSB0aGUgZXZlbnQgaGFzIGZpcmVkXG4gICAqXG4gICAqIEBtZXRob2QgX3RyaWdnZXJBc3luY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lICAgIE5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgb25lIHNob3VsZCBzdWJzY3JpYmUgdG8gaW4gb3JkZXIgdG8gcmVjZWl2ZSB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFyZyAgICAgICAgICAgVmFsdWVzIHRoYXQgd2lsbCBiZSBwbGFjZWQgd2l0aGluIGEgbGF5ZXIuTGF5ZXJFdmVudFxuICAgKiBAcmV0dXJuIHtsYXllci5Sb290fSB0aGlzXG4gICAqL1xuICBfdHJpZ2dlckFzeW5jKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb21wdXRlZEFyZ3MgPSB0aGlzLl9nZXRUcmlnZ2VyQXJncyguLi5hcmdzKTtcbiAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMucHVzaChjb21wdXRlZEFyZ3MpO1xuXG4gICAgLy8gTk9URTogSXQgaXMgdW5jbGVhciBhdCB0aGlzIHRpbWUgaG93IGl0IGhhcHBlbnMsIGJ1dCBvbiB2ZXJ5IHJhcmUgb2NjYXNpb25zLCB3ZSBzZWUgcHJvY2Vzc0RlbGF5ZWRUcmlnZ2Vyc1xuICAgIC8vIGZhaWwgdG8gZ2V0IGNhbGxlZCB3aGVuIGxlbmd0aCA9IDEsIGFuZCBhZnRlciB0aGF0IGxlbmd0aCBqdXN0IGNvbnRpbnVvdXNseSBncm93cy4gIFNvIHdlIGFkZFxuICAgIC8vIHRoZSBfbGFzdERlbGF5ZWRUcmlnZ2VyIHRlc3QgdG8gaW5zdXJlIHRoYXQgaXQgd2lsbCBzdGlsbCBydW4uXG4gICAgY29uc3Qgc2hvdWxkU2NoZWR1bGVUcmlnZ2VyID0gdGhpcy5fZGVsYXllZFRyaWdnZXJzLmxlbmd0aCA9PT0gMSB8fFxuICAgICAgKHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5sZW5ndGggJiYgdGhpcy5fbGFzdERlbGF5ZWRUcmlnZ2VyICsgNTAwIDwgRGF0ZS5ub3coKSk7XG4gICAgaWYgKHNob3VsZFNjaGVkdWxlVHJpZ2dlcikge1xuICAgICAgdGhpcy5fbGFzdERlbGF5ZWRUcmlnZ2VyID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh0eXBlb2YgcG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGphc21pbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgIHR5cGU6ICdsYXllci1kZWxheWVkLWV2ZW50JyxcbiAgICAgICAgICBpbnRlcm5hbElkOiB0aGlzLmludGVybmFsSWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VEYXRhLCAnKicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlYWN0IE5hdGl2ZSByZXBvcnRlZGx5IGxhY2tzIGEgZG9jdW1lbnQsIGFuZCB0aHJvd3MgZXJyb3JzIG9uIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9wcm9jZXNzRGVsYXllZFRyaWdnZXJzKCksIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyBhIHNldCBvZiBldmVudHMgaW50byBhIHNpbmdsZSBldmVudC5cbiAgICpcbiAgICogR2l2ZW4gYW4gZXZlbnQgc3RydWN0dXJlIG9mXG4gICAqIGBgYFxuICAgKiAgICAgIHtcbiAgICogICAgICAgICAgY3VzdG9tTmFtZTogW3ZhbHVlMV1cbiAgICogICAgICB9XG4gICAqICAgICAge1xuICAgKiAgICAgICAgICBjdXN0b21OYW1lOiBbdmFsdWUyXVxuICAgKiAgICAgIH1cbiAgICogICAgICB7XG4gICAqICAgICAgICAgIGN1c3RvbU5hbWU6IFt2YWx1ZTNdXG4gICAqICAgICAgfVxuICAgKiBgYGBcbiAgICpcbiAgICogTWVyZ2UgdGhlbSBpbnRvXG4gICAqXG4gICAqIGBgYFxuICAgKiAgICAgIHtcbiAgICogICAgICAgICAgY3VzdG9tTmFtZTogW3ZhbHVlMSwgdmFsdWUyLCB2YWx1ZTNdXG4gICAqICAgICAgfVxuICAgKiBgYGBcbiAgICpcbiAgICogQG1ldGhvZCBfZm9sZEV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50W119IGV2ZW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgICBOYW1lIG9mIHRoZSBwcm9wZXJ0eSAoaS5lLiAnY3VzdG9tTmFtZScpXG4gICAqIEBwYXJhbSAge2xheWVyLlJvb3R9ICAgIG5ld1RhcmdldCBWYWx1ZSBvZiB0aGUgdGFyZ2V0IGZvciB0aGUgZm9sZGVkIHJlc3VsdGluZyBldmVudFxuICAgKi9cbiAgX2ZvbGRFdmVudHMoZXZlbnRzLCBuYW1lLCBuZXdUYXJnZXQpIHtcbiAgICBjb25zdCBmaXJzdEV2dCA9IGV2ZW50cy5sZW5ndGggPyBldmVudHNbMF1bMV0gOiBudWxsO1xuICAgIGNvbnN0IGZpcnN0RXZ0UHJvcCA9IGZpcnN0RXZ0ID8gZmlyc3RFdnRbbmFtZV0gOiBudWxsO1xuICAgIGV2ZW50cy5mb3JFYWNoKChldnQsIGkpID0+IHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBmaXJzdEV2dFByb3AucHVzaChldnRbMV1bbmFtZV1bMF0pO1xuICAgICAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuc3BsaWNlKHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5pbmRleE9mKGV2dCksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChldmVudHMubGVuZ3RoICYmIG5ld1RhcmdldCkgZXZlbnRzWzBdWzFdLnRhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2xkIGEgc2V0IG9mIENoYW5nZSBldmVudHMgaW50byBhIHNpbmdsZSBDaGFuZ2UgZXZlbnQuXG4gICAqXG4gICAqIEdpdmVuIGEgc2V0IGNoYW5nZSBldmVudHMgb24gdGhpcyBjb21wb25lbnQsXG4gICAqIGZvbGQgYWxsIGNoYW5nZSBldmVudHMgaW50byBhIHNpbmdsZSBldmVudCB2aWFcbiAgICogdGhlIGxheWVyLkxheWVyRXZlbnQncyBjaGFuZ2VzIGFycmF5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9mb2xkQ2hhbmdlRXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9sZENoYW5nZUV2ZW50cygpIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuZmlsdGVyKGV2dCA9PiBldnRbMV0uaXNDaGFuZ2UpO1xuICAgIGV2ZW50cy5mb3JFYWNoKChldnQsIGkpID0+IHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBldmVudHNbMF1bMV0uX21lcmdlQ2hhbmdlcyhldnRbMV0pO1xuICAgICAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuc3BsaWNlKHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5pbmRleE9mKGV2dCksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYWxsIGRlbGF5ZWQgZXZlbnRzIGZvciB0aGlzIGNvbXBvZW5udC5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc0RlbGF5ZWRUcmlnZ2Vyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NEZWxheWVkVHJpZ2dlcnMoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICB0aGlzLl9mb2xkQ2hhbmdlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoLi4uZXZ0KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMgPSBbXTtcbiAgfVxuXG5cbiAgX3J1bk1peGlucyhtaXhpbk5hbWUsIGFyZ0FycmF5KSB7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5taXhpbnMuZm9yRWFjaCgobWl4aW4pID0+IHtcbiAgICAgIGlmIChtaXhpbi5saWZlY3ljbGVbbWl4aW5OYW1lXSkgbWl4aW4ubGlmZWN5Y2xlW21peGluTmFtZV0uYXBwbHkodGhpcywgYXJnQXJyYXkpO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2xhc3MgdGhhdCBpcyBuaWNlciB0aGFuIGBbT2JqZWN0XWAuXG4gICAqXG4gICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxJZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShuZXdDbGFzcywgcHJvcGVydHlOYW1lKSB7XG4gIGNvbnN0IHBLZXkgPSAnX18nICsgcHJvcGVydHlOYW1lO1xuICBjb25zdCBjYW1lbCA9IHByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMSk7XG4gIGNvbnN0IGhhc0RlZmluaXRpb25zID0gbmV3Q2xhc3MucHJvdG90eXBlWydfX2FkanVzdCcgKyBjYW1lbF0gfHwgbmV3Q2xhc3MucHJvdG90eXBlWydfX3VwZGF0ZScgKyBjYW1lbF0gfHxcbiAgICBuZXdDbGFzcy5wcm90b3R5cGVbJ19fZ2V0JyArIGNhbWVsXTtcbiAgaWYgKGhhc0RlZmluaXRpb25zKSB7XG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVcbiAgICBuZXdDbGFzcy5wcm90b3R5cGVbcEtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1snX19nZXQnICsgY2FtZWxdID8gdGhpc1snX19nZXQnICsgY2FtZWxdKHBLZXkpIDogdGhpc1twS2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpblZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSB0aGlzW3BLZXldO1xuICAgICAgICBpZiAoaW5WYWx1ZSAhPT0gaW5pdGlhbCkge1xuICAgICAgICAgIGlmICh0aGlzWydfX2FkanVzdCcgKyBjYW1lbF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNbJ19fYWRqdXN0JyArIGNhbWVsXShpblZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgaW5WYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1twS2V5XSA9IGluVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluVmFsdWUgIT09IGluaXRpYWwpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXppbmcgJiYgdGhpc1snX191cGRhdGUnICsgY2FtZWxdKSB7XG4gICAgICAgICAgICB0aGlzWydfX3VwZGF0ZScgKyBjYW1lbF0oaW5WYWx1ZSwgaW5pdGlhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDbGFzcyhuZXdDbGFzcywgY2xhc3NOYW1lKSB7XG4gIC8vIE1ha2Ugc3VyZSBvdXIgbmV3IGNsYXNzIGhhcyBhIG5hbWUgcHJvcGVydHlcbiAgaWYgKCFuZXdDbGFzcy5uYW1lKSBuZXdDbGFzcy5uYW1lID0gY2xhc3NOYW1lO1xuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgbmV3IGNsYXNzIGhhcyBhIF9zdXBwb3J0ZWRFdmVudHMsIF9pZ25vcmVkRXZlbnRzLCBfaW5PYmplY3RJZ25vcmUgYW5kIEVWRU5UUyBwcm9wZXJ0aWVzXG4gIGlmICghbmV3Q2xhc3MuX3N1cHBvcnRlZEV2ZW50cykgbmV3Q2xhc3MuX3N1cHBvcnRlZEV2ZW50cyA9IFJvb3QuX3N1cHBvcnRlZEV2ZW50cztcbiAgaWYgKCFuZXdDbGFzcy5faWdub3JlZEV2ZW50cykgbmV3Q2xhc3MuX2lnbm9yZWRFdmVudHMgPSBSb290Ll9pZ25vcmVkRXZlbnRzO1xuXG4gIGlmIChuZXdDbGFzcy5taXhpbnMpIHtcbiAgICBuZXdDbGFzcy5taXhpbnMuZm9yRWFjaCgobWl4aW4pID0+IHtcbiAgICAgIGlmIChtaXhpbi5ldmVudHMpIG5ld0NsYXNzLl9zdXBwb3J0ZWRFdmVudHMgPSBuZXdDbGFzcy5fc3VwcG9ydGVkRXZlbnRzLmNvbmNhdChtaXhpbi5ldmVudHMpO1xuICAgICAgaWYgKG1peGluLnByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobWl4aW4ucHJvcGVydGllcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgbmV3Q2xhc3MucHJvdG90eXBlW2tleV0gPSBtaXhpbi5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1peGluLm1ldGhvZHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobWl4aW4ubWV0aG9kcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgbmV3Q2xhc3MucHJvdG90eXBlW2tleV0gPSBtaXhpbi5tZXRob2RzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSBsaXN0IG9mIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3M7IHdlIGRvbid0IGluY2x1ZGUgYW55XG4gIC8vIHByb3BlcnRpZXMgZnJvbSBsYXllci5Sb290XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuZXdDbGFzcy5wcm90b3R5cGUpLmZpbHRlcihrZXkgPT5cbiAgICBuZXdDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICFSb290LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgdHlwZW9mIG5ld0NsYXNzLnByb3RvdHlwZVtrZXldICE9PSAnZnVuY3Rpb24nKTtcblxuICAvLyBEZWZpbmUgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbnkgcHJvcGVydHkgdGhhdCBoYXMgX19hZGp1c3Qgb3IgX191cGRhdGUgbWV0aG9kcyBkZWZpbmVkXG4gIGtleXMuZm9yRWFjaChuYW1lID0+IGRlZmluZVByb3BlcnR5KG5ld0NsYXNzLCBuYW1lKSk7XG59XG5cbi8qKlxuICogU2V0IHRvIHRydWUgb25jZSBkZXN0cm95KCkgaGFzIGJlZW4gY2FsbGVkLlxuICpcbiAqIEEgZGVzdHJveWVkIG9iamVjdCB3aWxsIGxpa2VseSBjYXVzZSBlcnJvcnMgaW4gYW55IGF0dGVtcHRcbiAqIHRvIGNhbGwgbWV0aG9kcyBvbiBpdCwgYW5kIHdpbGwgbm8gbG9uZ2VyIHRyaWdnZXIgZXZlbnRzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHJlYWRvbmx5XG4gKi9cblJvb3QucHJvdG90eXBlLmlzRGVzdHJveWVkID0gZmFsc2U7XG5cbi8qKlxuICogRXZlcnkgaW5zdGFuY2UgaGFzIGl0cyBvd24gaW50ZXJuYWwgSUQuXG4gKlxuICogVGhpcyBJRCBpcyBkaXN0aW5jdCBmcm9tIGFueSBJRHMgYXNzaWduZWQgYnkgdGhlIHNlcnZlci5cbiAqIFRoZSBpbnRlcm5hbCBJRCBpcyBnYXVyZW50ZWVkIG5vdCB0byBjaGFuZ2Ugd2l0aGluIHRoZSBsaWZldGltZSBvZiB0aGUgT2JqZWN0L3Nlc3Npb247XG4gKiBpdCBpcyBwb3NzaWJsZSwgb24gY3JlYXRpbmcgYSBuZXcgb2JqZWN0LCBmb3IgaXRzIGBpZGAgcHJvcGVydHkgdG8gY2hhbmdlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqL1xuUm9vdC5wcm90b3R5cGUuaW50ZXJuYWxJZCA9ICcnO1xuXG4vKipcbiAqIFRydWUgd2hpbGUgd2UgYXJlIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5Sb290LnByb3RvdHlwZS5pc0luaXRpYWxpemluZyA9IHRydWU7XG5cbi8qKlxuICogT2JqZWN0cyB0aGF0IHRoaXMgb2JqZWN0IGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzIGZyb20uXG4gKlxuICogQHR5cGUge2xheWVyLlJvb3RbXX1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9sYXllckV2ZW50U3Vic2NyaXB0aW9ucyA9IG51bGw7XG5cbi8qKlxuICogRGlzYWJsZSBhbGwgZXZlbnRzIHRyaWdnZXJlZCBvbiB0aGlzIG9iamVjdC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2Rpc2FibGVFdmVudHMgPSBmYWxzZTtcblxuXG5Sb290Ll9zdXBwb3J0ZWRFdmVudHMgPSBbJ2Rlc3Ryb3knLCAnYWxsJ107XG5Sb290Ll9pZ25vcmVkRXZlbnRzID0gW107XG5tb2R1bGUuZXhwb3J0cyA9IFJvb3Q7XG5tb2R1bGUuZXhwb3J0cy5pbml0Q2xhc3MgPSBpbml0Q2xhc3M7XG4iXX0=
