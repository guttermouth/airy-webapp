'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Container is a parent class representing a container that manages a set of Messages.
 *
 * @class  layer.Container
 * @abstract
 * @extends layer.Syncable
 * @author  Michael Kantor
 */
var Syncable = require('./syncable');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var Constants = require('../const');
var Root = require('../root');

var Container = function (_Syncable) {
  _inherits(Container, _Syncable);

  /**
   * Create a new conversation.
   *
   * The static `layer.Conversation.create()` method
   * will correctly lookup distinct Conversations and
   * return them; `new layer.Conversation()` will not.
   *
   * Developers should use `layer.Conversation.create()`.
   *
   * @method constructor
   * @protected
   * @param  {Object} options
   * @param {string[]/layer.Identity[]} options.participants - Array of Participant IDs or layer.Identity instances
   * @param {boolean} [options.distinct=true] - Is the conversation distinct
   * @param {Object} [options.metadata] - An object containing Conversation Metadata.
   * @return {layer.Conversation}
   */
  function Container() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Container);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) options.id = options.fromServer.id;

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.metadata) options.metadata = {};

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Container).call(this, options));

    if (!_this.clientId) throw new Error(LayerError.dictionary.clientMissing);
    _this.isInitializing = true;

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Conversation
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.metadata) _this.metadata = {};

    if (!_this.createdAt) {
      _this.createdAt = new Date();
    }
    _this.isInitializing = false;
    return _this;
  }

  _createClass(Container, [{
    key: 'send',
    value: function send(message) {
      var _this2 = this;

      if (this.isNew()) {
        this.createdAt = new Date();

        // Update the syncState
        this._setSyncing();

        this.getClient()._triggerAsync('state-change', {
          started: true,
          type: 'send_' + Util.typeFromID(this.id),
          telemetryId: 'send_' + Util.typeFromID(this.id) + '_time',
          id: this.id
        });
        this.getClient().sendSocketRequest({
          method: 'POST',
          body: {}, // see _getSendData
          sync: {
            depends: this.id,
            target: this.id
          }
        }, function (result) {
          return _this2._createResult(result);
        });
      }
      if (message) this._setupMessage(message);
      return this;
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} container - Server representation of the container
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(container) {
      var client = this.getClient();

      this._setSynced();

      var id = this.id;
      this.id = container.id;

      // IDs change if the server returns a matching Container
      if (id !== this.id) {
        client._updateContainerId(this, id);
        this._triggerAsync(this.constructor.eventPrefix + ':change', {
          oldValue: id,
          newValue: this.id,
          property: 'id'
        });
      }

      this.url = container.url;
      this.createdAt = new Date(container.created_at);
      this.metadata = container.metadata;
    }

    /**
     * Process result of send method.
     *
     * Note that we use _triggerAsync so that
     * events reporting changes to the layer.Conversation.id can
     * be applied before reporting on it being sent.
     *
     * Example: Query will now have the resolved Distinct IDs rather than the proposed ID
     * when this event is triggered.
     *
     * @method _createResult
     * @private
     * @param  {Object} result
     */

  }, {
    key: '_createResult',
    value: function _createResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      this.getClient()._triggerAsync('state-change', {
        ended: true,
        type: 'send_' + Util.typeFromID(this.id),
        telemetryId: 'send_' + Util.typeFromID(this.id) + '_time',
        id: this.id
      });
      if (this.isDestroyed) return;
      if (success) {
        this._createSuccess(data);
      } else if (data.id === 'conflict') {
        this._createResultConflict(data);
      } else {
        this.trigger(this.constructor.eventPrefix + ':sent-error', { error: data });
        this.destroy();
      }
    }

    /**
     * Process the successful result of a create call
     *
     * @method _createSuccess
     * @private
     * @param  {Object} data Server description of Conversation/Channel
     */

  }, {
    key: '_createSuccess',
    value: function _createSuccess(data) {
      var id = this.id;
      this._populateFromServer(data);
      this._triggerAsync(this.constructor.eventPrefix + ':sent', {
        result: id === this.id ? Container.CREATED : Container.FOUND
      });
    }

    /**
     * Updates specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.setMetadataProperties({
     *          'title': 'I am a title',
     *          'colors.background': 'red',
     *          'colors.text': {
     *              'fill': 'blue',
     *              'shadow': 'black'
     *           },
     *           'colors.title.fill': 'red'
     *      });
     *
     * Use setMetadataProperties to specify the path to a property, and a new value for that property.
     * Multiple properties can be changed this way.  Whatever value was there before is
     * replaced with the new value; so in the above example, whatever other keys may have
     * existed under `colors.text` have been replaced by the new object `{fill: 'blue', shadow: 'black'}`.
     *
     * Note also that only string and subobjects are accepted as values.
     *
     * Keys with '.' will update a field of an object (and create an object if it wasn't there):
     *
     * Initial metadata: {}
     *
     *      conversation.setMetadataProperties({
     *          'colors.background': 'red',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red'}}`
     *
     *      conversation.setMetadataProperties({
     *          'colors.foreground': 'black',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red', foreground: 'black'}}`
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method setMetadataProperties
     * @param  {Object} properties
     * @return {layer.Conversation} this
     *
     */

  }, {
    key: 'setMetadataProperties',
    value: function setMetadataProperties(props) {
      var _this3 = this;

      var layerPatchOperations = [];
      Object.keys(props).forEach(function (name) {
        var fullName = name;
        if (name) {
          if (name !== 'metadata' && name.indexOf('metadata.') !== 0) {
            fullName = 'metadata.' + name;
          }
          layerPatchOperations.push({
            operation: 'set',
            property: fullName,
            value: props[name]
          });
        }
      });

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success && !_this3.isDestroyed && result.data.id !== 'authentication_required') _this3._load();
      });

      return this;
    }

    /**
     * Deletes specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.deleteMetadataProperties(
     *          ['title', 'colors.background', 'colors.title.fill']
     *      );
     *
     * Use deleteMetadataProperties to specify paths to properties to be deleted.
     * Multiple properties can be deleted.
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method deleteMetadataProperties
     * @param  {string[]} properties
     * @return {layer.Conversation} this
     */

  }, {
    key: 'deleteMetadataProperties',
    value: function deleteMetadataProperties(props) {
      var _this4 = this;

      var layerPatchOperations = [];
      props.forEach(function (property) {
        if (property !== 'metadata' && property.indexOf('metadata.') !== 0) {
          property = 'metadata.' + property;
        }
        layerPatchOperations.push({
          operation: 'delete',
          property: property
        });
      }, this);

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success && result.data.id !== 'authentication_required') _this4._load();
      });

      return this;
    }

    /**
     * Delete the Conversation from the server (internal version).
     *
     * This version of Delete takes a Query String that is packaged up by
     * layer.Conversation.delete and layer.Conversation.leave.
     *
     * @method _delete
     * @private
     * @param {string} queryStr - Query string for the DELETE request
     */

  }, {
    key: '_delete',
    value: function _delete(queryStr) {
      var _this5 = this;

      var id = this.id;
      this._xhr({
        method: 'DELETE',
        url: '?' + queryStr
      }, function (result) {
        return _this5._deleteResult(result, id);
      });

      this._deleted();
      this.destroy();
    }
  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      if (data.mode === Constants.DELETION_MODE.MY_DEVICES && data.from_position) {
        this.getClient()._purgeMessagesByPosition(this.id, data.from_position);
      } else {
        _get(Object.getPrototypeOf(Container.prototype), '_handleWebsocketDelete', this).call(this);
      }
    }
  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this._register(this);
    }

    /**
     * Standard `on()` provided by layer.Root.
     *
     * Adds some special handling of 'conversations:loaded' so that calls such as
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          myrerender(c);
     *      });
     *      myrender(c); // render a placeholder for c until the details of c have loaded
     *
     * can fire their callback regardless of whether the client loads or has
     * already loaded the Conversation.
     *
     * @method on
     * @param  {string} eventName
     * @param  {Function} callback
     * @param  {Object} context
     * @return {layer.Conversation} this
     */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var evtName = this.constructor.eventPrefix + ':loaded';
      var hasLoadedEvt = name === evtName || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name[evtName];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === evtName ? callback : name[evtName];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Container.prototype), 'on', this).call(this, name, callback, context);

      return this;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Container.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Container.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the metadata property will call this method and fire a
     * change event.  Changes to the metadata object that don't replace the object
     * with a new object will require directly calling this method.
     *
     * @method __updateMetadata
     * @private
     * @param  {Object} newValue
     * @param  {Object} oldValue
     */

  }, {
    key: '__updateMetadata',
    value: function __updateMetadata(newValue, oldValue, paths) {
      if (this._inLayerParser) return;
      if (JSON.stringify(newValue) !== JSON.stringify(oldValue)) {
        this._triggerAsync(this.constructor.eventPrefix + ':change', {
          property: 'metadata',
          newValue: newValue,
          oldValue: oldValue,
          paths: paths
        });
      }
    }
  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      if (paths[0].indexOf('metadata') === 0) {
        this.__updateMetadata(newValue, oldValue, paths);
      }
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Conversation instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Container.prototype), 'toObject', this).call(this);
        this._toObject.metadata = Util.clone(this.metadata);
      }
      return this._toObject;
    }

    /**
     * Identifies whether a Conversation receiving the specified patch data should be loaded from the server.
     *
     * Any change to a Conversation indicates that the Conversation is active and of potential interest; go ahead and load that
     * Conversation in case the app has need of it.  In the future we may ignore changes to unread count.  Only relevant
     * when we get Websocket events for a Conversation that has not been loaded/cached on Client.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }], [{
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return true;
    }
  }]);

  return Container;
}(Syncable);

/**
 * Time that the conversation was created on the server.
 *
 * @type {Date}
 */


Container.prototype.createdAt = null;

/**
 * Metadata for the conversation.
 *
 * Metadata values can be plain objects and strings, but
 * no arrays, numbers, booleans or dates.
 * @type {Object}
 */
Container.prototype.metadata = null;

/**
 * The authenticated user is a current participant in this Conversation.
 *
 * Set to false if the authenticated user has been removed from this conversation.
 *
 * A removed user can see messages up to the time they were removed,
 * but can no longer interact with the conversation.
 *
 * A removed user can no longer see the participant list.
 *
 * Read and Delivery receipts will fail on any Message in such a Conversation.
 *
 * @type {Boolean}
 */
Container.prototype.isCurrentParticipant = true;

/**
 * Cache's a Distinct Event.
 *
 * On creating a Channel or Conversation that already exists,
 * when the send() method is called, we should trigger
 * specific events detailing the results.  Results
 * may be determined locally or on the server, but same Event may be needed.
 *
 * @type {layer.LayerEvent}
 * @private
 */
Container.prototype._sendDistinctEvent = null;

/**
 * Caches last result of toObject()
 * @type {Object}
 * @private
 */
Container.prototype._toObject = null;

/**
 * Property to look for when bubbling up events.
 * @type {String}
 * @static
 * @private
 */
Container.bubbleEventParent = 'getClient';

/**
 * The Conversation/Channel that was requested has been created.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.CREATED = 'Created';

/**
 * The Conversation/Channel that was requested has been found.
 *
 * This means that it did not need to be created.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.FOUND = 'Found';

/**
 * The Conversation/Channel that was requested has been found, but there was a mismatch in metadata.
 *
 * If the createConversation request contained metadata and it did not match the Distinct Conversation
 * that matched the requested participants, then this value is passed to notify your app that the Conversation
 * was returned but does not exactly match your request.
 *
 * Used in `conversations:sent` events.
 * @type {String}
 * @static
 */
Container.FOUND_WITHOUT_REQUESTED_METADATA = 'FoundMismatch';

Root.initClass.apply(Container, [Container, 'Container']);
Syncable.subclasses.push(Container);
module.exports = Container;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY29udGFpbmVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsSUFBTSxXQUFXLFFBQVEsWUFBUixDQUFqQjtBQUNBLElBQU0sYUFBYSxRQUFRLGdCQUFSLENBQW5CO0FBQ0EsSUFBTSxPQUFPLFFBQVEsaUJBQVIsQ0FBYjtBQUNBLElBQU0sWUFBWSxRQUFRLFVBQVIsQ0FBbEI7QUFDQSxJQUFNLE9BQU8sUUFBUSxTQUFSLENBQWI7O0lBRU0sUzs7O0FBRUo7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLHVCQUEwQjtBQUFBLFFBQWQsT0FBYyx5REFBSixFQUFJOztBQUFBOztBQUN4QjtBQUNBLFFBQUksUUFBUSxVQUFaLEVBQXdCLFFBQVEsRUFBUixHQUFhLFFBQVEsVUFBUixDQUFtQixFQUFoQzs7QUFFeEI7QUFDQSxRQUFJLFFBQVEsTUFBWixFQUFvQixRQUFRLFFBQVIsR0FBbUIsUUFBUSxNQUFSLENBQWUsS0FBbEM7QUFDcEIsUUFBSSxDQUFDLFFBQVEsUUFBYixFQUF1QixRQUFRLFFBQVIsR0FBbUIsRUFBbkI7O0FBTkMsNkZBUWxCLE9BUmtCOztBQVV4QixRQUFJLENBQUMsTUFBSyxRQUFWLEVBQW9CLE1BQU0sSUFBSSxLQUFKLENBQVUsV0FBVyxVQUFYLENBQXNCLGFBQWhDLENBQU47QUFDcEIsVUFBSyxjQUFMLEdBQXNCLElBQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUksV0FBVyxRQUFRLFVBQXZCLEVBQW1DO0FBQ2pDLFlBQUssbUJBQUwsQ0FBeUIsUUFBUSxVQUFqQztBQUNEOztBQUVELFFBQUksQ0FBQyxNQUFLLFFBQVYsRUFBb0IsTUFBSyxRQUFMLEdBQWdCLEVBQWhCOztBQUVwQixRQUFJLENBQUMsTUFBSyxTQUFWLEVBQXFCO0FBQ25CLFlBQUssU0FBTCxHQUFpQixJQUFJLElBQUosRUFBakI7QUFDRDtBQUNELFVBQUssY0FBTCxHQUFzQixLQUF0QjtBQXpCd0I7QUEwQnpCOzs7O3lCQUdJLE8sRUFBUztBQUFBOztBQUNaLFVBQUksS0FBSyxLQUFMLEVBQUosRUFBa0I7QUFDaEIsYUFBSyxTQUFMLEdBQWlCLElBQUksSUFBSixFQUFqQjs7QUFFQTtBQUNBLGFBQUssV0FBTDs7QUFFQSxhQUFLLFNBQUwsR0FBaUIsYUFBakIsQ0FBK0IsY0FBL0IsRUFBK0M7QUFDN0MsbUJBQVMsSUFEb0M7QUFFN0MsZ0JBQU0sVUFBVSxLQUFLLFVBQUwsQ0FBZ0IsS0FBSyxFQUFyQixDQUY2QjtBQUc3Qyx1QkFBYSxVQUFVLEtBQUssVUFBTCxDQUFnQixLQUFLLEVBQXJCLENBQVYsR0FBcUMsT0FITDtBQUk3QyxjQUFJLEtBQUs7QUFKb0MsU0FBL0M7QUFNQSxhQUFLLFNBQUwsR0FBaUIsaUJBQWpCLENBQW1DO0FBQ2pDLGtCQUFRLE1BRHlCO0FBRWpDLGdCQUFNLEVBRjJCLEVBRXZCO0FBQ1YsZ0JBQU07QUFDSixxQkFBUyxLQUFLLEVBRFY7QUFFSixvQkFBUSxLQUFLO0FBRlQ7QUFIMkIsU0FBbkMsRUFPRztBQUFBLGlCQUFVLE9BQUssYUFBTCxDQUFtQixNQUFuQixDQUFWO0FBQUEsU0FQSDtBQVFEO0FBQ0QsVUFBSSxPQUFKLEVBQWEsS0FBSyxhQUFMLENBQW1CLE9BQW5CO0FBQ2IsYUFBTyxJQUFQO0FBQ0Q7O0FBR0Q7Ozs7Ozs7Ozs7Ozt3Q0FTb0IsUyxFQUFXO0FBQzdCLFVBQU0sU0FBUyxLQUFLLFNBQUwsRUFBZjs7QUFFQSxXQUFLLFVBQUw7O0FBRUEsVUFBTSxLQUFLLEtBQUssRUFBaEI7QUFDQSxXQUFLLEVBQUwsR0FBVSxVQUFVLEVBQXBCOztBQUVBO0FBQ0EsVUFBSSxPQUFPLEtBQUssRUFBaEIsRUFBb0I7QUFDbEIsZUFBTyxrQkFBUCxDQUEwQixJQUExQixFQUFnQyxFQUFoQztBQUNBLGFBQUssYUFBTCxDQUFzQixLQUFLLFdBQUwsQ0FBaUIsV0FBdkMsY0FBNkQ7QUFDM0Qsb0JBQVUsRUFEaUQ7QUFFM0Qsb0JBQVUsS0FBSyxFQUY0QztBQUczRCxvQkFBVTtBQUhpRCxTQUE3RDtBQUtEOztBQUVELFdBQUssR0FBTCxHQUFXLFVBQVUsR0FBckI7QUFDQSxXQUFLLFNBQUwsR0FBaUIsSUFBSSxJQUFKLENBQVMsVUFBVSxVQUFuQixDQUFqQjtBQUNBLFdBQUssUUFBTCxHQUFnQixVQUFVLFFBQTFCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQWNpQztBQUFBLFVBQWpCLE9BQWlCLFFBQWpCLE9BQWlCO0FBQUEsVUFBUixJQUFRLFFBQVIsSUFBUTs7QUFDL0IsV0FBSyxTQUFMLEdBQWlCLGFBQWpCLENBQStCLGNBQS9CLEVBQStDO0FBQzdDLGVBQU8sSUFEc0M7QUFFN0MsY0FBTSxVQUFVLEtBQUssVUFBTCxDQUFnQixLQUFLLEVBQXJCLENBRjZCO0FBRzdDLHFCQUFhLFVBQVUsS0FBSyxVQUFMLENBQWdCLEtBQUssRUFBckIsQ0FBVixHQUFxQyxPQUhMO0FBSTdDLFlBQUksS0FBSztBQUpvQyxPQUEvQztBQU1BLFVBQUksS0FBSyxXQUFULEVBQXNCO0FBQ3RCLFVBQUksT0FBSixFQUFhO0FBQ1gsYUFBSyxjQUFMLENBQW9CLElBQXBCO0FBQ0QsT0FGRCxNQUVPLElBQUksS0FBSyxFQUFMLEtBQVksVUFBaEIsRUFBNEI7QUFDakMsYUFBSyxxQkFBTCxDQUEyQixJQUEzQjtBQUNELE9BRk0sTUFFQTtBQUNMLGFBQUssT0FBTCxDQUFhLEtBQUssV0FBTCxDQUFpQixXQUFqQixHQUErQixhQUE1QyxFQUEyRCxFQUFFLE9BQU8sSUFBVCxFQUEzRDtBQUNBLGFBQUssT0FBTDtBQUNEO0FBQ0Y7O0FBR0Q7Ozs7Ozs7Ozs7bUNBT2UsSSxFQUFNO0FBQ25CLFVBQU0sS0FBSyxLQUFLLEVBQWhCO0FBQ0EsV0FBSyxtQkFBTCxDQUF5QixJQUF6QjtBQUNBLFdBQUssYUFBTCxDQUFtQixLQUFLLFdBQUwsQ0FBaUIsV0FBakIsR0FBK0IsT0FBbEQsRUFBMkQ7QUFDekQsZ0JBQVEsT0FBTyxLQUFLLEVBQVosR0FBaUIsVUFBVSxPQUEzQixHQUFxQyxVQUFVO0FBREUsT0FBM0Q7QUFHRDs7QUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQW1Ec0IsSyxFQUFPO0FBQUE7O0FBQzNCLFVBQU0sdUJBQXVCLEVBQTdCO0FBQ0EsYUFBTyxJQUFQLENBQVksS0FBWixFQUFtQixPQUFuQixDQUEyQixVQUFDLElBQUQsRUFBVTtBQUNuQyxZQUFJLFdBQVcsSUFBZjtBQUNBLFlBQUksSUFBSixFQUFVO0FBQ1IsY0FBSSxTQUFTLFVBQVQsSUFBdUIsS0FBSyxPQUFMLENBQWEsV0FBYixNQUE4QixDQUF6RCxFQUE0RDtBQUMxRCx1QkFBVyxjQUFjLElBQXpCO0FBQ0Q7QUFDRCwrQkFBcUIsSUFBckIsQ0FBMEI7QUFDeEIsdUJBQVcsS0FEYTtBQUV4QixzQkFBVSxRQUZjO0FBR3hCLG1CQUFPLE1BQU0sSUFBTjtBQUhpQixXQUExQjtBQUtEO0FBQ0YsT0FaRDs7QUFjQSxXQUFLLGNBQUwsR0FBc0IsSUFBdEI7O0FBRUE7QUFDQTtBQUNBLFdBQUssVUFBTCxDQUFnQjtBQUNkLGdCQUFRLElBRE07QUFFZCxjQUFNLGNBRlE7QUFHZCxvQkFBWSxvQkFIRTtBQUlkLGdCQUFRLEtBQUssU0FBTDtBQUpNLE9BQWhCO0FBTUEsV0FBSyxjQUFMLEdBQXNCLEtBQXRCOztBQUVBLFdBQUssSUFBTCxDQUFVO0FBQ1IsYUFBSyxFQURHO0FBRVIsZ0JBQVEsT0FGQTtBQUdSLGNBQU0sS0FBSyxTQUFMLENBQWUsb0JBQWYsQ0FIRTtBQUlSLGlCQUFTO0FBQ1AsMEJBQWdCO0FBRFQ7QUFKRCxPQUFWLEVBT0csVUFBQyxNQUFELEVBQVk7QUFDYixZQUFJLENBQUMsT0FBTyxPQUFSLElBQW1CLENBQUMsT0FBSyxXQUF6QixJQUF3QyxPQUFPLElBQVAsQ0FBWSxFQUFaLEtBQW1CLHlCQUEvRCxFQUEwRixPQUFLLEtBQUw7QUFDM0YsT0FURDs7QUFXQSxhQUFPLElBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZDQXdCeUIsSyxFQUFPO0FBQUE7O0FBQzlCLFVBQU0sdUJBQXVCLEVBQTdCO0FBQ0EsWUFBTSxPQUFOLENBQWMsVUFBQyxRQUFELEVBQWM7QUFDMUIsWUFBSSxhQUFhLFVBQWIsSUFBMkIsU0FBUyxPQUFULENBQWlCLFdBQWpCLE1BQWtDLENBQWpFLEVBQW9FO0FBQ2xFLHFCQUFXLGNBQWMsUUFBekI7QUFDRDtBQUNELDZCQUFxQixJQUFyQixDQUEwQjtBQUN4QixxQkFBVyxRQURhO0FBRXhCO0FBRndCLFNBQTFCO0FBSUQsT0FSRCxFQVFHLElBUkg7O0FBVUEsV0FBSyxjQUFMLEdBQXNCLElBQXRCOztBQUVBO0FBQ0E7QUFDQSxXQUFLLFVBQUwsQ0FBZ0I7QUFDZCxnQkFBUSxJQURNO0FBRWQsY0FBTSxjQUZRO0FBR2Qsb0JBQVksb0JBSEU7QUFJZCxnQkFBUSxLQUFLLFNBQUw7QUFKTSxPQUFoQjtBQU1BLFdBQUssY0FBTCxHQUFzQixLQUF0Qjs7QUFFQSxXQUFLLElBQUwsQ0FBVTtBQUNSLGFBQUssRUFERztBQUVSLGdCQUFRLE9BRkE7QUFHUixjQUFNLEtBQUssU0FBTCxDQUFlLG9CQUFmLENBSEU7QUFJUixpQkFBUztBQUNQLDBCQUFnQjtBQURUO0FBSkQsT0FBVixFQU9HLFVBQUMsTUFBRCxFQUFZO0FBQ2IsWUFBSSxDQUFDLE9BQU8sT0FBUixJQUFtQixPQUFPLElBQVAsQ0FBWSxFQUFaLEtBQW1CLHlCQUExQyxFQUFxRSxPQUFLLEtBQUw7QUFDdEUsT0FURDs7QUFXQSxhQUFPLElBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7Ozs7Ozs0QkFVUSxRLEVBQVU7QUFBQTs7QUFDaEIsVUFBTSxLQUFLLEtBQUssRUFBaEI7QUFDQSxXQUFLLElBQUwsQ0FBVTtBQUNSLGdCQUFRLFFBREE7QUFFUixhQUFLLE1BQU07QUFGSCxPQUFWLEVBR0c7QUFBQSxlQUFVLE9BQUssYUFBTCxDQUFtQixNQUFuQixFQUEyQixFQUEzQixDQUFWO0FBQUEsT0FISDs7QUFLQSxXQUFLLFFBQUw7QUFDQSxXQUFLLE9BQUw7QUFDRDs7OzJDQUVzQixJLEVBQU07QUFDM0IsVUFBSSxLQUFLLElBQUwsS0FBYyxVQUFVLGFBQVYsQ0FBd0IsVUFBdEMsSUFBb0QsS0FBSyxhQUE3RCxFQUE0RTtBQUMxRSxhQUFLLFNBQUwsR0FBaUIsd0JBQWpCLENBQTBDLEtBQUssRUFBL0MsRUFBbUQsS0FBSyxhQUF4RDtBQUNELE9BRkQsTUFFTztBQUNMO0FBQ0Q7QUFDRjs7OzRCQUVPLEcsRUFBSztBQUNYLGFBQU8sS0FBSyxHQUFMLElBQVksT0FBTyxFQUFuQixDQUFQO0FBQ0Q7Ozs0QkFFTyxJLEVBQU07QUFDWixXQUFLLFNBQUwsQ0FBZSxJQUFmO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQW9CRyxJLEVBQU0sUSxFQUFVLE8sRUFBUztBQUMxQixVQUFNLFVBQWEsS0FBSyxXQUFMLENBQWlCLFdBQTlCLFlBQU47QUFDQSxVQUFNLGVBQWUsU0FBUyxPQUFULElBQXFCLFFBQVEsUUFBTyxJQUFQLHlDQUFPLElBQVAsT0FBZ0IsUUFBeEIsSUFBb0MsS0FBSyxPQUFMLENBQTlFOztBQUVBLFVBQUksZ0JBQWdCLENBQUMsS0FBSyxTQUExQixFQUFxQztBQUFBO0FBQ25DLGNBQU0sVUFBVSxTQUFTLE9BQVQsR0FBbUIsUUFBbkIsR0FBOEIsS0FBSyxPQUFMLENBQTlDO0FBQ0EsZUFBSyxLQUFMLENBQVc7QUFBQSxtQkFBTSxRQUFRLEtBQVIsQ0FBYyxPQUFkLENBQU47QUFBQSxXQUFYO0FBRm1DO0FBR3BDO0FBQ0QsOEVBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUIsT0FBekI7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7OztrQ0FFYSxPLEVBQVMsSSxFQUFNO0FBQzNCLFdBQUssWUFBTDtBQUNBLHlGQUFvQixPQUFwQixFQUE2QixJQUE3QjtBQUNEOzs7NEJBRU8sTyxFQUFTLEksRUFBTTtBQUNyQixXQUFLLFlBQUw7QUFDQSxtRkFBYyxPQUFkLEVBQXVCLElBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztxQ0FZaUIsUSxFQUFVLFEsRUFBVSxLLEVBQU87QUFDMUMsVUFBSSxLQUFLLGNBQVQsRUFBeUI7QUFDekIsVUFBSSxLQUFLLFNBQUwsQ0FBZSxRQUFmLE1BQTZCLEtBQUssU0FBTCxDQUFlLFFBQWYsQ0FBakMsRUFBMkQ7QUFDekQsYUFBSyxhQUFMLENBQXNCLEtBQUssV0FBTCxDQUFpQixXQUF2QyxjQUE2RDtBQUMzRCxvQkFBVSxVQURpRDtBQUUzRCw0QkFGMkQ7QUFHM0QsNEJBSDJEO0FBSTNEO0FBSjJELFNBQTdEO0FBTUQ7QUFDRjs7O3NDQUVpQixRLEVBQVUsUSxFQUFVLEssRUFBTztBQUMzQyxVQUFJLE1BQU0sQ0FBTixFQUFTLE9BQVQsQ0FBaUIsVUFBakIsTUFBaUMsQ0FBckMsRUFBd0M7QUFDdEMsYUFBSyxnQkFBTCxDQUFzQixRQUF0QixFQUFnQyxRQUFoQyxFQUEwQyxLQUExQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7K0JBVVc7QUFDVCxVQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ25CLGFBQUssU0FBTDtBQUNBLGFBQUssU0FBTCxDQUFlLFFBQWYsR0FBMEIsS0FBSyxLQUFMLENBQVcsS0FBSyxRQUFoQixDQUExQjtBQUNEO0FBQ0QsYUFBTyxLQUFLLFNBQVo7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7MENBVzZCLFMsRUFBVztBQUN0QyxhQUFPLElBQVA7QUFDRDs7OztFQXRjcUIsUTs7QUF5Y3hCOzs7Ozs7O0FBS0EsVUFBVSxTQUFWLENBQW9CLFNBQXBCLEdBQWdDLElBQWhDOztBQUVBOzs7Ozs7O0FBT0EsVUFBVSxTQUFWLENBQW9CLFFBQXBCLEdBQStCLElBQS9COztBQUdBOzs7Ozs7Ozs7Ozs7OztBQWNBLFVBQVUsU0FBVixDQUFvQixvQkFBcEIsR0FBMkMsSUFBM0M7O0FBR0E7Ozs7Ozs7Ozs7O0FBV0EsVUFBVSxTQUFWLENBQW9CLGtCQUFwQixHQUF5QyxJQUF6Qzs7QUFFQTs7Ozs7QUFLQSxVQUFVLFNBQVYsQ0FBb0IsU0FBcEIsR0FBZ0MsSUFBaEM7O0FBSUE7Ozs7OztBQU1BLFVBQVUsaUJBQVYsR0FBOEIsV0FBOUI7O0FBRUE7Ozs7Ozs7QUFPQSxVQUFVLE9BQVYsR0FBb0IsU0FBcEI7O0FBRUE7Ozs7Ozs7OztBQVNBLFVBQVUsS0FBVixHQUFrQixPQUFsQjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxVQUFVLGdDQUFWLEdBQTZDLGVBQTdDOztBQUdBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsU0FBckIsRUFBZ0MsQ0FBQyxTQUFELEVBQVksV0FBWixDQUFoQztBQUNBLFNBQVMsVUFBVCxDQUFvQixJQUFwQixDQUF5QixTQUF6QjtBQUNBLE9BQU8sT0FBUCxHQUFpQixTQUFqQiIsImZpbGUiOiJjb250YWluZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgQ29udGFpbmVyIGlzIGEgcGFyZW50IGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbnRhaW5lciB0aGF0IG1hbmFnZXMgYSBzZXQgb2YgTWVzc2FnZXMuXG4gKlxuICogQGNsYXNzICBsYXllci5Db250YWluZXJcbiAqIEBhYnN0cmFjdFxuICogQGV4dGVuZHMgbGF5ZXIuU3luY2FibGVcbiAqIEBhdXRob3IgIE1pY2hhZWwgS2FudG9yXG4gKi9cbmNvbnN0IFN5bmNhYmxlID0gcmVxdWlyZSgnLi9zeW5jYWJsZScpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4uL2xheWVyLWVycm9yJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vY2xpZW50LXV0aWxzJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4uL3Jvb3QnKTtcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgU3luY2FibGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBUaGUgc3RhdGljIGBsYXllci5Db252ZXJzYXRpb24uY3JlYXRlKClgIG1ldGhvZFxuICAgKiB3aWxsIGNvcnJlY3RseSBsb29rdXAgZGlzdGluY3QgQ29udmVyc2F0aW9ucyBhbmRcbiAgICogcmV0dXJuIHRoZW07IGBuZXcgbGF5ZXIuQ29udmVyc2F0aW9uKClgIHdpbGwgbm90LlxuICAgKlxuICAgKiBEZXZlbG9wZXJzIHNob3VsZCB1c2UgYGxheWVyLkNvbnZlcnNhdGlvbi5jcmVhdGUoKWAuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXS9sYXllci5JZGVudGl0eVtdfSBvcHRpb25zLnBhcnRpY2lwYW50cyAtIEFycmF5IG9mIFBhcnRpY2lwYW50IElEcyBvciBsYXllci5JZGVudGl0eSBpbnN0YW5jZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kaXN0aW5jdD10cnVlXSAtIElzIHRoZSBjb252ZXJzYXRpb24gZGlzdGluY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1ldGFkYXRhXSAtIEFuIG9iamVjdCBjb250YWluaW5nIENvbnZlcnNhdGlvbiBNZXRhZGF0YS5cbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBJRCBmcm9tIGhhbmRsZSBmcm9tU2VydmVyIHBhcmFtZXRlciBpcyB1c2VkIGJ5IHRoZSBSb290LmNvbnN0cnVjdG9yXG4gICAgaWYgKG9wdGlvbnMuZnJvbVNlcnZlcikgb3B0aW9ucy5pZCA9IG9wdGlvbnMuZnJvbVNlcnZlci5pZDtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGNsaWVudElkIHByb3BlcnR5XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50KSBvcHRpb25zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnQuYXBwSWQ7XG4gICAgaWYgKCFvcHRpb25zLm1ldGFkYXRhKSBvcHRpb25zLm1ldGFkYXRhID0ge307XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIGlmICghdGhpcy5jbGllbnRJZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jbGllbnRNaXNzaW5nKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSBvcHRpb25zIGNvbnRhaW5zIGEgZnVsbCBzZXJ2ZXIgZGVmaW5pdGlvbiBvZiB0aGUgb2JqZWN0LFxuICAgIC8vIGNvcHkgaXQgaW4gd2l0aCBfcG9wdWxhdGVGcm9tU2VydmVyOyB0aGlzIHdpbGwgYWRkIHRoZSBDb252ZXJzYXRpb25cbiAgICAvLyB0byB0aGUgQ2xpZW50IGFzIHdlbGwuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mcm9tU2VydmVyKSB7XG4gICAgICB0aGlzLl9wb3B1bGF0ZUZyb21TZXJ2ZXIob3B0aW9ucy5mcm9tU2VydmVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubWV0YWRhdGEpIHRoaXMubWV0YWRhdGEgPSB7fTtcblxuICAgIGlmICghdGhpcy5jcmVhdGVkQXQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICB9XG5cblxuICBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pc05ldygpKSB7XG4gICAgICB0aGlzLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3luY1N0YXRlXG4gICAgICB0aGlzLl9zZXRTeW5jaW5nKCk7XG5cbiAgICAgIHRoaXMuZ2V0Q2xpZW50KCkuX3RyaWdnZXJBc3luYygnc3RhdGUtY2hhbmdlJywge1xuICAgICAgICBzdGFydGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnc2VuZF8nICsgVXRpbC50eXBlRnJvbUlEKHRoaXMuaWQpLFxuICAgICAgICB0ZWxlbWV0cnlJZDogJ3NlbmRfJyArIFV0aWwudHlwZUZyb21JRCh0aGlzLmlkKSArICdfdGltZScsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldENsaWVudCgpLnNlbmRTb2NrZXRSZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IHt9LCAvLyBzZWUgX2dldFNlbmREYXRhXG4gICAgICAgIHN5bmM6IHtcbiAgICAgICAgICBkZXBlbmRzOiB0aGlzLmlkLFxuICAgICAgICAgIHRhcmdldDogdGhpcy5pZCxcbiAgICAgICAgfSxcbiAgICAgIH0sIHJlc3VsdCA9PiB0aGlzLl9jcmVhdGVSZXN1bHQocmVzdWx0KSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB0aGlzLl9zZXR1cE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgdGhpcyBpbnN0YW5jZSB1c2luZyBzZXJ2ZXItZGF0YS5cbiAgICpcbiAgICogU2lkZSBlZmZlY3RzIGFkZCB0aGlzIHRvIHRoZSBDbGllbnQuXG4gICAqXG4gICAqIEBtZXRob2QgX3BvcHVsYXRlRnJvbVNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRhaW5lciAtIFNlcnZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGFpbmVyXG4gICAqL1xuICBfcG9wdWxhdGVGcm9tU2VydmVyKGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG5cbiAgICB0aGlzLl9zZXRTeW5jZWQoKTtcblxuICAgIGNvbnN0IGlkID0gdGhpcy5pZDtcbiAgICB0aGlzLmlkID0gY29udGFpbmVyLmlkO1xuXG4gICAgLy8gSURzIGNoYW5nZSBpZiB0aGUgc2VydmVyIHJldHVybnMgYSBtYXRjaGluZyBDb250YWluZXJcbiAgICBpZiAoaWQgIT09IHRoaXMuaWQpIHtcbiAgICAgIGNsaWVudC5fdXBkYXRlQ29udGFpbmVySWQodGhpcywgaWQpO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKGAke3RoaXMuY29uc3RydWN0b3IuZXZlbnRQcmVmaXh9OmNoYW5nZWAsIHtcbiAgICAgICAgb2xkVmFsdWU6IGlkLFxuICAgICAgICBuZXdWYWx1ZTogdGhpcy5pZCxcbiAgICAgICAgcHJvcGVydHk6ICdpZCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVybCA9IGNvbnRhaW5lci51cmw7XG4gICAgdGhpcy5jcmVhdGVkQXQgPSBuZXcgRGF0ZShjb250YWluZXIuY3JlYXRlZF9hdCk7XG4gICAgdGhpcy5tZXRhZGF0YSA9IGNvbnRhaW5lci5tZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHJlc3VsdCBvZiBzZW5kIG1ldGhvZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdlIHVzZSBfdHJpZ2dlckFzeW5jIHNvIHRoYXRcbiAgICogZXZlbnRzIHJlcG9ydGluZyBjaGFuZ2VzIHRvIHRoZSBsYXllci5Db252ZXJzYXRpb24uaWQgY2FuXG4gICAqIGJlIGFwcGxpZWQgYmVmb3JlIHJlcG9ydGluZyBvbiBpdCBiZWluZyBzZW50LlxuICAgKlxuICAgKiBFeGFtcGxlOiBRdWVyeSB3aWxsIG5vdyBoYXZlIHRoZSByZXNvbHZlZCBEaXN0aW5jdCBJRHMgcmF0aGVyIHRoYW4gdGhlIHByb3Bvc2VkIElEXG4gICAqIHdoZW4gdGhpcyBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZVJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdFxuICAgKi9cbiAgX2NyZWF0ZVJlc3VsdCh7IHN1Y2Nlc3MsIGRhdGEgfSkge1xuICAgIHRoaXMuZ2V0Q2xpZW50KCkuX3RyaWdnZXJBc3luYygnc3RhdGUtY2hhbmdlJywge1xuICAgICAgZW5kZWQ6IHRydWUsXG4gICAgICB0eXBlOiAnc2VuZF8nICsgVXRpbC50eXBlRnJvbUlEKHRoaXMuaWQpLFxuICAgICAgdGVsZW1ldHJ5SWQ6ICdzZW5kXycgKyBVdGlsLnR5cGVGcm9tSUQodGhpcy5pZCkgKyAnX3RpbWUnLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgdGhpcy5fY3JlYXRlU3VjY2VzcyhkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuaWQgPT09ICdjb25mbGljdCcpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVJlc3VsdENvbmZsaWN0KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5ldmVudFByZWZpeCArICc6c2VudC1lcnJvcicsIHsgZXJyb3I6IGRhdGEgfSk7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBzdWNjZXNzZnVsIHJlc3VsdCBvZiBhIGNyZWF0ZSBjYWxsXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZVN1Y2Nlc3NcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIFNlcnZlciBkZXNjcmlwdGlvbiBvZiBDb252ZXJzYXRpb24vQ2hhbm5lbFxuICAgKi9cbiAgX2NyZWF0ZVN1Y2Nlc3MoZGF0YSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5pZDtcbiAgICB0aGlzLl9wb3B1bGF0ZUZyb21TZXJ2ZXIoZGF0YSk7XG4gICAgdGhpcy5fdHJpZ2dlckFzeW5jKHRoaXMuY29uc3RydWN0b3IuZXZlbnRQcmVmaXggKyAnOnNlbnQnLCB7XG4gICAgICByZXN1bHQ6IGlkID09PSB0aGlzLmlkID8gQ29udGFpbmVyLkNSRUFURUQgOiBDb250YWluZXIuRk9VTkQsXG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHNwZWNpZmllZCBtZXRhZGF0YSBrZXlzLlxuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBvYmplY3QncyBtZXRhZGF0YSBhbmQgc3luY3MgdGhlIGNoYW5nZSB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiAgICAgIGNvbnZlcnNhdGlvbi5zZXRNZXRhZGF0YVByb3BlcnRpZXMoe1xuICAgKiAgICAgICAgICAndGl0bGUnOiAnSSBhbSBhIHRpdGxlJyxcbiAgICogICAgICAgICAgJ2NvbG9ycy5iYWNrZ3JvdW5kJzogJ3JlZCcsXG4gICAqICAgICAgICAgICdjb2xvcnMudGV4dCc6IHtcbiAgICogICAgICAgICAgICAgICdmaWxsJzogJ2JsdWUnLFxuICAgKiAgICAgICAgICAgICAgJ3NoYWRvdyc6ICdibGFjaydcbiAgICogICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAnY29sb3JzLnRpdGxlLmZpbGwnOiAncmVkJ1xuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBVc2Ugc2V0TWV0YWRhdGFQcm9wZXJ0aWVzIHRvIHNwZWNpZnkgdGhlIHBhdGggdG8gYSBwcm9wZXJ0eSwgYW5kIGEgbmV3IHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LlxuICAgKiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGNhbiBiZSBjaGFuZ2VkIHRoaXMgd2F5LiAgV2hhdGV2ZXIgdmFsdWUgd2FzIHRoZXJlIGJlZm9yZSBpc1xuICAgKiByZXBsYWNlZCB3aXRoIHRoZSBuZXcgdmFsdWU7IHNvIGluIHRoZSBhYm92ZSBleGFtcGxlLCB3aGF0ZXZlciBvdGhlciBrZXlzIG1heSBoYXZlXG4gICAqIGV4aXN0ZWQgdW5kZXIgYGNvbG9ycy50ZXh0YCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgdGhlIG5ldyBvYmplY3QgYHtmaWxsOiAnYmx1ZScsIHNoYWRvdzogJ2JsYWNrJ31gLlxuICAgKlxuICAgKiBOb3RlIGFsc28gdGhhdCBvbmx5IHN0cmluZyBhbmQgc3Vib2JqZWN0cyBhcmUgYWNjZXB0ZWQgYXMgdmFsdWVzLlxuICAgKlxuICAgKiBLZXlzIHdpdGggJy4nIHdpbGwgdXBkYXRlIGEgZmllbGQgb2YgYW4gb2JqZWN0IChhbmQgY3JlYXRlIGFuIG9iamVjdCBpZiBpdCB3YXNuJ3QgdGhlcmUpOlxuICAgKlxuICAgKiBJbml0aWFsIG1ldGFkYXRhOiB7fVxuICAgKlxuICAgKiAgICAgIGNvbnZlcnNhdGlvbi5zZXRNZXRhZGF0YVByb3BlcnRpZXMoe1xuICAgKiAgICAgICAgICAnY29sb3JzLmJhY2tncm91bmQnOiAncmVkJyxcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogTWV0YWRhdGEgaXMgbm93OiBge2NvbG9yczoge2JhY2tncm91bmQ6ICdyZWQnfX1gXG4gICAqXG4gICAqICAgICAgY29udmVyc2F0aW9uLnNldE1ldGFkYXRhUHJvcGVydGllcyh7XG4gICAqICAgICAgICAgICdjb2xvcnMuZm9yZWdyb3VuZCc6ICdibGFjaycsXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIE1ldGFkYXRhIGlzIG5vdzogYHtjb2xvcnM6IHtiYWNrZ3JvdW5kOiAncmVkJywgZm9yZWdyb3VuZDogJ2JsYWNrJ319YFxuICAgKlxuICAgKiBFeGVjdXRlcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAxLiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBwcm9wZXJ0eSBvZiB0aGUgbG9jYWwgb2JqZWN0XG4gICAqIDIuIFRyaWdnZXJzIGEgY29udmVyc2F0aW9uczpjaGFuZ2UgZXZlbnRcbiAgICogMy4gU3VibWl0cyBhIHJlcXVlc3QgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHVwZGF0ZSB0aGUgc2VydmVyJ3Mgb2JqZWN0XG4gICAqIDQuIElmIHRoZXJlIGlzIGFuIGVycm9yLCBubyBlcnJvcnMgYXJlIGZpcmVkIGV4Y2VwdCBieSBsYXllci5TeW5jTWFuYWdlciwgYnV0IGFub3RoZXJcbiAgICogICAgY29udmVyc2F0aW9uczpjaGFuZ2UgZXZlbnQgaXMgZmlyZWQgYXMgdGhlIGNoYW5nZSBpcyByb2xsZWQgYmFjay5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRNZXRhZGF0YVByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKlxuICAgKi9cbiAgc2V0TWV0YWRhdGFQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgY29uc3QgbGF5ZXJQYXRjaE9wZXJhdGlvbnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgbGV0IGZ1bGxOYW1lID0gbmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSAnbWV0YWRhdGEnICYmIG5hbWUuaW5kZXhPZignbWV0YWRhdGEuJykgIT09IDApIHtcbiAgICAgICAgICBmdWxsTmFtZSA9ICdtZXRhZGF0YS4nICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBsYXllclBhdGNoT3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBvcGVyYXRpb246ICdzZXQnLFxuICAgICAgICAgIHByb3BlcnR5OiBmdWxsTmFtZSxcbiAgICAgICAgICB2YWx1ZTogcHJvcHNbbmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IHRydWU7XG5cbiAgICAvLyBEbyB0aGlzIGJlZm9yZSBzZXRTeW5jaW5nIGFzIGlmIHRoZXJlIGFyZSBhbnkgZXJyb3JzLCB3ZSBzaG91bGQgbmV2ZXIgZXZlblxuICAgIC8vIHN0YXJ0IHNldHRpbmcgdXAgYSByZXF1ZXN0LlxuICAgIFV0aWwubGF5ZXJQYXJzZSh7XG4gICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICB0eXBlOiAnQ29udmVyc2F0aW9uJyxcbiAgICAgIG9wZXJhdGlvbnM6IGxheWVyUGF0Y2hPcGVyYXRpb25zLFxuICAgICAgY2xpZW50OiB0aGlzLmdldENsaWVudCgpLFxuICAgIH0pO1xuICAgIHRoaXMuX2luTGF5ZXJQYXJzZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3hocih7XG4gICAgICB1cmw6ICcnLFxuICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkobGF5ZXJQYXRjaE9wZXJhdGlvbnMpLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5sYXllci1wYXRjaCtqc29uJyxcbiAgICAgIH0sXG4gICAgfSwgKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyAmJiAhdGhpcy5pc0Rlc3Ryb3llZCAmJiByZXN1bHQuZGF0YS5pZCAhPT0gJ2F1dGhlbnRpY2F0aW9uX3JlcXVpcmVkJykgdGhpcy5fbG9hZCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHNwZWNpZmllZCBtZXRhZGF0YSBrZXlzLlxuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBvYmplY3QncyBtZXRhZGF0YSBhbmQgc3luY3MgdGhlIGNoYW5nZSB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiAgICAgIGNvbnZlcnNhdGlvbi5kZWxldGVNZXRhZGF0YVByb3BlcnRpZXMoXG4gICAqICAgICAgICAgIFsndGl0bGUnLCAnY29sb3JzLmJhY2tncm91bmQnLCAnY29sb3JzLnRpdGxlLmZpbGwnXVxuICAgKiAgICAgICk7XG4gICAqXG4gICAqIFVzZSBkZWxldGVNZXRhZGF0YVByb3BlcnRpZXMgdG8gc3BlY2lmeSBwYXRocyB0byBwcm9wZXJ0aWVzIHRvIGJlIGRlbGV0ZWQuXG4gICAqIE11bHRpcGxlIHByb3BlcnRpZXMgY2FuIGJlIGRlbGV0ZWQuXG4gICAqXG4gICAqIEV4ZWN1dGVzIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIDEuIFVwZGF0ZXMgdGhlIG1ldGFkYXRhIHByb3BlcnR5IG9mIHRoZSBsb2NhbCBvYmplY3RcbiAgICogMi4gVHJpZ2dlcnMgYSBjb252ZXJzYXRpb25zOmNoYW5nZSBldmVudFxuICAgKiAzLiBTdWJtaXRzIGEgcmVxdWVzdCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIgdG8gdXBkYXRlIHRoZSBzZXJ2ZXIncyBvYmplY3RcbiAgICogNC4gSWYgdGhlcmUgaXMgYW4gZXJyb3IsIG5vIGVycm9ycyBhcmUgZmlyZWQgZXhjZXB0IGJ5IGxheWVyLlN5bmNNYW5hZ2VyLCBidXQgYW5vdGhlclxuICAgKiAgICBjb252ZXJzYXRpb25zOmNoYW5nZSBldmVudCBpcyBmaXJlZCBhcyB0aGUgY2hhbmdlIGlzIHJvbGxlZCBiYWNrLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZU1ldGFkYXRhUHJvcGVydGllc1xuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gcHJvcGVydGllc1xuICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259IHRoaXNcbiAgICovXG4gIGRlbGV0ZU1ldGFkYXRhUHJvcGVydGllcyhwcm9wcykge1xuICAgIGNvbnN0IGxheWVyUGF0Y2hPcGVyYXRpb25zID0gW107XG4gICAgcHJvcHMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ21ldGFkYXRhJyAmJiBwcm9wZXJ0eS5pbmRleE9mKCdtZXRhZGF0YS4nKSAhPT0gMCkge1xuICAgICAgICBwcm9wZXJ0eSA9ICdtZXRhZGF0YS4nICsgcHJvcGVydHk7XG4gICAgICB9XG4gICAgICBsYXllclBhdGNoT3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgb3BlcmF0aW9uOiAnZGVsZXRlJyxcbiAgICAgICAgcHJvcGVydHksXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2luTGF5ZXJQYXJzZXIgPSB0cnVlO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgc2V0U3luY2luZyBhcyBpZiB0aGVyZSBhcmUgYW55IGVycm9ycywgd2Ugc2hvdWxkIG5ldmVyIGV2ZW5cbiAgICAvLyBzdGFydCBzZXR0aW5nIHVwIGEgcmVxdWVzdC5cbiAgICBVdGlsLmxheWVyUGFyc2Uoe1xuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgdHlwZTogJ0NvbnZlcnNhdGlvbicsXG4gICAgICBvcGVyYXRpb25zOiBsYXllclBhdGNoT3BlcmF0aW9ucyxcbiAgICAgIGNsaWVudDogdGhpcy5nZXRDbGllbnQoKSxcbiAgICB9KTtcbiAgICB0aGlzLl9pbkxheWVyUGFyc2VyID0gZmFsc2U7XG5cbiAgICB0aGlzLl94aHIoe1xuICAgICAgdXJsOiAnJyxcbiAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGxheWVyUGF0Y2hPcGVyYXRpb25zKSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi92bmQubGF5ZXItcGF0Y2granNvbicsXG4gICAgICB9LFxuICAgIH0sIChyZXN1bHQpID0+IHtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEuaWQgIT09ICdhdXRoZW50aWNhdGlvbl9yZXF1aXJlZCcpIHRoaXMuX2xvYWQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblxuICAvKipcbiAgICogRGVsZXRlIHRoZSBDb252ZXJzYXRpb24gZnJvbSB0aGUgc2VydmVyIChpbnRlcm5hbCB2ZXJzaW9uKS5cbiAgICpcbiAgICogVGhpcyB2ZXJzaW9uIG9mIERlbGV0ZSB0YWtlcyBhIFF1ZXJ5IFN0cmluZyB0aGF0IGlzIHBhY2thZ2VkIHVwIGJ5XG4gICAqIGxheWVyLkNvbnZlcnNhdGlvbi5kZWxldGUgYW5kIGxheWVyLkNvbnZlcnNhdGlvbi5sZWF2ZS5cbiAgICpcbiAgICogQG1ldGhvZCBfZGVsZXRlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVN0ciAtIFF1ZXJ5IHN0cmluZyBmb3IgdGhlIERFTEVURSByZXF1ZXN0XG4gICAqL1xuICBfZGVsZXRlKHF1ZXJ5U3RyKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuX3hocih7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsOiAnPycgKyBxdWVyeVN0cixcbiAgICB9LCByZXN1bHQgPT4gdGhpcy5fZGVsZXRlUmVzdWx0KHJlc3VsdCwgaWQpKTtcblxuICAgIHRoaXMuX2RlbGV0ZWQoKTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuXG4gIF9oYW5kbGVXZWJzb2NrZXREZWxldGUoZGF0YSkge1xuICAgIGlmIChkYXRhLm1vZGUgPT09IENvbnN0YW50cy5ERUxFVElPTl9NT0RFLk1ZX0RFVklDRVMgJiYgZGF0YS5mcm9tX3Bvc2l0aW9uKSB7XG4gICAgICB0aGlzLmdldENsaWVudCgpLl9wdXJnZU1lc3NhZ2VzQnlQb3NpdGlvbih0aGlzLmlkLCBkYXRhLmZyb21fcG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5faGFuZGxlV2Vic29ja2V0RGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy51cmwgKyAodXJsIHx8ICcnKTtcbiAgfVxuXG4gIF9sb2FkZWQoZGF0YSkge1xuICAgIHRoaXMuX3JlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGBvbigpYCBwcm92aWRlZCBieSBsYXllci5Sb290LlxuICAgKlxuICAgKiBBZGRzIHNvbWUgc3BlY2lhbCBoYW5kbGluZyBvZiAnY29udmVyc2F0aW9uczpsb2FkZWQnIHNvIHRoYXQgY2FsbHMgc3VjaCBhc1xuICAgKlxuICAgKiAgICAgIHZhciBjID0gY2xpZW50LmdldENvbnZlcnNhdGlvbignbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy8xMjMnLCB0cnVlKVxuICAgKiAgICAgIC5vbignY29udmVyc2F0aW9uczpsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgbXlyZXJlbmRlcihjKTtcbiAgICogICAgICB9KTtcbiAgICogICAgICBteXJlbmRlcihjKTsgLy8gcmVuZGVyIGEgcGxhY2Vob2xkZXIgZm9yIGMgdW50aWwgdGhlIGRldGFpbHMgb2YgYyBoYXZlIGxvYWRlZFxuICAgKlxuICAgKiBjYW4gZmlyZSB0aGVpciBjYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNsaWVudCBsb2FkcyBvciBoYXNcbiAgICogYWxyZWFkeSBsb2FkZWQgdGhlIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKi9cbiAgb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBldnROYW1lID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5ldmVudFByZWZpeH06bG9hZGVkYDtcbiAgICBjb25zdCBoYXNMb2FkZWRFdnQgPSBuYW1lID09PSBldnROYW1lIHx8IChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyAmJiBuYW1lW2V2dE5hbWVdKTtcblxuICAgIGlmIChoYXNMb2FkZWRFdnQgJiYgIXRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICBjb25zdCBjYWxsTm93ID0gbmFtZSA9PT0gZXZ0TmFtZSA/IGNhbGxiYWNrIDogbmFtZVtldnROYW1lXTtcbiAgICAgIFV0aWwuZGVmZXIoKCkgPT4gY2FsbE5vdy5hcHBseShjb250ZXh0KSk7XG4gICAgfVxuICAgIHN1cGVyLm9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX3RyaWdnZXJBc3luYyhldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci5fdHJpZ2dlckFzeW5jKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgdHJpZ2dlcihldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci50cmlnZ2VyKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIF9fIE1ldGhvZHMgYXJlIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHByb3BlcnR5IHNldHRlcnMuXG4gICAqXG4gICAqIEFueSBjaGFuZ2UgaW4gdGhlIG1ldGFkYXRhIHByb3BlcnR5IHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBhbmQgZmlyZSBhXG4gICAqIGNoYW5nZSBldmVudC4gIENoYW5nZXMgdG8gdGhlIG1ldGFkYXRhIG9iamVjdCB0aGF0IGRvbid0IHJlcGxhY2UgdGhlIG9iamVjdFxuICAgKiB3aXRoIGEgbmV3IG9iamVjdCB3aWxsIHJlcXVpcmUgZGlyZWN0bHkgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZU1ldGFkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gbmV3VmFsdWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvbGRWYWx1ZVxuICAgKi9cbiAgX191cGRhdGVNZXRhZGF0YShuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGhzKSB7XG4gICAgaWYgKHRoaXMuX2luTGF5ZXJQYXJzZXIpIHJldHVybjtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUpICE9PSBKU09OLnN0cmluZ2lmeShvbGRWYWx1ZSkpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYyhgJHt0aGlzLmNvbnN0cnVjdG9yLmV2ZW50UHJlZml4fTpjaGFuZ2VgLCB7XG4gICAgICAgIHByb3BlcnR5OiAnbWV0YWRhdGEnLFxuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgIHBhdGhzLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVBhdGNoRXZlbnQobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocykge1xuICAgIGlmIChwYXRoc1swXS5pbmRleE9mKCdtZXRhZGF0YScpID09PSAwKSB7XG4gICAgICB0aGlzLl9fdXBkYXRlTWV0YWRhdGEobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIE9iamVjdCB3aWxsIGhhdmUgYWxsIHRoZSBzYW1lIHB1YmxpYyBwcm9wZXJ0aWVzIGFzIHRoaXNcbiAgICogQ29udmVyc2F0aW9uIGluc3RhbmNlLiAgTmV3IG9iamVjdCBpcyByZXR1cm5lZCBhbnkgdGltZVxuICAgKiBhbnkgb2YgdGhpcyBvYmplY3QncyBwcm9wZXJ0aWVzIGNoYW5nZS5cbiAgICpcbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFBPSk8gdmVyc2lvbiBvZiB0aGlzLlxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLl90b09iamVjdCkge1xuICAgICAgdGhpcy5fdG9PYmplY3QgPSBzdXBlci50b09iamVjdCgpO1xuICAgICAgdGhpcy5fdG9PYmplY3QubWV0YWRhdGEgPSBVdGlsLmNsb25lKHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllcyB3aGV0aGVyIGEgQ29udmVyc2F0aW9uIHJlY2VpdmluZyB0aGUgc3BlY2lmaWVkIHBhdGNoIGRhdGEgc2hvdWxkIGJlIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEFueSBjaGFuZ2UgdG8gYSBDb252ZXJzYXRpb24gaW5kaWNhdGVzIHRoYXQgdGhlIENvbnZlcnNhdGlvbiBpcyBhY3RpdmUgYW5kIG9mIHBvdGVudGlhbCBpbnRlcmVzdDsgZ28gYWhlYWQgYW5kIGxvYWQgdGhhdFxuICAgKiBDb252ZXJzYXRpb24gaW4gY2FzZSB0aGUgYXBwIGhhcyBuZWVkIG9mIGl0LiAgSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgaWdub3JlIGNoYW5nZXMgdG8gdW5yZWFkIGNvdW50LiAgT25seSByZWxldmFudFxuICAgKiB3aGVuIHdlIGdldCBXZWJzb2NrZXQgZXZlbnRzIGZvciBhIENvbnZlcnNhdGlvbiB0aGF0IGhhcyBub3QgYmVlbiBsb2FkZWQvY2FjaGVkIG9uIENsaWVudC5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZFJlc291cmNlRm9yUGF0Y2hcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9sb2FkUmVzb3VyY2VGb3JQYXRjaChwYXRjaERhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRpbWUgdGhhdCB0aGUgY29udmVyc2F0aW9uIHdhcyBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHR5cGUge0RhdGV9XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuY3JlYXRlZEF0ID0gbnVsbDtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgdGhlIGNvbnZlcnNhdGlvbi5cbiAqXG4gKiBNZXRhZGF0YSB2YWx1ZXMgY2FuIGJlIHBsYWluIG9iamVjdHMgYW5kIHN0cmluZ3MsIGJ1dFxuICogbm8gYXJyYXlzLCBudW1iZXJzLCBib29sZWFucyBvciBkYXRlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUubWV0YWRhdGEgPSBudWxsO1xuXG5cbi8qKlxuICogVGhlIGF1dGhlbnRpY2F0ZWQgdXNlciBpcyBhIGN1cnJlbnQgcGFydGljaXBhbnQgaW4gdGhpcyBDb252ZXJzYXRpb24uXG4gKlxuICogU2V0IHRvIGZhbHNlIGlmIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoaXMgY29udmVyc2F0aW9uLlxuICpcbiAqIEEgcmVtb3ZlZCB1c2VyIGNhbiBzZWUgbWVzc2FnZXMgdXAgdG8gdGhlIHRpbWUgdGhleSB3ZXJlIHJlbW92ZWQsXG4gKiBidXQgY2FuIG5vIGxvbmdlciBpbnRlcmFjdCB3aXRoIHRoZSBjb252ZXJzYXRpb24uXG4gKlxuICogQSByZW1vdmVkIHVzZXIgY2FuIG5vIGxvbmdlciBzZWUgdGhlIHBhcnRpY2lwYW50IGxpc3QuXG4gKlxuICogUmVhZCBhbmQgRGVsaXZlcnkgcmVjZWlwdHMgd2lsbCBmYWlsIG9uIGFueSBNZXNzYWdlIGluIHN1Y2ggYSBDb252ZXJzYXRpb24uXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuaXNDdXJyZW50UGFydGljaXBhbnQgPSB0cnVlO1xuXG5cbi8qKlxuICogQ2FjaGUncyBhIERpc3RpbmN0IEV2ZW50LlxuICpcbiAqIE9uIGNyZWF0aW5nIGEgQ2hhbm5lbCBvciBDb252ZXJzYXRpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyxcbiAqIHdoZW4gdGhlIHNlbmQoKSBtZXRob2QgaXMgY2FsbGVkLCB3ZSBzaG91bGQgdHJpZ2dlclxuICogc3BlY2lmaWMgZXZlbnRzIGRldGFpbGluZyB0aGUgcmVzdWx0cy4gIFJlc3VsdHNcbiAqIG1heSBiZSBkZXRlcm1pbmVkIGxvY2FsbHkgb3Igb24gdGhlIHNlcnZlciwgYnV0IHNhbWUgRXZlbnQgbWF5IGJlIG5lZWRlZC5cbiAqXG4gKiBAdHlwZSB7bGF5ZXIuTGF5ZXJFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuX3NlbmREaXN0aW5jdEV2ZW50ID0gbnVsbDtcblxuLyoqXG4gKiBDYWNoZXMgbGFzdCByZXN1bHQgb2YgdG9PYmplY3QoKVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbnRhaW5lci5wcm90b3R5cGUuX3RvT2JqZWN0ID0gbnVsbDtcblxuXG5cbi8qKlxuICogUHJvcGVydHkgdG8gbG9vayBmb3Igd2hlbiBidWJibGluZyB1cCBldmVudHMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuQ29udGFpbmVyLmJ1YmJsZUV2ZW50UGFyZW50ID0gJ2dldENsaWVudCc7XG5cbi8qKlxuICogVGhlIENvbnZlcnNhdGlvbi9DaGFubmVsIHRoYXQgd2FzIHJlcXVlc3RlZCBoYXMgYmVlbiBjcmVhdGVkLlxuICpcbiAqIFVzZWQgaW4gYGNvbnZlcnNhdGlvbnM6c2VudGAgZXZlbnRzLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuQ29udGFpbmVyLkNSRUFURUQgPSAnQ3JlYXRlZCc7XG5cbi8qKlxuICogVGhlIENvbnZlcnNhdGlvbi9DaGFubmVsIHRoYXQgd2FzIHJlcXVlc3RlZCBoYXMgYmVlbiBmb3VuZC5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgaXQgZGlkIG5vdCBuZWVkIHRvIGJlIGNyZWF0ZWQuXG4gKlxuICogVXNlZCBpbiBgY29udmVyc2F0aW9uczpzZW50YCBldmVudHMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5Db250YWluZXIuRk9VTkQgPSAnRm91bmQnO1xuXG4vKipcbiAqIFRoZSBDb252ZXJzYXRpb24vQ2hhbm5lbCB0aGF0IHdhcyByZXF1ZXN0ZWQgaGFzIGJlZW4gZm91bmQsIGJ1dCB0aGVyZSB3YXMgYSBtaXNtYXRjaCBpbiBtZXRhZGF0YS5cbiAqXG4gKiBJZiB0aGUgY3JlYXRlQ29udmVyc2F0aW9uIHJlcXVlc3QgY29udGFpbmVkIG1ldGFkYXRhIGFuZCBpdCBkaWQgbm90IG1hdGNoIHRoZSBEaXN0aW5jdCBDb252ZXJzYXRpb25cbiAqIHRoYXQgbWF0Y2hlZCB0aGUgcmVxdWVzdGVkIHBhcnRpY2lwYW50cywgdGhlbiB0aGlzIHZhbHVlIGlzIHBhc3NlZCB0byBub3RpZnkgeW91ciBhcHAgdGhhdCB0aGUgQ29udmVyc2F0aW9uXG4gKiB3YXMgcmV0dXJuZWQgYnV0IGRvZXMgbm90IGV4YWN0bHkgbWF0Y2ggeW91ciByZXF1ZXN0LlxuICpcbiAqIFVzZWQgaW4gYGNvbnZlcnNhdGlvbnM6c2VudGAgZXZlbnRzLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuQ29udGFpbmVyLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBID0gJ0ZvdW5kTWlzbWF0Y2gnO1xuXG5cblJvb3QuaW5pdENsYXNzLmFwcGx5KENvbnRhaW5lciwgW0NvbnRhaW5lciwgJ0NvbnRhaW5lciddKTtcblN5bmNhYmxlLnN1YmNsYXNzZXMucHVzaChDb250YWluZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXI7XG4iXX0=
