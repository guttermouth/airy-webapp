'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The MessagePart class represents an element of a message.
 *
 *      // Create a Message Part with any mimeType
 *      var part = new layer.MessagePart({
 *          body: "hello",
 *          mimeType: "text/plain"
 *      });
 *
 *      // Create a text/plain only Message Part
 *      var part = new layer.MessagePart("Hello I am text/plain");
 *
 * You can also create a Message Part from a File Input dom node:
 *
 *      var fileInputNode = document.getElementById("myFileInput");
 *      var part = new layer.MessagePart(fileInputNode.files[0]);
 *
 * You can also create Message Parts from a file drag and drop operation:
 *
 *      onFileDrop: function(evt) {
 *           var files = evt.dataTransfer.files;
 *           var m = conversation.createMessage({
 *               parts: files.map(function(file) {
 *                  return new layer.MessagePart({body: file, mimeType: file.type});
 *               }
 *           });
 *      });
 *
 * ### Blobs vs Strings
 *
 * You should always expect to see the `body` property be a Blob **unless** the mimeType is listed in layer.MessagePart.TextualMimeTypes,
 * in which case the value will be a String.  You can add mimeTypes to TextualMimeTypes:
 *
 * ```
 * layer.MessagePart.TextualMimeTypes = ['text/plain', 'text/mountain', /^application\/json(\+.+)$/]
 * ```
 *
 * Any mimeType matching the above strings and regular expressions will be transformed to text before being delivered to your app; otherwise it
 * must be a Blob.  Note that the above snippet sets a static property that is set once, and affects all MessagePart objects for the lifespan of
 * the app.
 *
 * ### Accesing Rich Content
 *
 * There are two ways of accessing rich content
 *
 * 1. Access the data directly: `part.fetchContent(function(data) {myRenderData(data);})`. This approach downloads the data,
 *    writes it to the the `body` property, writes a Data URI to the part's `url` property, and then calls your callback.
 *    By downloading the data and storing it in `body`, the data does not expire.
 * 2. Access the URL rather than the data.  When you first receive the Message Part it will have a valid `url` property; however, this URL expires.  *    URLs are needed for streaming, and for content that doesn't yet need to be rendered (e.g. hyperlinks to data that will render when clicked).
 *    The url property will return a string if the url is valid, or '' if its expired.  Call `part.fetchStream(callback)` to get an updated URL.
 *    The following pattern is recommended:
 *
 * ```
 * if (!part.url) {
 *   part.fetchStream(function(url) {myRenderUrl(url)});
 * } else {
 *   myRenderUrl(part.url);
 * }
 * ```
 *
 * NOTE: `layer.MessagePart.url` should have a value when the message is first received, and will only fail `if (!part.url)` once the url has expired.
 *
 * @class  layer.MessagePart
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require('../root');
var Content = require('./content');
var xhr = require('../xhr');
var ClientRegistry = require('../client-registry');
var LayerError = require('../layer-error');
var Util = require('../client-utils');
var logger = require('../logger');

var MessagePart = function (_Root) {
  _inherits(MessagePart, _Root);

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options - Can be an object with body and mimeType, or it can be a string, or a Blob/File
   * @param  {string} options.body - Any string larger than 2kb will be sent as Rich Content, meaning it will be uploaded to cloud storage and must be separately downloaded from the Message when its received.
   * @param  {string} [options.mimeType=text/plain] - Mime type; can be anything; if your client doesn't have a renderer for it, it will be ignored.
   * @param  {number} [options.size=0] - Size of your part. Will be calculated for you if not provided.
   *
   * @return {layer.MessagePart}
   */
  function MessagePart(options) {
    _classCallCheck(this, MessagePart);

    var newOptions = options;
    if (typeof options === 'string') {
      newOptions = { body: options };
      if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) {
        newOptions.mimeType = arguments.length <= 1 ? undefined : arguments[1];
      } else {
        newOptions.mimeType = 'text/plain';
      }
    } else if (Util.isBlob(options) || Util.isBlob(options.body)) {
      var body = options instanceof Blob ? options : options.body;
      var mimeType = Util.isBlob(options.body) ? options.mimeType : body.type;
      newOptions = {
        mimeType: mimeType,
        body: body,
        size: body.size,
        hasContent: true
      };
    }

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MessagePart).call(this, newOptions));

    if (!_this.size && _this.body) _this.size = _this.body.length;

    // Don't expose encoding; blobify it if its encoded.
    if (options.encoding === 'base64') {
      _this.body = Util.base64ToBlob(_this.body);
    }

    // Could be a blob because it was read out of indexedDB,
    // or because it was created locally with a file
    // Or because of base64 encoded data.
    var isBlobBody = Util.isBlob(_this.body);
    var textual = _this.isTextualMimeType();

    // Custom handling for non-textual content
    if (!textual) {
      // If the body exists and is a blob, extract the data uri for convenience; only really relevant for image and video HTML tags.
      if (!isBlobBody && _this.body) _this.body = new Blob([_this.body], { type: _this.mimeType });
      if (_this.body) _this.url = URL.createObjectURL(_this.body);
    }

    // If our textual content is a blob, turning it into text is asychronous, and can't be done in the synchronous constructor
    // This will only happen when the client is attaching a file.  Conversion for locally created messages is done while calling `Message.send()`
    return _this;
  }

  _createClass(MessagePart, [{
    key: 'destroy',
    value: function destroy() {
      if (this.__url) {
        URL.revokeObjectURL(this.__url);
        this.__url = null;
      }
      this.body = null;
      _get(Object.getPrototypeOf(MessagePart.prototype), 'destroy', this).call(this);
    }

    /**
     * Get the layer.Client associated with this layer.MessagePart.
     *
     * Uses the layer.MessagePart.clientId property.
     *
     * @method _getClient
     * @private
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Get the layer.Message associated with this layer.MessagePart.
     *
     * @method _getMessage
     * @private
     * @return {layer.Message}
     */

  }, {
    key: '_getMessage',
    value: function _getMessage() {
      return this._getClient().getMessage(this.id.replace(/\/parts.*$/, ''));
    }

    /**
     * Download Rich Content from cloud server.
     *
     * For MessageParts with rich content, this method will load the data from google's cloud storage.
     * The body property of this MessagePart is set to the result.
     *
     *      messagepart.fetchContent()
     *      .on("content-loaded", function() {
     *          render(messagepart.body);
     *      });
     *
     * Note that a successful call to `fetchContent` will also cause Query change events to fire.
     * In this example, `render` will be called by the query change event that will occur once the content has downloaded:
     *
     * ```
     *  query.on('change', function(evt) {
     *    render(query.data);
     *  });
     *  messagepart.fetchContent();
     * ```
     *
     *
     * @method fetchContent
     * @param {Function} [callback]
     * @param {Mixed} callback.data - Either a string (mimeType=text/plain) or a Blob (all other mimeTypes)
     * @return {layer.Content} this
     */

  }, {
    key: 'fetchContent',
    value: function fetchContent(callback) {
      var _this2 = this;

      if (this._content && !this.isFiring) {
        this.isFiring = true;
        var type = this.mimeType === 'image/jpeg+preview' ? 'image/jpeg' : this.mimeType;
        this._content.loadContent(type, function (err, result) {
          if (!_this2.isDestroyed) _this2._fetchContentCallback(err, result, callback);
        });
      }
      return this;
    }

    /**
     * Callback with result or error from calling fetchContent.
     *
     * @private
     * @method _fetchContentCallback
     * @param {layer.LayerError} err
     * @param {Object} result
     * @param {Function} callback
     */

  }, {
    key: '_fetchContentCallback',
    value: function _fetchContentCallback(err, result, callback) {
      var _this3 = this;

      if (err) {
        this.trigger('content-loaded-error', err);
      } else {
        this.isFiring = false;
        if (this.isTextualMimeType()) {
          Util.fetchTextFromFile(result, function (text) {
            return _this3._fetchContentComplete(text, callback);
          });
        } else {
          this.url = URL.createObjectURL(result);
          this._fetchContentComplete(result, callback);
        }
      }
    }

    /**
     * Callback with Part Body from _fetchContentCallback.
     *
     * @private
     * @method _fetchContentComplete
     * @param {Blob|String} body
     * @param {Function} callback
     */

  }, {
    key: '_fetchContentComplete',
    value: function _fetchContentComplete(body, callback) {
      var message = this._getMessage();
      if (!message) return;

      // NOTE: This will trigger a messageparts:change event, and therefore a messages:change event
      this.body = body;

      this.trigger('content-loaded');

      // TODO: This event is now deprecated, and should be removed for WebSDK 4.0
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });

      if (callback) callback(this.body);
    }

    /**
     * Access the URL to the remote resource.
     *
     * Useful for streaming the content so that you don't have to download the entire file before rendering it.
     * Also useful for content that will be openned in a new window, and does not need to be fetched now.
     *
     * For MessageParts with Rich Content, will lookup a URL to your Rich Content.
     * Useful for streaming and content so that you don't have to download the entire file before rendering it.
     *
     * ```
     * messagepart.fetchStream(function(url) {
     *     render(url);
     * });
     * ```
     *
     * Note that a successful call to `fetchStream` will also cause Query change events to fire.
     * In this example, `render` will be called by the query change event that will occur once the `url` has been refreshed:
     *
     * ```
     *  query.on('change', function(evt) {
     *      render(query.data);
     *  });
     *  messagepart.fetchStream();
     * ```
     *
     * @method fetchStream
     * @param {Function} [callback]
     * @param {Mixed} callback.url
     * @return {layer.Content} this
     */

  }, {
    key: 'fetchStream',
    value: function fetchStream(callback) {
      var _this4 = this;

      if (!this._content) throw new Error(LayerError.dictionary.contentRequired);
      if (this._content.isExpired()) {
        this._content.refreshContent(this._getClient(), function (url) {
          return _this4._fetchStreamComplete(url, callback);
        });
      } else {
        this._fetchStreamComplete(this._content.downloadUrl, callback);
      }
      return this;
    }

    // Does not set this.url; instead relies on fact that this._content.downloadUrl has been updated

  }, {
    key: '_fetchStreamComplete',
    value: function _fetchStreamComplete(url, callback) {
      var message = this._getMessage();

      this.trigger('url-loaded');

      this._triggerAsync('messageparts:change', {
        oldValue: '',
        newValue: url,
        property: 'url'
      });

      // TODO: This event is now deprecated, and should be removed for WebSDK 4.0
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });
      if (callback) callback(url);
    }

    /**
     * Preps a MessagePart for sending.  Normally that is trivial.
     * But if there is rich content, then the content must be uploaded
     * and then we can trigger a "parts:send" event indicating that
     * the part is ready to send.
     *
     * @method _send
     * @protected
     * @param  {layer.Client} client
     * @fires parts:send
     */

  }, {
    key: '_send',
    value: function _send(client) {
      // There is already a Content object, presumably the developer
      // already took care of this step for us.
      if (this._content) {
        this._sendWithContent();
      }

      // If the size is large, Create and upload the Content
      else if (this.size > 2048) {
          this._generateContentAndSend(client);
        }

        // If the body is a blob, but is not YET Rich Content, do some custom analysis/processing:
        else if (Util.isBlob(this.body)) {
            this._sendBlob(client);
          }

          // Else the message part can be sent as is.
          else {
              this._sendBody();
            }
    }
  }, {
    key: '_sendBody',
    value: function _sendBody() {
      if (typeof this.body !== 'string') {
        var err = 'MessagePart.body must be a string in order to send it';
        logger.error(err, { mimeType: this.mimeType, body: this.body });
        throw new Error(err);
      }

      var obj = {
        mime_type: this.mimeType,
        body: this.body
      };
      this.trigger('parts:send', obj);
    }
  }, {
    key: '_sendWithContent',
    value: function _sendWithContent() {
      this.trigger('parts:send', {
        mime_type: this.mimeType,
        content: {
          size: this.size,
          id: this._content.id
        }
      });
    }

    /**
     * This method is only called if Blob.size < 2048.
     *
     * However, conversion to base64 can impact the size, so we must retest the size
     * after conversion, and then decide to send the original blob or the base64 encoded data.
     *
     * @method _sendBlob
     * @private
     * @param {layer.Client} client
     */

  }, {
    key: '_sendBlob',
    value: function _sendBlob(client) {
      var _this5 = this;

      /* istanbul ignore else */
      Util.blobToBase64(this.body, function (base64data) {
        if (base64data.length < 2048) {
          var body = base64data.substring(base64data.indexOf(',') + 1);
          var obj = {
            body: body,
            mime_type: _this5.mimeType
          };
          obj.encoding = 'base64';
          _this5.trigger('parts:send', obj);
        } else {
          _this5._generateContentAndSend(client);
        }
      });
    }

    /**
     * Create an rich Content object on the server
     * and then call _processContentResponse
     *
     * @method _generateContentAndSend
     * @private
     * @param  {layer.Client} client
     */

  }, {
    key: '_generateContentAndSend',
    value: function _generateContentAndSend(client) {
      var _this6 = this;

      this.hasContent = true;
      var body = void 0;
      if (!Util.isBlob(this.body)) {
        body = Util.base64ToBlob(Util.utoa(this.body), this.mimeType);
      } else {
        body = this.body;
      }
      client.xhr({
        url: '/content',
        method: 'POST',
        headers: {
          'Upload-Content-Type': this.mimeType,
          'Upload-Content-Length': body.size,
          'Upload-Origin': typeof location !== 'undefined' ? location.origin : ''
        },
        sync: {}
      }, function (result) {
        return _this6._processContentResponse(result.data, body, client);
      });
    }

    /**
     * Creates a layer.Content object from the server's
     * Content object, and then uploads the data to google cloud storage.
     *
     * @method _processContentResponse
     * @private
     * @param  {Object} response
     * @param  {Blob} body
     * @param  {layer.Client} client
     * @param {Number} [retryCount=0]
     */

  }, {
    key: '_processContentResponse',
    value: function _processContentResponse(response, body, client) {
      var _this7 = this;

      var retryCount = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

      this._content = new Content(response.id);
      this.hasContent = true;
      xhr({
        url: response.upload_url,
        method: 'PUT',
        data: body,
        headers: {
          'Upload-Content-Length': this.size,
          'Upload-Content-Type': this.mimeType
        }
      }, function (result) {
        return _this7._processContentUploadResponse(result, response, client, body, retryCount);
      });
    }

    /**
     * Process the response to uploading the content to google cloud storage.
     *
     * Result is either:
     *
     * 1. trigger `parts:send` on success
     * 2. call `_processContentResponse` to retry
     * 3. trigger `messages:sent-error` if retries have failed
     *
     * @method _processContentUploadResponse
     * @private
     * @param  {Object} uploadResult    Response from google cloud server; note that the xhr method assumes some layer-like behaviors and may replace non-json responses with js objects.
     * @param  {Object} contentResponse Response to `POST /content` from before
     * @param  {layer.Client} client
     * @param  {Blob} body
     * @param  {Number} retryCount
     */

  }, {
    key: '_processContentUploadResponse',
    value: function _processContentUploadResponse(uploadResult, contentResponse, client, body, retryCount) {
      if (!uploadResult.success) {
        if (!client.onlineManager.isOnline) {
          client.onlineManager.once('connected', this._processContentResponse.bind(this, contentResponse, client), this);
        } else if (retryCount < MessagePart.MaxRichContentRetryCount) {
          this._processContentResponse(contentResponse, body, client, retryCount + 1);
        } else {
          logger.error('Failed to upload rich content; triggering message:sent-error event; status of ', uploadResult.status, this);
          this._getMessage().trigger('messages:sent-error', {
            error: new LayerError({
              message: 'Upload of rich content failed',
              httpStatus: uploadResult.status,
              code: 0,
              data: uploadResult.xhr
            }),
            part: this
          });
        }
      } else {
        this.trigger('parts:send', {
          mime_type: this.mimeType,
          content: {
            size: this.size,
            id: this._content.id
          }
        });
      }
    }

    /**
     * Returns the text for any text/plain part.
     *
     * Returns '' if its not a text/plain part.
     *
     * @method getText
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      if (this.isTextualMimeType()) {
        return this.body;
      } else {
        return '';
      }
    }

    /**
     * Updates the MessagePart with new data from the server.
     *
     * Currently, MessagePart properties do not update... however,
     * the layer.Content object that Rich Content MessageParts contain
     * do get updated with refreshed expiring urls.
     *
     * @method _populateFromServer
     * @param  {Object} part - Server representation of a part
     * @private
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(part) {
      if (part.content && this._content) {
        this._content.downloadUrl = part.content.download_url;
        this._content.expiration = new Date(part.content.expiration);
      }
    }

    /**
     * Is the mimeType for this MessagePart defined as textual content?
     *
     * If the answer is true, expect a `body` of string, else expect `body` of Blob.
     *
     * To change whether a given MIME Type is treated as textual, see layer.MessagePart.TextualMimeTypes.
     *
     * @method isTextualMimeType
     * @returns {Boolean}
     */

  }, {
    key: 'isTextualMimeType',
    value: function isTextualMimeType() {
      var i = 0;
      for (i = 0; i < MessagePart.TextualMimeTypes.length; i++) {
        var test = MessagePart.TextualMimeTypes[i];
        if (typeof test === 'string') {
          if (test === this.mimeType) return true;
        } else if (test instanceof RegExp) {
          if (this.mimeType.match(test)) return true;
        }
      }
      return false;
    }

    /**
     * This method is automatically called any time the body is changed.
     *
     * Note that it is not called during initialization.  Any developer who does:
     *
     * ```
     * part.body = "Hi";
     * ```
     *
     * can expect this to trigger a change event, which will in turn trigger a `messages:change` event on the layer.Message.
     *
     * @method __updateBody
     * @private
     * @param {String} newValue
     * @param {String} oldValue
     */

  }, {
    key: '__updateBody',
    value: function __updateBody(newValue, oldValue) {
      this._triggerAsync('messageparts:change', {
        property: 'body',
        newValue: newValue,
        oldValue: oldValue
      });
    }

    /**
     * This method is automatically called any time the mimeType is changed.
     *
     * Note that it is not called during initialization.  Any developer who does:
     *
     * ```
     * part.mimeType = "text/mountain";
     * ```
     *
     * can expect this to trigger a change event, which will in turn trigger a `messages:change` event on the layer.Message.
     *
     * @method __updateMimeType
     * @private
     * @param {String} newValue
     * @param {String} oldValue
     */

  }, {
    key: '__updateMimeType',
    value: function __updateMimeType(newValue, oldValue) {
      this._triggerAsync('messageparts:change', {
        property: 'mimeType',
        newValue: newValue,
        oldValue: oldValue
      });
    }

    /**
     * Creates a MessagePart from a server representation of the part
     *
     * @method _createFromServer
     * @private
     * @static
     * @param  {Object} part - Server representation of a part
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(part) {
      var content = part.content ? Content._createFromServer(part.content) : null;

      // Turn base64 data into a Blob
      if (part.encoding === 'base64') part.body = Util.base64ToBlob(part.body, part.mimeType);

      // Create the MessagePart
      return new MessagePart({
        id: part.id,
        mimeType: part.mime_type,
        body: part.body || '',
        _content: content,
        hasContent: Boolean(content),
        size: part.size || 0
      });
    }
  }]);

  return MessagePart;
}(Root);

/**
 * layer.Client that the conversation belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */


MessagePart.prototype.clientId = '';

/**
 * Server generated identifier for the part
 * @type {string}
 */
MessagePart.prototype.id = '';

/**
 * Body of your message part.
 *
 * This is the core data of your part.
 *
 * If this is `null` then most likely layer.Message.hasContent is true, and you
 * can either use the layer.MessagePart.url property or the layer.MessagePart.fetchContent method.
 *
 * @type {string}
 */
MessagePart.prototype.body = null;

/**
 * Rich content object.
 *
 * This will be automatically created for you if your layer.MessagePart.body
 * is large.
 * @type {layer.Content}
 * @private
 */
MessagePart.prototype._content = null;

/**
 * The Part has rich content
 * @type {Boolean}
 */
MessagePart.prototype.hasContent = false;

/**
 * URL to rich content object.
 *
 * Parts with rich content will be initialized with this property set.  But its value will expire.
 *
 * Will contain an expiring url at initialization time and be refreshed with calls to `layer.MessagePart.fetchStream()`.
 * Will contain a non-expiring url to a local resource if `layer.MessagePart.fetchContent()` is called.
 *
 * @type {layer.Content}
 */
Object.defineProperty(MessagePart.prototype, 'url', {
  enumerable: true,
  get: function get() {
    // Its possible to have a url and no content if it has been instantiated but not yet sent.
    // If there is a __url then its a local url generated from the body property and does not expire.
    if (this.__url) return this.__url;
    if (this._content) return this._content.isExpired() ? '' : this._content.downloadUrl;
    return '';
  },
  set: function set(inValue) {
    this.__url = inValue;
  }
});

/**
 * Mime Type for the data represented by the MessagePart.
 *
 * Typically this is the type for the data in layer.MessagePart.body;
 * if there is Rich Content, then its the type of Content that needs to be
 * downloaded.
 *
 * @type {String}
 */
MessagePart.prototype.mimeType = 'text/plain';

/**
 * Size of the layer.MessagePart.body.
 *
 * Will be set for you if not provided.
 * Only needed for use with rich content.
 *
 * @type {number}
 */
MessagePart.prototype.size = 0;

/**
 * Array of mime types that should be treated as text.
 *
 * Treating a MessagePart as text means that even if the `body` gets a File or Blob,
 * it will be transformed to a string before being delivered to your app.
 *
 * This value can be customized using strings and regular expressions:
 *
 * ```
 * layer.MessagePart.TextualMimeTypes = ['text/plain', 'text/mountain', /^application\/json(\+.+)$/]
 * ```
 *
 * @static
 * @type {Mixed[]}
 */
MessagePart.TextualMimeTypes = [/^text\/.+$/, /^application\/json(\+.+)?$/];

/**
 * Number of retry attempts to make before giving up on uploading Rich Content to Google Cloud Storage.
 *
 * @type {Number}
 */
MessagePart.MaxRichContentRetryCount = 3;

MessagePart._supportedEvents = ['parts:send', 'content-loaded', 'url-loaded', 'content-loaded-error', 'messageparts:change'].concat(Root._supportedEvents);
Root.initClass.apply(MessagePart, [MessagePart, 'MessagePart']);

module.exports = MessagePart;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvbWVzc2FnZS1wYXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUVBLElBQU0sT0FBTyxRQUFRLFNBQVIsQ0FBYjtBQUNBLElBQU0sVUFBVSxRQUFRLFdBQVIsQ0FBaEI7QUFDQSxJQUFNLE1BQU0sUUFBUSxRQUFSLENBQVo7QUFDQSxJQUFNLGlCQUFpQixRQUFRLG9CQUFSLENBQXZCO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFNLE9BQU8sUUFBUSxpQkFBUixDQUFiO0FBQ0EsSUFBTSxTQUFTLFFBQVEsV0FBUixDQUFmOztJQUVNLFc7OztBQUVKOzs7Ozs7Ozs7OztBQVdBLHVCQUFZLE9BQVosRUFBOEI7QUFBQTs7QUFDNUIsUUFBSSxhQUFhLE9BQWpCO0FBQ0EsUUFBSSxPQUFPLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsbUJBQWEsRUFBRSxNQUFNLE9BQVIsRUFBYjtBQUNBLFVBQUkscURBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsbUJBQVcsUUFBWDtBQUNELE9BRkQsTUFFTztBQUNMLG1CQUFXLFFBQVgsR0FBc0IsWUFBdEI7QUFDRDtBQUNGLEtBUEQsTUFPTyxJQUFJLEtBQUssTUFBTCxDQUFZLE9BQVosS0FBd0IsS0FBSyxNQUFMLENBQVksUUFBUSxJQUFwQixDQUE1QixFQUF1RDtBQUM1RCxVQUFNLE9BQU8sbUJBQW1CLElBQW5CLEdBQTBCLE9BQTFCLEdBQW9DLFFBQVEsSUFBekQ7QUFDQSxVQUFNLFdBQVcsS0FBSyxNQUFMLENBQVksUUFBUSxJQUFwQixJQUE0QixRQUFRLFFBQXBDLEdBQStDLEtBQUssSUFBckU7QUFDQSxtQkFBYTtBQUNYLDBCQURXO0FBRVgsa0JBRlc7QUFHWCxjQUFNLEtBQUssSUFIQTtBQUlYLG9C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O0FBSUEsWUFBWSxTQUFaLENBQXNCLFVBQXRCLEdBQW1DLEtBQW5DOztBQUVBOzs7Ozs7Ozs7O0FBVUEsT0FBTyxjQUFQLENBQXNCLFlBQVksU0FBbEMsRUFBNkMsS0FBN0MsRUFBb0Q7QUFDbEQsY0FBWSxJQURzQztBQUVsRCxPQUFLLFNBQVMsR0FBVCxHQUFlO0FBQ2xCO0FBQ0E7QUFDQSxRQUFJLEtBQUssS0FBVCxFQUFnQixPQUFPLEtBQUssS0FBWjtBQUNoQixRQUFJLEtBQUssUUFBVCxFQUFtQixPQUFPLEtBQUssUUFBTCxDQUFjLFNBQWQsS0FBNEIsRUFBNUIsR0FBaUMsS0FBSyxRQUFMLENBQWMsV0FBdEQ7QUFDbkIsV0FBTyxFQUFQO0FBQ0QsR0FSaUQ7QUFTbEQsT0FBSyxTQUFTLEdBQVQsQ0FBYSxPQUFiLEVBQXNCO0FBQ3pCLFNBQUssS0FBTCxHQUFhLE9BQWI7QUFDRDtBQVhpRCxDQUFwRDs7QUFjQTs7Ozs7Ozs7O0FBU0EsWUFBWSxTQUFaLENBQXNCLFFBQXRCLEdBQWlDLFlBQWpDOztBQUVBOzs7Ozs7OztBQVFBLFlBQVksU0FBWixDQUFzQixJQUF0QixHQUE2QixDQUE3Qjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsWUFBWSxnQkFBWixHQUErQixDQUFDLFlBQUQsRUFBZSw0QkFBZixDQUEvQjs7QUFFQTs7Ozs7QUFLQSxZQUFZLHdCQUFaLEdBQXVDLENBQXZDOztBQUVBLFlBQVksZ0JBQVosR0FBK0IsQ0FDN0IsWUFENkIsRUFFN0IsZ0JBRjZCLEVBRzdCLFlBSDZCLEVBSTdCLHNCQUo2QixFQUs3QixxQkFMNkIsRUFNN0IsTUFONkIsQ0FNdEIsS0FBSyxnQkFOaUIsQ0FBL0I7QUFPQSxLQUFLLFNBQUwsQ0FBZSxLQUFmLENBQXFCLFdBQXJCLEVBQWtDLENBQUMsV0FBRCxFQUFjLGFBQWQsQ0FBbEM7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFdBQWpCIiwiZmlsZSI6Im1lc3NhZ2UtcGFydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIE1lc3NhZ2VQYXJ0IGNsYXNzIHJlcHJlc2VudHMgYW4gZWxlbWVudCBvZiBhIG1lc3NhZ2UuXG4gKlxuICogICAgICAvLyBDcmVhdGUgYSBNZXNzYWdlIFBhcnQgd2l0aCBhbnkgbWltZVR5cGVcbiAqICAgICAgdmFyIHBhcnQgPSBuZXcgbGF5ZXIuTWVzc2FnZVBhcnQoe1xuICogICAgICAgICAgYm9keTogXCJoZWxsb1wiLFxuICogICAgICAgICAgbWltZVR5cGU6IFwidGV4dC9wbGFpblwiXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gQ3JlYXRlIGEgdGV4dC9wbGFpbiBvbmx5IE1lc3NhZ2UgUGFydFxuICogICAgICB2YXIgcGFydCA9IG5ldyBsYXllci5NZXNzYWdlUGFydChcIkhlbGxvIEkgYW0gdGV4dC9wbGFpblwiKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3JlYXRlIGEgTWVzc2FnZSBQYXJ0IGZyb20gYSBGaWxlIElucHV0IGRvbSBub2RlOlxuICpcbiAqICAgICAgdmFyIGZpbGVJbnB1dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15RmlsZUlucHV0XCIpO1xuICogICAgICB2YXIgcGFydCA9IG5ldyBsYXllci5NZXNzYWdlUGFydChmaWxlSW5wdXROb2RlLmZpbGVzWzBdKTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gY3JlYXRlIE1lc3NhZ2UgUGFydHMgZnJvbSBhIGZpbGUgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb246XG4gKlxuICogICAgICBvbkZpbGVEcm9wOiBmdW5jdGlvbihldnQpIHtcbiAqICAgICAgICAgICB2YXIgZmlsZXMgPSBldnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICogICAgICAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2Uoe1xuICogICAgICAgICAgICAgICBwYXJ0czogZmlsZXMubWFwKGZ1bmN0aW9uKGZpbGUpIHtcbiAqICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsYXllci5NZXNzYWdlUGFydCh7Ym9keTogZmlsZSwgbWltZVR5cGU6IGZpbGUudHlwZX0pO1xuICogICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgfSk7XG4gKiAgICAgIH0pO1xuICpcbiAqICMjIyBCbG9icyB2cyBTdHJpbmdzXG4gKlxuICogWW91IHNob3VsZCBhbHdheXMgZXhwZWN0IHRvIHNlZSB0aGUgYGJvZHlgIHByb3BlcnR5IGJlIGEgQmxvYiAqKnVubGVzcyoqIHRoZSBtaW1lVHlwZSBpcyBsaXN0ZWQgaW4gbGF5ZXIuTWVzc2FnZVBhcnQuVGV4dHVhbE1pbWVUeXBlcyxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHZhbHVlIHdpbGwgYmUgYSBTdHJpbmcuICBZb3UgY2FuIGFkZCBtaW1lVHlwZXMgdG8gVGV4dHVhbE1pbWVUeXBlczpcbiAqXG4gKiBgYGBcbiAqIGxheWVyLk1lc3NhZ2VQYXJ0LlRleHR1YWxNaW1lVHlwZXMgPSBbJ3RleHQvcGxhaW4nLCAndGV4dC9tb3VudGFpbicsIC9eYXBwbGljYXRpb25cXC9qc29uKFxcKy4rKSQvXVxuICogYGBgXG4gKlxuICogQW55IG1pbWVUeXBlIG1hdGNoaW5nIHRoZSBhYm92ZSBzdHJpbmdzIGFuZCByZWd1bGFyIGV4cHJlc3Npb25zIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gdGV4dCBiZWZvcmUgYmVpbmcgZGVsaXZlcmVkIHRvIHlvdXIgYXBwOyBvdGhlcndpc2UgaXRcbiAqIG11c3QgYmUgYSBCbG9iLiAgTm90ZSB0aGF0IHRoZSBhYm92ZSBzbmlwcGV0IHNldHMgYSBzdGF0aWMgcHJvcGVydHkgdGhhdCBpcyBzZXQgb25jZSwgYW5kIGFmZmVjdHMgYWxsIE1lc3NhZ2VQYXJ0IG9iamVjdHMgZm9yIHRoZSBsaWZlc3BhbiBvZlxuICogdGhlIGFwcC5cbiAqXG4gKiAjIyMgQWNjZXNpbmcgUmljaCBDb250ZW50XG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIG9mIGFjY2Vzc2luZyByaWNoIGNvbnRlbnRcbiAqXG4gKiAxLiBBY2Nlc3MgdGhlIGRhdGEgZGlyZWN0bHk6IGBwYXJ0LmZldGNoQ29udGVudChmdW5jdGlvbihkYXRhKSB7bXlSZW5kZXJEYXRhKGRhdGEpO30pYC4gVGhpcyBhcHByb2FjaCBkb3dubG9hZHMgdGhlIGRhdGEsXG4gKiAgICB3cml0ZXMgaXQgdG8gdGhlIHRoZSBgYm9keWAgcHJvcGVydHksIHdyaXRlcyBhIERhdGEgVVJJIHRvIHRoZSBwYXJ0J3MgYHVybGAgcHJvcGVydHksIGFuZCB0aGVuIGNhbGxzIHlvdXIgY2FsbGJhY2suXG4gKiAgICBCeSBkb3dubG9hZGluZyB0aGUgZGF0YSBhbmQgc3RvcmluZyBpdCBpbiBgYm9keWAsIHRoZSBkYXRhIGRvZXMgbm90IGV4cGlyZS5cbiAqIDIuIEFjY2VzcyB0aGUgVVJMIHJhdGhlciB0aGFuIHRoZSBkYXRhLiAgV2hlbiB5b3UgZmlyc3QgcmVjZWl2ZSB0aGUgTWVzc2FnZSBQYXJ0IGl0IHdpbGwgaGF2ZSBhIHZhbGlkIGB1cmxgIHByb3BlcnR5OyBob3dldmVyLCB0aGlzIFVSTCBleHBpcmVzLiAgKiAgICBVUkxzIGFyZSBuZWVkZWQgZm9yIHN0cmVhbWluZywgYW5kIGZvciBjb250ZW50IHRoYXQgZG9lc24ndCB5ZXQgbmVlZCB0byBiZSByZW5kZXJlZCAoZS5nLiBoeXBlcmxpbmtzIHRvIGRhdGEgdGhhdCB3aWxsIHJlbmRlciB3aGVuIGNsaWNrZWQpLlxuICogICAgVGhlIHVybCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHN0cmluZyBpZiB0aGUgdXJsIGlzIHZhbGlkLCBvciAnJyBpZiBpdHMgZXhwaXJlZC4gIENhbGwgYHBhcnQuZmV0Y2hTdHJlYW0oY2FsbGJhY2spYCB0byBnZXQgYW4gdXBkYXRlZCBVUkwuXG4gKiAgICBUaGUgZm9sbG93aW5nIHBhdHRlcm4gaXMgcmVjb21tZW5kZWQ6XG4gKlxuICogYGBgXG4gKiBpZiAoIXBhcnQudXJsKSB7XG4gKiAgIHBhcnQuZmV0Y2hTdHJlYW0oZnVuY3Rpb24odXJsKSB7bXlSZW5kZXJVcmwodXJsKX0pO1xuICogfSBlbHNlIHtcbiAqICAgbXlSZW5kZXJVcmwocGFydC51cmwpO1xuICogfVxuICogYGBgXG4gKlxuICogTk9URTogYGxheWVyLk1lc3NhZ2VQYXJ0LnVybGAgc2hvdWxkIGhhdmUgYSB2YWx1ZSB3aGVuIHRoZSBtZXNzYWdlIGlzIGZpcnN0IHJlY2VpdmVkLCBhbmQgd2lsbCBvbmx5IGZhaWwgYGlmICghcGFydC51cmwpYCBvbmNlIHRoZSB1cmwgaGFzIGV4cGlyZWQuXG4gKlxuICogQGNsYXNzICBsYXllci5NZXNzYWdlUGFydFxuICogQGV4dGVuZHMgbGF5ZXIuUm9vdFxuICogQGF1dGhvciBNaWNoYWVsIEthbnRvclxuICovXG5cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuLi9yb290Jyk7XG5jb25zdCBDb250ZW50ID0gcmVxdWlyZSgnLi9jb250ZW50Jyk7XG5jb25zdCB4aHIgPSByZXF1aXJlKCcuLi94aHInKTtcbmNvbnN0IENsaWVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vY2xpZW50LXJlZ2lzdHJ5Jyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi9jbGllbnQtdXRpbHMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG5jbGFzcyBNZXNzYWdlUGFydCBleHRlbmRzIFJvb3Qge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIENhbiBiZSBhbiBvYmplY3Qgd2l0aCBib2R5IGFuZCBtaW1lVHlwZSwgb3IgaXQgY2FuIGJlIGEgc3RyaW5nLCBvciBhIEJsb2IvRmlsZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG9wdGlvbnMuYm9keSAtIEFueSBzdHJpbmcgbGFyZ2VyIHRoYW4gMmtiIHdpbGwgYmUgc2VudCBhcyBSaWNoIENvbnRlbnQsIG1lYW5pbmcgaXQgd2lsbCBiZSB1cGxvYWRlZCB0byBjbG91ZCBzdG9yYWdlIGFuZCBtdXN0IGJlIHNlcGFyYXRlbHkgZG93bmxvYWRlZCBmcm9tIHRoZSBNZXNzYWdlIHdoZW4gaXRzIHJlY2VpdmVkLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHRpb25zLm1pbWVUeXBlPXRleHQvcGxhaW5dIC0gTWltZSB0eXBlOyBjYW4gYmUgYW55dGhpbmc7IGlmIHlvdXIgY2xpZW50IGRvZXNuJ3QgaGF2ZSBhIHJlbmRlcmVyIGZvciBpdCwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLnNpemU9MF0gLSBTaXplIG9mIHlvdXIgcGFydC4gV2lsbCBiZSBjYWxjdWxhdGVkIGZvciB5b3UgaWYgbm90IHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlUGFydH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICBsZXQgbmV3T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgbmV3T3B0aW9ucyA9IHsgYm9keTogb3B0aW9ucyB9O1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXdPcHRpb25zLm1pbWVUeXBlID0gYXJnc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09wdGlvbnMubWltZVR5cGUgPSAndGV4dC9wbGFpbic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzQmxvYihvcHRpb25zKSB8fCBVdGlsLmlzQmxvYihvcHRpb25zLmJvZHkpKSB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucyBpbnN0YW5jZW9mIEJsb2IgPyBvcHRpb25zIDogb3B0aW9ucy5ib2R5O1xuICAgICAgY29uc3QgbWltZVR5cGUgPSBVdGlsLmlzQmxvYihvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5taW1lVHlwZSA6IGJvZHkudHlwZTtcbiAgICAgIG5ld09wdGlvbnMgPSB7XG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBib2R5LFxuICAgICAgICBzaXplOiBib2R5LnNpemUsXG4gICAgICAgIGhhc0NvbnRlbnQ6IHRydWUsXG4gICAgICB9O1xuICAgIH1cbiAgICBzdXBlcihuZXdPcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuc2l6ZSAmJiB0aGlzLmJvZHkpIHRoaXMuc2l6ZSA9IHRoaXMuYm9keS5sZW5ndGg7XG5cbiAgICAvLyBEb24ndCBleHBvc2UgZW5jb2Rpbmc7IGJsb2JpZnkgaXQgaWYgaXRzIGVuY29kZWQuXG4gICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICB0aGlzLmJvZHkgPSBVdGlsLmJhc2U2NFRvQmxvYih0aGlzLmJvZHkpO1xuICAgIH1cblxuICAgIC8vIENvdWxkIGJlIGEgYmxvYiBiZWNhdXNlIGl0IHdhcyByZWFkIG91dCBvZiBpbmRleGVkREIsXG4gICAgLy8gb3IgYmVjYXVzZSBpdCB3YXMgY3JlYXRlZCBsb2NhbGx5IHdpdGggYSBmaWxlXG4gICAgLy8gT3IgYmVjYXVzZSBvZiBiYXNlNjQgZW5jb2RlZCBkYXRhLlxuICAgIGNvbnN0IGlzQmxvYkJvZHkgPSBVdGlsLmlzQmxvYih0aGlzLmJvZHkpO1xuICAgIGNvbnN0IHRleHR1YWwgPSB0aGlzLmlzVGV4dHVhbE1pbWVUeXBlKCk7XG5cbiAgICAvLyBDdXN0b20gaGFuZGxpbmcgZm9yIG5vbi10ZXh0dWFsIGNvbnRlbnRcbiAgICBpZiAoIXRleHR1YWwpIHtcbiAgICAgIC8vIElmIHRoZSBib2R5IGV4aXN0cyBhbmQgaXMgYSBibG9iLCBleHRyYWN0IHRoZSBkYXRhIHVyaSBmb3IgY29udmVuaWVuY2U7IG9ubHkgcmVhbGx5IHJlbGV2YW50IGZvciBpbWFnZSBhbmQgdmlkZW8gSFRNTCB0YWdzLlxuICAgICAgaWYgKCFpc0Jsb2JCb2R5ICYmIHRoaXMuYm9keSkgdGhpcy5ib2R5ID0gbmV3IEJsb2IoW3RoaXMuYm9keV0sIHsgdHlwZTogdGhpcy5taW1lVHlwZSB9KTtcbiAgICAgIGlmICh0aGlzLmJvZHkpIHRoaXMudXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmJvZHkpO1xuICAgIH1cblxuICAgIC8vIElmIG91ciB0ZXh0dWFsIGNvbnRlbnQgaXMgYSBibG9iLCB0dXJuaW5nIGl0IGludG8gdGV4dCBpcyBhc3ljaHJvbm91cywgYW5kIGNhbid0IGJlIGRvbmUgaW4gdGhlIHN5bmNocm9ub3VzIGNvbnN0cnVjdG9yXG4gICAgLy8gVGhpcyB3aWxsIG9ubHkgaGFwcGVuIHdoZW4gdGhlIGNsaWVudCBpcyBhdHRhY2hpbmcgYSBmaWxlLiAgQ29udmVyc2lvbiBmb3IgbG9jYWxseSBjcmVhdGVkIG1lc3NhZ2VzIGlzIGRvbmUgd2hpbGUgY2FsbGluZyBgTWVzc2FnZS5zZW5kKClgXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9fdXJsKSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuX191cmwpO1xuICAgICAgdGhpcy5fX3VybCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIuQ2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheWVyLk1lc3NhZ2VQYXJ0LlxuICAgKlxuICAgKiBVc2VzIHRoZSBsYXllci5NZXNzYWdlUGFydC5jbGllbnRJZCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0Q2xpZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudH1cbiAgICovXG4gIF9nZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIENsaWVudFJlZ2lzdHJ5LmdldCh0aGlzLmNsaWVudElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyLk1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5ZXIuTWVzc2FnZVBhcnQuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldE1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIF9nZXRNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDbGllbnQoKS5nZXRNZXNzYWdlKHRoaXMuaWQucmVwbGFjZSgvXFwvcGFydHMuKiQvLCAnJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkIFJpY2ggQ29udGVudCBmcm9tIGNsb3VkIHNlcnZlci5cbiAgICpcbiAgICogRm9yIE1lc3NhZ2VQYXJ0cyB3aXRoIHJpY2ggY29udGVudCwgdGhpcyBtZXRob2Qgd2lsbCBsb2FkIHRoZSBkYXRhIGZyb20gZ29vZ2xlJ3MgY2xvdWQgc3RvcmFnZS5cbiAgICogVGhlIGJvZHkgcHJvcGVydHkgb2YgdGhpcyBNZXNzYWdlUGFydCBpcyBzZXQgdG8gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogICAgICBtZXNzYWdlcGFydC5mZXRjaENvbnRlbnQoKVxuICAgKiAgICAgIC5vbihcImNvbnRlbnQtbG9hZGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICByZW5kZXIobWVzc2FnZXBhcnQuYm9keSk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBgZmV0Y2hDb250ZW50YCB3aWxsIGFsc28gY2F1c2UgUXVlcnkgY2hhbmdlIGV2ZW50cyB0byBmaXJlLlxuICAgKiBJbiB0aGlzIGV4YW1wbGUsIGByZW5kZXJgIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBxdWVyeSBjaGFuZ2UgZXZlbnQgdGhhdCB3aWxsIG9jY3VyIG9uY2UgdGhlIGNvbnRlbnQgaGFzIGRvd25sb2FkZWQ6XG4gICAqXG4gICAqIGBgYFxuICAgKiAgcXVlcnkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICByZW5kZXIocXVlcnkuZGF0YSk7XG4gICAqICB9KTtcbiAgICogIG1lc3NhZ2VwYXJ0LmZldGNoQ29udGVudCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICpcbiAgICogQG1ldGhvZCBmZXRjaENvbnRlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge01peGVkfSBjYWxsYmFjay5kYXRhIC0gRWl0aGVyIGEgc3RyaW5nIChtaW1lVHlwZT10ZXh0L3BsYWluKSBvciBhIEJsb2IgKGFsbCBvdGhlciBtaW1lVHlwZXMpXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnRlbnR9IHRoaXNcbiAgICovXG4gIGZldGNoQ29udGVudChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9jb250ZW50ICYmICF0aGlzLmlzRmlyaW5nKSB7XG4gICAgICB0aGlzLmlzRmlyaW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLm1pbWVUeXBlID09PSAnaW1hZ2UvanBlZytwcmV2aWV3JyA/ICdpbWFnZS9qcGVnJyA6IHRoaXMubWltZVR5cGU7XG4gICAgICB0aGlzLl9jb250ZW50LmxvYWRDb250ZW50KHR5cGUsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQpIHRoaXMuX2ZldGNoQ29udGVudENhbGxiYWNrKGVyciwgcmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB3aXRoIHJlc3VsdCBvciBlcnJvciBmcm9tIGNhbGxpbmcgZmV0Y2hDb250ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9mZXRjaENvbnRlbnRDYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXJyb3J9IGVyclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfZmV0Y2hDb250ZW50Q2FsbGJhY2soZXJyLCByZXN1bHQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb250ZW50LWxvYWRlZC1lcnJvcicsIGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNGaXJpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzVGV4dHVhbE1pbWVUeXBlKCkpIHtcbiAgICAgICAgVXRpbC5mZXRjaFRleHRGcm9tRmlsZShyZXN1bHQsIHRleHQgPT4gdGhpcy5fZmV0Y2hDb250ZW50Q29tcGxldGUodGV4dCwgY2FsbGJhY2spKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQpO1xuICAgICAgICB0aGlzLl9mZXRjaENvbnRlbnRDb21wbGV0ZShyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgd2l0aCBQYXJ0IEJvZHkgZnJvbSBfZmV0Y2hDb250ZW50Q2FsbGJhY2suXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX2ZldGNoQ29udGVudENvbXBsZXRlXG4gICAqIEBwYXJhbSB7QmxvYnxTdHJpbmd9IGJvZHlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF9mZXRjaENvbnRlbnRDb21wbGV0ZShib2R5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9nZXRNZXNzYWdlKCk7XG4gICAgaWYgKCFtZXNzYWdlKSByZXR1cm47XG5cbiAgICAvLyBOT1RFOiBUaGlzIHdpbGwgdHJpZ2dlciBhIG1lc3NhZ2VwYXJ0czpjaGFuZ2UgZXZlbnQsIGFuZCB0aGVyZWZvcmUgYSBtZXNzYWdlczpjaGFuZ2UgZXZlbnRcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy50cmlnZ2VyKCdjb250ZW50LWxvYWRlZCcpO1xuXG4gICAgLy8gVE9ETzogVGhpcyBldmVudCBpcyBub3cgZGVwcmVjYXRlZCwgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZvciBXZWJTREsgNC4wXG4gICAgbWVzc2FnZS5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlczpjaGFuZ2UnLCB7XG4gICAgICBvbGRWYWx1ZTogbWVzc2FnZS5wYXJ0cyxcbiAgICAgIG5ld1ZhbHVlOiBtZXNzYWdlLnBhcnRzLFxuICAgICAgcHJvcGVydHk6ICdwYXJ0cycsXG4gICAgfSk7XG5cbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMuYm9keSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBY2Nlc3MgdGhlIFVSTCB0byB0aGUgcmVtb3RlIHJlc291cmNlLlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIHN0cmVhbWluZyB0aGUgY29udGVudCBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGRvd25sb2FkIHRoZSBlbnRpcmUgZmlsZSBiZWZvcmUgcmVuZGVyaW5nIGl0LlxuICAgKiBBbHNvIHVzZWZ1bCBmb3IgY29udGVudCB0aGF0IHdpbGwgYmUgb3Blbm5lZCBpbiBhIG5ldyB3aW5kb3csIGFuZCBkb2VzIG5vdCBuZWVkIHRvIGJlIGZldGNoZWQgbm93LlxuICAgKlxuICAgKiBGb3IgTWVzc2FnZVBhcnRzIHdpdGggUmljaCBDb250ZW50LCB3aWxsIGxvb2t1cCBhIFVSTCB0byB5b3VyIFJpY2ggQ29udGVudC5cbiAgICogVXNlZnVsIGZvciBzdHJlYW1pbmcgYW5kIGNvbnRlbnQgc28gdGhhdCB5b3UgZG9uJ3QgaGF2ZSB0byBkb3dubG9hZCB0aGUgZW50aXJlIGZpbGUgYmVmb3JlIHJlbmRlcmluZyBpdC5cbiAgICpcbiAgICogYGBgXG4gICAqIG1lc3NhZ2VwYXJ0LmZldGNoU3RyZWFtKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgcmVuZGVyKHVybCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGBmZXRjaFN0cmVhbWAgd2lsbCBhbHNvIGNhdXNlIFF1ZXJ5IGNoYW5nZSBldmVudHMgdG8gZmlyZS5cbiAgICogSW4gdGhpcyBleGFtcGxlLCBgcmVuZGVyYCB3aWxsIGJlIGNhbGxlZCBieSB0aGUgcXVlcnkgY2hhbmdlIGV2ZW50IHRoYXQgd2lsbCBvY2N1ciBvbmNlIHRoZSBgdXJsYCBoYXMgYmVlbiByZWZyZXNoZWQ6XG4gICAqXG4gICAqIGBgYFxuICAgKiAgcXVlcnkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgIHJlbmRlcihxdWVyeS5kYXRhKTtcbiAgICogIH0pO1xuICAgKiAgbWVzc2FnZXBhcnQuZmV0Y2hTdHJlYW0oKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBtZXRob2QgZmV0Y2hTdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge01peGVkfSBjYWxsYmFjay51cmxcbiAgICogQHJldHVybiB7bGF5ZXIuQ29udGVudH0gdGhpc1xuICAgKi9cbiAgZmV0Y2hTdHJlYW0oY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY29udGVudFJlcXVpcmVkKTtcbiAgICBpZiAodGhpcy5fY29udGVudC5pc0V4cGlyZWQoKSkge1xuICAgICAgdGhpcy5fY29udGVudC5yZWZyZXNoQ29udGVudCh0aGlzLl9nZXRDbGllbnQoKSwgdXJsID0+IHRoaXMuX2ZldGNoU3RyZWFtQ29tcGxldGUodXJsLCBjYWxsYmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mZXRjaFN0cmVhbUNvbXBsZXRlKHRoaXMuX2NvbnRlbnQuZG93bmxvYWRVcmwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBEb2VzIG5vdCBzZXQgdGhpcy51cmw7IGluc3RlYWQgcmVsaWVzIG9uIGZhY3QgdGhhdCB0aGlzLl9jb250ZW50LmRvd25sb2FkVXJsIGhhcyBiZWVuIHVwZGF0ZWRcbiAgX2ZldGNoU3RyZWFtQ29tcGxldGUodXJsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9nZXRNZXNzYWdlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3VybC1sb2FkZWQnKTtcblxuICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXBhcnRzOmNoYW5nZScsIHtcbiAgICAgIG9sZFZhbHVlOiAnJyxcbiAgICAgIG5ld1ZhbHVlOiB1cmwsXG4gICAgICBwcm9wZXJ0eTogJ3VybCcsXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBUaGlzIGV2ZW50IGlzIG5vdyBkZXByZWNhdGVkLCBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgZm9yIFdlYlNESyA0LjBcbiAgICBtZXNzYWdlLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgIG9sZFZhbHVlOiBtZXNzYWdlLnBhcnRzLFxuICAgICAgbmV3VmFsdWU6IG1lc3NhZ2UucGFydHMsXG4gICAgICBwcm9wZXJ0eTogJ3BhcnRzJyxcbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHVybCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHMgYSBNZXNzYWdlUGFydCBmb3Igc2VuZGluZy4gIE5vcm1hbGx5IHRoYXQgaXMgdHJpdmlhbC5cbiAgICogQnV0IGlmIHRoZXJlIGlzIHJpY2ggY29udGVudCwgdGhlbiB0aGUgY29udGVudCBtdXN0IGJlIHVwbG9hZGVkXG4gICAqIGFuZCB0aGVuIHdlIGNhbiB0cmlnZ2VyIGEgXCJwYXJ0czpzZW5kXCIgZXZlbnQgaW5kaWNhdGluZyB0aGF0XG4gICAqIHRoZSBwYXJ0IGlzIHJlYWR5IHRvIHNlbmQuXG4gICAqXG4gICAqIEBtZXRob2QgX3NlbmRcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAZmlyZXMgcGFydHM6c2VuZFxuICAgKi9cbiAgX3NlbmQoY2xpZW50KSB7XG4gICAgLy8gVGhlcmUgaXMgYWxyZWFkeSBhIENvbnRlbnQgb2JqZWN0LCBwcmVzdW1hYmx5IHRoZSBkZXZlbG9wZXJcbiAgICAvLyBhbHJlYWR5IHRvb2sgY2FyZSBvZiB0aGlzIHN0ZXAgZm9yIHVzLlxuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9zZW5kV2l0aENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBpcyBsYXJnZSwgQ3JlYXRlIGFuZCB1cGxvYWQgdGhlIENvbnRlbnRcbiAgICBlbHNlIGlmICh0aGlzLnNpemUgPiAyMDQ4KSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZUNvbnRlbnRBbmRTZW5kKGNsaWVudCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGJvZHkgaXMgYSBibG9iLCBidXQgaXMgbm90IFlFVCBSaWNoIENvbnRlbnQsIGRvIHNvbWUgY3VzdG9tIGFuYWx5c2lzL3Byb2Nlc3Npbmc6XG4gICAgZWxzZSBpZiAoVXRpbC5pc0Jsb2IodGhpcy5ib2R5KSkge1xuICAgICAgdGhpcy5fc2VuZEJsb2IoY2xpZW50KTtcbiAgICB9XG5cbiAgICAvLyBFbHNlIHRoZSBtZXNzYWdlIHBhcnQgY2FuIGJlIHNlbnQgYXMgaXMuXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZW5kQm9keSgpO1xuICAgIH1cbiAgfVxuXG4gIF9zZW5kQm9keSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVyciA9ICdNZXNzYWdlUGFydC5ib2R5IG11c3QgYmUgYSBzdHJpbmcgaW4gb3JkZXIgdG8gc2VuZCBpdCc7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyLCB7IG1pbWVUeXBlOiB0aGlzLm1pbWVUeXBlLCBib2R5OiB0aGlzLmJvZHkgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBtaW1lX3R5cGU6IHRoaXMubWltZVR5cGUsXG4gICAgICBib2R5OiB0aGlzLmJvZHksXG4gICAgfTtcbiAgICB0aGlzLnRyaWdnZXIoJ3BhcnRzOnNlbmQnLCBvYmopO1xuICB9XG5cbiAgX3NlbmRXaXRoQ29udGVudCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3BhcnRzOnNlbmQnLCB7XG4gICAgICBtaW1lX3R5cGU6IHRoaXMubWltZVR5cGUsXG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgaWQ6IHRoaXMuX2NvbnRlbnQuaWQsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkIGlmIEJsb2Iuc2l6ZSA8IDIwNDguXG4gICAqXG4gICAqIEhvd2V2ZXIsIGNvbnZlcnNpb24gdG8gYmFzZTY0IGNhbiBpbXBhY3QgdGhlIHNpemUsIHNvIHdlIG11c3QgcmV0ZXN0IHRoZSBzaXplXG4gICAqIGFmdGVyIGNvbnZlcnNpb24sIGFuZCB0aGVuIGRlY2lkZSB0byBzZW5kIHRoZSBvcmlnaW5hbCBibG9iIG9yIHRoZSBiYXNlNjQgZW5jb2RlZCBkYXRhLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zZW5kQmxvYlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqL1xuICBfc2VuZEJsb2IoY2xpZW50KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBVdGlsLmJsb2JUb0Jhc2U2NCh0aGlzLmJvZHksIChiYXNlNjRkYXRhKSA9PiB7XG4gICAgICBpZiAoYmFzZTY0ZGF0YS5sZW5ndGggPCAyMDQ4KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBiYXNlNjRkYXRhLnN1YnN0cmluZyhiYXNlNjRkYXRhLmluZGV4T2YoJywnKSArIDEpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBtaW1lX3R5cGU6IHRoaXMubWltZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIG9iai5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhcnRzOnNlbmQnLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVDb250ZW50QW5kU2VuZChjbGllbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiByaWNoIENvbnRlbnQgb2JqZWN0IG9uIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHRoZW4gY2FsbCBfcHJvY2Vzc0NvbnRlbnRSZXNwb25zZVxuICAgKlxuICAgKiBAbWV0aG9kIF9nZW5lcmF0ZUNvbnRlbnRBbmRTZW5kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqL1xuICBfZ2VuZXJhdGVDb250ZW50QW5kU2VuZChjbGllbnQpIHtcbiAgICB0aGlzLmhhc0NvbnRlbnQgPSB0cnVlO1xuICAgIGxldCBib2R5O1xuICAgIGlmICghVXRpbC5pc0Jsb2IodGhpcy5ib2R5KSkge1xuICAgICAgYm9keSA9IFV0aWwuYmFzZTY0VG9CbG9iKFV0aWwudXRvYSh0aGlzLmJvZHkpLCB0aGlzLm1pbWVUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHRoaXMuYm9keTtcbiAgICB9XG4gICAgY2xpZW50Lnhocih7XG4gICAgICB1cmw6ICcvY29udGVudCcsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1VwbG9hZC1Db250ZW50LVR5cGUnOiB0aGlzLm1pbWVUeXBlLFxuICAgICAgICAnVXBsb2FkLUNvbnRlbnQtTGVuZ3RoJzogYm9keS5zaXplLFxuICAgICAgICAnVXBsb2FkLU9yaWdpbic6IHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhdGlvbi5vcmlnaW4gOiAnJyxcbiAgICAgIH0sXG4gICAgICBzeW5jOiB7fSxcbiAgICB9LCByZXN1bHQgPT4gdGhpcy5fcHJvY2Vzc0NvbnRlbnRSZXNwb25zZShyZXN1bHQuZGF0YSwgYm9keSwgY2xpZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxheWVyLkNvbnRlbnQgb2JqZWN0IGZyb20gdGhlIHNlcnZlcidzXG4gICAqIENvbnRlbnQgb2JqZWN0LCBhbmQgdGhlbiB1cGxvYWRzIHRoZSBkYXRhIHRvIGdvb2dsZSBjbG91ZCBzdG9yYWdlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9wcm9jZXNzQ29udGVudFJlc3BvbnNlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHBhcmFtICB7QmxvYn0gYm9keVxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3JldHJ5Q291bnQ9MF1cbiAgICovXG4gIF9wcm9jZXNzQ29udGVudFJlc3BvbnNlKHJlc3BvbnNlLCBib2R5LCBjbGllbnQsIHJldHJ5Q291bnQgPSAwKSB7XG4gICAgdGhpcy5fY29udGVudCA9IG5ldyBDb250ZW50KHJlc3BvbnNlLmlkKTtcbiAgICB0aGlzLmhhc0NvbnRlbnQgPSB0cnVlO1xuICAgIHhocih7XG4gICAgICB1cmw6IHJlc3BvbnNlLnVwbG9hZF91cmwsXG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgZGF0YTogYm9keSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1VwbG9hZC1Db250ZW50LUxlbmd0aCc6IHRoaXMuc2l6ZSxcbiAgICAgICAgJ1VwbG9hZC1Db250ZW50LVR5cGUnOiB0aGlzLm1pbWVUeXBlLFxuICAgICAgfSxcbiAgICB9LCByZXN1bHQgPT4gdGhpcy5fcHJvY2Vzc0NvbnRlbnRVcGxvYWRSZXNwb25zZShyZXN1bHQsIHJlc3BvbnNlLCBjbGllbnQsIGJvZHksIHJldHJ5Q291bnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSByZXNwb25zZSB0byB1cGxvYWRpbmcgdGhlIGNvbnRlbnQgdG8gZ29vZ2xlIGNsb3VkIHN0b3JhZ2UuXG4gICAqXG4gICAqIFJlc3VsdCBpcyBlaXRoZXI6XG4gICAqXG4gICAqIDEuIHRyaWdnZXIgYHBhcnRzOnNlbmRgIG9uIHN1Y2Nlc3NcbiAgICogMi4gY2FsbCBgX3Byb2Nlc3NDb250ZW50UmVzcG9uc2VgIHRvIHJldHJ5XG4gICAqIDMuIHRyaWdnZXIgYG1lc3NhZ2VzOnNlbnQtZXJyb3JgIGlmIHJldHJpZXMgaGF2ZSBmYWlsZWRcbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc0NvbnRlbnRVcGxvYWRSZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHVwbG9hZFJlc3VsdCAgICBSZXNwb25zZSBmcm9tIGdvb2dsZSBjbG91ZCBzZXJ2ZXI7IG5vdGUgdGhhdCB0aGUgeGhyIG1ldGhvZCBhc3N1bWVzIHNvbWUgbGF5ZXItbGlrZSBiZWhhdmlvcnMgYW5kIG1heSByZXBsYWNlIG5vbi1qc29uIHJlc3BvbnNlcyB3aXRoIGpzIG9iamVjdHMuXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGVudFJlc3BvbnNlIFJlc3BvbnNlIHRvIGBQT1NUIC9jb250ZW50YCBmcm9tIGJlZm9yZVxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcGFyYW0gIHtCbG9ifSBib2R5XG4gICAqIEBwYXJhbSAge051bWJlcn0gcmV0cnlDb3VudFxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZW50VXBsb2FkUmVzcG9uc2UodXBsb2FkUmVzdWx0LCBjb250ZW50UmVzcG9uc2UsIGNsaWVudCwgYm9keSwgcmV0cnlDb3VudCkge1xuICAgIGlmICghdXBsb2FkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGlmICghY2xpZW50Lm9ubGluZU1hbmFnZXIuaXNPbmxpbmUpIHtcbiAgICAgICAgY2xpZW50Lm9ubGluZU1hbmFnZXIub25jZSgnY29ubmVjdGVkJywgdGhpcy5fcHJvY2Vzc0NvbnRlbnRSZXNwb25zZS5iaW5kKHRoaXMsIGNvbnRlbnRSZXNwb25zZSwgY2xpZW50KSwgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHJldHJ5Q291bnQgPCBNZXNzYWdlUGFydC5NYXhSaWNoQ29udGVudFJldHJ5Q291bnQpIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0NvbnRlbnRSZXNwb25zZShjb250ZW50UmVzcG9uc2UsIGJvZHksIGNsaWVudCwgcmV0cnlDb3VudCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIHJpY2ggY29udGVudDsgdHJpZ2dlcmluZyBtZXNzYWdlOnNlbnQtZXJyb3IgZXZlbnQ7IHN0YXR1cyBvZiAnLCB1cGxvYWRSZXN1bHQuc3RhdHVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fZ2V0TWVzc2FnZSgpLnRyaWdnZXIoJ21lc3NhZ2VzOnNlbnQtZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3I6IG5ldyBMYXllckVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVcGxvYWQgb2YgcmljaCBjb250ZW50IGZhaWxlZCcsXG4gICAgICAgICAgICBodHRwU3RhdHVzOiB1cGxvYWRSZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgIGRhdGE6IHVwbG9hZFJlc3VsdC54aHIsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgcGFydDogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcigncGFydHM6c2VuZCcsIHtcbiAgICAgICAgbWltZV90eXBlOiB0aGlzLm1pbWVUeXBlLFxuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICAgIGlkOiB0aGlzLl9jb250ZW50LmlkLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgZm9yIGFueSB0ZXh0L3BsYWluIHBhcnQuXG4gICAqXG4gICAqIFJldHVybnMgJycgaWYgaXRzIG5vdCBhIHRleHQvcGxhaW4gcGFydC5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRUZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgaWYgKHRoaXMuaXNUZXh0dWFsTWltZVR5cGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBNZXNzYWdlUGFydCB3aXRoIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ3VycmVudGx5LCBNZXNzYWdlUGFydCBwcm9wZXJ0aWVzIGRvIG5vdCB1cGRhdGUuLi4gaG93ZXZlcixcbiAgICogdGhlIGxheWVyLkNvbnRlbnQgb2JqZWN0IHRoYXQgUmljaCBDb250ZW50IE1lc3NhZ2VQYXJ0cyBjb250YWluXG4gICAqIGRvIGdldCB1cGRhdGVkIHdpdGggcmVmcmVzaGVkIGV4cGlyaW5nIHVybHMuXG4gICAqXG4gICAqIEBtZXRob2QgX3BvcHVsYXRlRnJvbVNlcnZlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcnQgLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgYSBwYXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9wdWxhdGVGcm9tU2VydmVyKHBhcnQpIHtcbiAgICBpZiAocGFydC5jb250ZW50ICYmIHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuZG93bmxvYWRVcmwgPSBwYXJ0LmNvbnRlbnQuZG93bmxvYWRfdXJsO1xuICAgICAgdGhpcy5fY29udGVudC5leHBpcmF0aW9uID0gbmV3IERhdGUocGFydC5jb250ZW50LmV4cGlyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgbWltZVR5cGUgZm9yIHRoaXMgTWVzc2FnZVBhcnQgZGVmaW5lZCBhcyB0ZXh0dWFsIGNvbnRlbnQ/XG4gICAqXG4gICAqIElmIHRoZSBhbnN3ZXIgaXMgdHJ1ZSwgZXhwZWN0IGEgYGJvZHlgIG9mIHN0cmluZywgZWxzZSBleHBlY3QgYGJvZHlgIG9mIEJsb2IuXG4gICAqXG4gICAqIFRvIGNoYW5nZSB3aGV0aGVyIGEgZ2l2ZW4gTUlNRSBUeXBlIGlzIHRyZWF0ZWQgYXMgdGV4dHVhbCwgc2VlIGxheWVyLk1lc3NhZ2VQYXJ0LlRleHR1YWxNaW1lVHlwZXMuXG4gICAqXG4gICAqIEBtZXRob2QgaXNUZXh0dWFsTWltZVR5cGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1RleHR1YWxNaW1lVHlwZSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IE1lc3NhZ2VQYXJ0LlRleHR1YWxNaW1lVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRlc3QgPSBNZXNzYWdlUGFydC5UZXh0dWFsTWltZVR5cGVzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVzdCA9PT0gdGhpcy5taW1lVHlwZSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRlc3QgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKHRoaXMubWltZVR5cGUubWF0Y2godGVzdCkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYW55IHRpbWUgdGhlIGJvZHkgaXMgY2hhbmdlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGl0IGlzIG5vdCBjYWxsZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAgQW55IGRldmVsb3BlciB3aG8gZG9lczpcbiAgICpcbiAgICogYGBgXG4gICAqIHBhcnQuYm9keSA9IFwiSGlcIjtcbiAgICogYGBgXG4gICAqXG4gICAqIGNhbiBleHBlY3QgdGhpcyB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCB3aGljaCB3aWxsIGluIHR1cm4gdHJpZ2dlciBhIGBtZXNzYWdlczpjaGFuZ2VgIGV2ZW50IG9uIHRoZSBsYXllci5NZXNzYWdlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9fdXBkYXRlQm9keVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3VmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9sZFZhbHVlXG4gICAqL1xuICBfX3VwZGF0ZUJvZHkobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlcGFydHM6Y2hhbmdlJywge1xuICAgICAgcHJvcGVydHk6ICdib2R5JyxcbiAgICAgIG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYW55IHRpbWUgdGhlIG1pbWVUeXBlIGlzIGNoYW5nZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpdCBpcyBub3QgY2FsbGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gIEFueSBkZXZlbG9wZXIgd2hvIGRvZXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBwYXJ0Lm1pbWVUeXBlID0gXCJ0ZXh0L21vdW50YWluXCI7XG4gICAqIGBgYFxuICAgKlxuICAgKiBjYW4gZXhwZWN0IHRoaXMgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hpY2ggd2lsbCBpbiB0dXJuIHRyaWdnZXIgYSBgbWVzc2FnZXM6Y2hhbmdlYCBldmVudCBvbiB0aGUgbGF5ZXIuTWVzc2FnZS5cbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZU1pbWVUeXBlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkVmFsdWVcbiAgICovXG4gIF9fdXBkYXRlTWltZVR5cGUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlcGFydHM6Y2hhbmdlJywge1xuICAgICAgcHJvcGVydHk6ICdtaW1lVHlwZScsXG4gICAgICBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBNZXNzYWdlUGFydCBmcm9tIGEgc2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJ0XG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZUZyb21TZXJ2ZXJcbiAgICogQHByaXZhdGVcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcnQgLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgYSBwYXJ0XG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUZyb21TZXJ2ZXIocGFydCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAocGFydC5jb250ZW50KSA/IENvbnRlbnQuX2NyZWF0ZUZyb21TZXJ2ZXIocGFydC5jb250ZW50KSA6IG51bGw7XG5cbiAgICAvLyBUdXJuIGJhc2U2NCBkYXRhIGludG8gYSBCbG9iXG4gICAgaWYgKHBhcnQuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSBwYXJ0LmJvZHkgPSBVdGlsLmJhc2U2NFRvQmxvYihwYXJ0LmJvZHksIHBhcnQubWltZVR5cGUpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBNZXNzYWdlUGFydFxuICAgIHJldHVybiBuZXcgTWVzc2FnZVBhcnQoe1xuICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICBtaW1lVHlwZTogcGFydC5taW1lX3R5cGUsXG4gICAgICBib2R5OiBwYXJ0LmJvZHkgfHwgJycsXG4gICAgICBfY29udGVudDogY29udGVudCxcbiAgICAgIGhhc0NvbnRlbnQ6IEJvb2xlYW4oY29udGVudCksXG4gICAgICBzaXplOiBwYXJ0LnNpemUgfHwgMCxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGxheWVyLkNsaWVudCB0aGF0IHRoZSBjb252ZXJzYXRpb24gYmVsb25ncyB0by5cbiAqXG4gKiBBY3R1YWwgdmFsdWUgb2YgdGhpcyBzdHJpbmcgbWF0Y2hlcyB0aGUgYXBwSWQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuY2xpZW50SWQgPSAnJztcblxuLyoqXG4gKiBTZXJ2ZXIgZ2VuZXJhdGVkIGlkZW50aWZpZXIgZm9yIHRoZSBwYXJ0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuaWQgPSAnJztcblxuLyoqXG4gKiBCb2R5IG9mIHlvdXIgbWVzc2FnZSBwYXJ0LlxuICpcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZGF0YSBvZiB5b3VyIHBhcnQuXG4gKlxuICogSWYgdGhpcyBpcyBgbnVsbGAgdGhlbiBtb3N0IGxpa2VseSBsYXllci5NZXNzYWdlLmhhc0NvbnRlbnQgaXMgdHJ1ZSwgYW5kIHlvdVxuICogY2FuIGVpdGhlciB1c2UgdGhlIGxheWVyLk1lc3NhZ2VQYXJ0LnVybCBwcm9wZXJ0eSBvciB0aGUgbGF5ZXIuTWVzc2FnZVBhcnQuZmV0Y2hDb250ZW50IG1ldGhvZC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuYm9keSA9IG51bGw7XG5cbi8qKlxuICogUmljaCBjb250ZW50IG9iamVjdC5cbiAqXG4gKiBUaGlzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGZvciB5b3UgaWYgeW91ciBsYXllci5NZXNzYWdlUGFydC5ib2R5XG4gKiBpcyBsYXJnZS5cbiAqIEB0eXBlIHtsYXllci5Db250ZW50fVxuICogQHByaXZhdGVcbiAqL1xuTWVzc2FnZVBhcnQucHJvdG90eXBlLl9jb250ZW50ID0gbnVsbDtcblxuLyoqXG4gKiBUaGUgUGFydCBoYXMgcmljaCBjb250ZW50XG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuTWVzc2FnZVBhcnQucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmYWxzZTtcblxuLyoqXG4gKiBVUkwgdG8gcmljaCBjb250ZW50IG9iamVjdC5cbiAqXG4gKiBQYXJ0cyB3aXRoIHJpY2ggY29udGVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggdGhpcyBwcm9wZXJ0eSBzZXQuICBCdXQgaXRzIHZhbHVlIHdpbGwgZXhwaXJlLlxuICpcbiAqIFdpbGwgY29udGFpbiBhbiBleHBpcmluZyB1cmwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSBhbmQgYmUgcmVmcmVzaGVkIHdpdGggY2FsbHMgdG8gYGxheWVyLk1lc3NhZ2VQYXJ0LmZldGNoU3RyZWFtKClgLlxuICogV2lsbCBjb250YWluIGEgbm9uLWV4cGlyaW5nIHVybCB0byBhIGxvY2FsIHJlc291cmNlIGlmIGBsYXllci5NZXNzYWdlUGFydC5mZXRjaENvbnRlbnQoKWAgaXMgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtsYXllci5Db250ZW50fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZVBhcnQucHJvdG90eXBlLCAndXJsJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAvLyBJdHMgcG9zc2libGUgdG8gaGF2ZSBhIHVybCBhbmQgbm8gY29udGVudCBpZiBpdCBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgYnV0IG5vdCB5ZXQgc2VudC5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIF9fdXJsIHRoZW4gaXRzIGEgbG9jYWwgdXJsIGdlbmVyYXRlZCBmcm9tIHRoZSBib2R5IHByb3BlcnR5IGFuZCBkb2VzIG5vdCBleHBpcmUuXG4gICAgaWYgKHRoaXMuX191cmwpIHJldHVybiB0aGlzLl9fdXJsO1xuICAgIGlmICh0aGlzLl9jb250ZW50KSByZXR1cm4gdGhpcy5fY29udGVudC5pc0V4cGlyZWQoKSA/ICcnIDogdGhpcy5fY29udGVudC5kb3dubG9hZFVybDtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KGluVmFsdWUpIHtcbiAgICB0aGlzLl9fdXJsID0gaW5WYWx1ZTtcbiAgfSxcbn0pO1xuXG4vKipcbiAqIE1pbWUgVHlwZSBmb3IgdGhlIGRhdGEgcmVwcmVzZW50ZWQgYnkgdGhlIE1lc3NhZ2VQYXJ0LlxuICpcbiAqIFR5cGljYWxseSB0aGlzIGlzIHRoZSB0eXBlIGZvciB0aGUgZGF0YSBpbiBsYXllci5NZXNzYWdlUGFydC5ib2R5O1xuICogaWYgdGhlcmUgaXMgUmljaCBDb250ZW50LCB0aGVuIGl0cyB0aGUgdHlwZSBvZiBDb250ZW50IHRoYXQgbmVlZHMgdG8gYmVcbiAqIGRvd25sb2FkZWQuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVzc2FnZVBhcnQucHJvdG90eXBlLm1pbWVUeXBlID0gJ3RleHQvcGxhaW4nO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIGxheWVyLk1lc3NhZ2VQYXJ0LmJvZHkuXG4gKlxuICogV2lsbCBiZSBzZXQgZm9yIHlvdSBpZiBub3QgcHJvdmlkZWQuXG4gKiBPbmx5IG5lZWRlZCBmb3IgdXNlIHdpdGggcmljaCBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbk1lc3NhZ2VQYXJ0LnByb3RvdHlwZS5zaXplID0gMDtcblxuLyoqXG4gKiBBcnJheSBvZiBtaW1lIHR5cGVzIHRoYXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdGV4dC5cbiAqXG4gKiBUcmVhdGluZyBhIE1lc3NhZ2VQYXJ0IGFzIHRleHQgbWVhbnMgdGhhdCBldmVuIGlmIHRoZSBgYm9keWAgZ2V0cyBhIEZpbGUgb3IgQmxvYixcbiAqIGl0IHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlaW5nIGRlbGl2ZXJlZCB0byB5b3VyIGFwcC5cbiAqXG4gKiBUaGlzIHZhbHVlIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIHN0cmluZ3MgYW5kIHJlZ3VsYXIgZXhwcmVzc2lvbnM6XG4gKlxuICogYGBgXG4gKiBsYXllci5NZXNzYWdlUGFydC5UZXh0dWFsTWltZVR5cGVzID0gWyd0ZXh0L3BsYWluJywgJ3RleHQvbW91bnRhaW4nLCAvXmFwcGxpY2F0aW9uXFwvanNvbihcXCsuKykkL11cbiAqIGBgYFxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtNaXhlZFtdfVxuICovXG5NZXNzYWdlUGFydC5UZXh0dWFsTWltZVR5cGVzID0gWy9edGV4dFxcLy4rJC8sIC9eYXBwbGljYXRpb25cXC9qc29uKFxcKy4rKT8kL107XG5cbi8qKlxuICogTnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIHRvIG1ha2UgYmVmb3JlIGdpdmluZyB1cCBvbiB1cGxvYWRpbmcgUmljaCBDb250ZW50IHRvIEdvb2dsZSBDbG91ZCBTdG9yYWdlLlxuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lc3NhZ2VQYXJ0Lk1heFJpY2hDb250ZW50UmV0cnlDb3VudCA9IDM7XG5cbk1lc3NhZ2VQYXJ0Ll9zdXBwb3J0ZWRFdmVudHMgPSBbXG4gICdwYXJ0czpzZW5kJyxcbiAgJ2NvbnRlbnQtbG9hZGVkJyxcbiAgJ3VybC1sb2FkZWQnLFxuICAnY29udGVudC1sb2FkZWQtZXJyb3InLFxuICAnbWVzc2FnZXBhcnRzOmNoYW5nZScsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuUm9vdC5pbml0Q2xhc3MuYXBwbHkoTWVzc2FnZVBhcnQsIFtNZXNzYWdlUGFydCwgJ01lc3NhZ2VQYXJ0J10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VQYXJ0O1xuIl19
