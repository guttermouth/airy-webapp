'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A layer.Message instance for use within layer.Conversation.
 *
 * @class layer.Message.ConversationMessage
 * @extends layer.Message
 */
var Root = require('../root');
var Message = require('./message');
var ClientRegistry = require('../client-registry');
var LayerError = require('../layer-error');
var Constants = require('../const');
var Util = require('../client-utils');

var ConversationMessage = function (_Message) {
  _inherits(ConversationMessage, _Message);

  function ConversationMessage(options) {
    _classCallCheck(this, ConversationMessage);

    if (options.conversation) options.conversationId = options.conversation.id;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ConversationMessage).call(this, options));

    _this._disableEvents = true;
    if (!options.fromServer) _this.recipientStatus = {};else _this.__updateRecipientStatus(_this.recipientStatus);
    _this._disableEvents = false;

    var client = _this.getClient();
    _this.isInitializing = false;
    if (options && options.fromServer) {
      client._addMessage(_this);
      var status = _this.recipientStatus[client.user.id];
      if (status && status !== Constants.RECEIPT_STATE.READ && status !== Constants.RECEIPT_STATE.DELIVERED) {
        Util.defer(function () {
          return _this._sendReceipt('delivery');
        });
      }
    }
    return _this;
  }

  /**
   * Get the layer.Conversation associated with this layer.Message.ConversationMessage.
   *
   * @method getConversation
   * @param {Boolean} load       Pass in true if the layer.Conversation should be loaded if not found locally
   * @return {layer.Conversation}
   */


  _createClass(ConversationMessage, [{
    key: 'getConversation',
    value: function getConversation(load) {
      if (this.conversationId) {
        return ClientRegistry.get(this.clientId).getConversation(this.conversationId, load);
      }
      return null;
    }

    /**
     * On loading this one item from the server, after _populateFromServer has been called, due final setup.
     *
     * @method _loaded
     * @private
     * @param {Object} data  Data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.conversationId = data.conversation.id;
      this.getClient()._addMessage(this);
    }

    /**
     * Accessor called whenever the app accesses `message.recipientStatus`.
     *
     * Insures that participants who haven't yet been sent the Message are marked as layer.Constants.RECEIPT_STATE.PENDING
     *
     * @method __getRecipientStatus
     * @param {string} pKey - The actual property key where the value is stored
     * @private
     * @return {Object}
     */

  }, {
    key: '__getRecipientStatus',
    value: function __getRecipientStatus(pKey) {
      var _this2 = this;

      var value = this[pKey] || {};
      var client = this.getClient();
      if (client) {
        (function () {
          var id = client.user.id;
          var conversation = _this2.getConversation(false);
          if (conversation) {
            conversation.participants.forEach(function (participant) {
              if (!value[participant.id]) {
                value[participant.id] = participant.id === id ? Constants.RECEIPT_STATE.READ : Constants.RECEIPT_STATE.PENDING;
              }
            });
          }
        })();
      }
      return value;
    }

    /**
     * Handle changes to the recipientStatus property.
     *
     * Any time the recipientStatus property is set,
     * Recalculate all of the receipt related properties:
     *
     * 1. isRead
     * 2. readStatus
     * 3. deliveryStatus
     *
     * @method __updateRecipientStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     *
     */

  }, {
    key: '__updateRecipientStatus',
    value: function __updateRecipientStatus(status, oldStatus) {
      var conversation = this.getConversation(false);
      var client = this.getClient();

      if (!conversation || Util.doesObjectMatch(status, oldStatus)) return;

      var id = client.user.id;
      var isSender = this.sender.sessionOwner;
      var userHasRead = status[id] === Constants.RECEIPT_STATE.READ;

      try {
        // -1 so we don't count this user
        var userCount = conversation.participants.length - 1;

        // If sent by this user or read by this user, update isRead/unread
        if (!this.__isRead && (isSender || userHasRead)) {
          this.__isRead = true; // no __updateIsRead event fired
        }

        // Update the readStatus/deliveryStatus properties

        var _getReceiptStatus2 = this._getReceiptStatus(status, id);

        var readCount = _getReceiptStatus2.readCount;
        var deliveredCount = _getReceiptStatus2.deliveredCount;

        this._setReceiptStatus(readCount, deliveredCount, userCount);
      } catch (error) {}
      // Do nothing


      // Only trigger an event
      // 1. we're not initializing a new Message
      // 2. the user's state has been updated to read; we don't care about updates from other users if we aren't the sender.
      //    We also don't care about state changes to delivered; these do not inform rendering as the fact we are processing it
      //    proves its delivered.
      // 3. The user is the sender; in that case we do care about rendering receipts from other users
      if (!this.isInitializing && oldStatus) {
        var usersStateUpdatedToRead = userHasRead && oldStatus[id] !== Constants.RECEIPT_STATE.READ;
        if (usersStateUpdatedToRead || isSender) {
          this._triggerAsync('messages:change', {
            oldValue: oldStatus,
            newValue: status,
            property: 'recipientStatus'
          });
        }
      }
    }

    /**
     * Get the number of participants who have read and been delivered
     * this Message
     *
     * @method _getReceiptStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     * @param  {string} id - Identity ID for this user; not counted when reporting on how many people have read/received.
     * @return {Object} result
     * @return {number} result.readCount
     * @return {number} result.deliveredCount
     */

  }, {
    key: '_getReceiptStatus',
    value: function _getReceiptStatus(status, id) {
      var readCount = 0,
          deliveredCount = 0;
      Object.keys(status).filter(function (participant) {
        return participant !== id;
      }).forEach(function (participant) {
        if (status[participant] === Constants.RECEIPT_STATE.READ) {
          readCount++;
          deliveredCount++;
        } else if (status[participant] === Constants.RECEIPT_STATE.DELIVERED) {
          deliveredCount++;
        }
      });

      return {
        readCount: readCount,
        deliveredCount: deliveredCount
      };
    }

    /**
     * Sets the layer.Message.ConversationMessage.readStatus and layer.Message.ConversationMessage.deliveryStatus properties.
     *
     * @method _setReceiptStatus
     * @private
     * @param  {number} readCount
     * @param  {number} deliveredCount
     * @param  {number} userCount
     */

  }, {
    key: '_setReceiptStatus',
    value: function _setReceiptStatus(readCount, deliveredCount, userCount) {
      if (readCount === userCount) {
        this.readStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (readCount > 0) {
        this.readStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.readStatus = Constants.RECIPIENT_STATE.NONE;
      }
      if (deliveredCount === userCount) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (deliveredCount > 0) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.deliveryStatus = Constants.RECIPIENT_STATE.NONE;
      }
    }

    /**
     * Handle changes to the isRead property.
     *
     * If someone called m.isRead = true, AND
     * if it was previously false, AND
     * if the call didn't come from layer.Message.ConversationMessage.__updateRecipientStatus,
     * Then notify the server that the message has been read.
     *
     *
     * @method __updateIsRead
     * @private
     * @param  {boolean} value - True if isRead is true.
     */

  }, {
    key: '__updateIsRead',
    value: function __updateIsRead(value) {
      if (value) {
        if (!this._inPopulateFromServer) {
          this._sendReceipt(Constants.RECEIPT_STATE.READ);
        }
        this._triggerMessageRead();
        var conversation = this.getConversation(false);
        if (conversation) conversation.unreadCount--;
      }
    }

    /**
     * Trigger events indicating changes to the isRead/isUnread properties.
     *
     * @method _triggerMessageRead
     * @private
     */

  }, {
    key: '_triggerMessageRead',
    value: function _triggerMessageRead() {
      var value = this.isRead;
      this._triggerAsync('messages:change', {
        property: 'isRead',
        oldValue: !value,
        newValue: value
      });
      this._triggerAsync('messages:change', {
        property: 'isUnread',
        oldValue: value,
        newValue: !value
      });
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * For Read Receipt, you can also just write:
     *
     * ```
     * message.isRead = true;
     * ```
     *
     * You can retract a Delivery or Read Receipt; once marked as Delivered or Read, it can't go back.
     *
     * ```
     * messsage.sendReceipt(layer.Constants.RECEIPT_STATE.READ);
     * ```
     *
     * @method sendReceipt
     * @param {string} [type=layer.Constants.RECEIPT_STATE.READ] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     * @return {layer.Message.ConversationMessage} this
     */

  }, {
    key: 'sendReceipt',
    value: function sendReceipt() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? Constants.RECEIPT_STATE.READ : arguments[0];

      if (type === Constants.RECEIPT_STATE.READ) {
        if (this.isRead) {
          return this;
        } else {
          // Without triggering the event, clearObject isn't called,
          // which means those using the toObject() data will have an isRead that doesn't match
          // this instance.  Which typically leads to lots of extra attempts
          // to mark the message as read.
          this.__isRead = true;
          this._triggerMessageRead();
          var conversation = this.getConversation(false);
          if (conversation) conversation.unreadCount--;
        }
      }
      this._sendReceipt(type);
      return this;
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * This bypasses any validation and goes direct to sending to the server.
     *
     * NOTE: Server errors are not handled; the local receipt state is suitable even
     * if out of sync with the server.
     *
     * @method _sendReceipt
     * @private
     * @param {string} [type=read] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     */

  }, {
    key: '_sendReceipt',
    value: function _sendReceipt(type) {
      var _this3 = this;

      // This little test exists so that we don't send receipts on Conversations we are no longer
      // participants in (participants = [] if we are not a participant)
      var conversation = this.getConversation(false);
      if (conversation && conversation.participants.length === 0) return;

      this._setSyncing();
      this._xhr({
        url: '/receipts',
        method: 'POST',
        data: {
          type: type
        },
        sync: {
          // This should not be treated as a POST/CREATE request on the Message
          operation: 'RECEIPT'
        }
      }, function () {
        return _this3._setSynced();
      });
    }

    /**
     * Delete the Message from the server.
     *
     * This call will support various deletion modes.  Calling without a deletion mode is deprecated.
     *
     * Deletion Modes:
     *
     * * layer.Constants.DELETION_MODE.ALL: This deletes the local copy immediately, and attempts to also
     *   delete the server's copy.
     * * layer.Constants.DELETION_MODE.MY_DEVICES: Deletes this Message from all of my devices; no effect on other users.
     *
     * @method delete
     * @param {String} deletionMode
     */
    // Abstract Method

  }, {
    key: 'delete',
    value: function _delete(mode) {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      var queryStr = void 0;
      switch (mode) {
        case Constants.DELETION_MODE.ALL:
        case true:
          queryStr = 'mode=all_participants';
          break;
        case Constants.DELETION_MODE.MY_DEVICES:
          queryStr = 'mode=my_devices';
          break;
        default:
          throw new Error(LayerError.dictionary.deletionModeUnsupported);
      }

      var id = this.id;
      var client = this.getClient();
      this._xhr({
        url: '?' + queryStr,
        method: 'DELETE'
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found' && result.data.id !== 'authentication_required')) {
          Message.load(id, client);
        }
      });

      this._deleted();
      this.destroy();
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(ConversationMessage.prototype), 'toObject', this).call(this);
        this._toObject.recipientStatus = Util.clone(this.recipientStatus);
      }
      return this._toObject;
    }

    /*
     * Creates a message from the server's representation of a message.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the message
     * @param  {layer.Client} client
     * @return {layer.Message.ConversationMessage}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      var conversationId = void 0;
      if (message.conversation) {
        conversationId = message.conversation.id;
      } else {
        conversationId = message.conversationId;
      }

      return new ConversationMessage({
        conversationId: conversationId,
        fromServer: message,
        clientId: client.appId,
        _fromDB: message._fromDB,
        _notify: fromWebsocket && message.is_unread && message.sender.user_id !== client.user.userId
      });
    }
  }]);

  return ConversationMessage;
}(Message);

/**
 * True if this Message has been read by this user.
 *
 * You can change isRead programatically
 *
 *      m.isRead = true;
 *
 * This will automatically notify the server that the message was read by your user.
 * @type {Boolean}
 */


ConversationMessage.prototype.isRead = false;

/**
 * Read/delivery State of all participants.
 *
 * This is an object containing keys for each participant,
 * and a value of:
 *
 * * layer.RECEIPT_STATE.SENT
 * * layer.RECEIPT_STATE.DELIVERED
 * * layer.RECEIPT_STATE.READ
 * * layer.RECEIPT_STATE.PENDING
 *
 * @type {Object}
 */
ConversationMessage.prototype.recipientStatus = null;

/**
 * Have the other participants read this Message yet.
 *
 * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * See layer.Message.ConversationMessage.recipientStatus for a more detailed report.
 *
 * @type {String}
 */
ConversationMessage.prototype.readStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * Have the other participants received this Message yet.
 *
  * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * See layer.Message.ConversationMessage.recipientStatus for a more detailed report.
 *
 *
 * @type {String}
 */
ConversationMessage.prototype.deliveryStatus = Constants.RECIPIENT_STATE.NONE;

ConversationMessage.inObjectIgnore = Message.inObjectIgnore;
ConversationMessage._supportedEvents = [].concat(Message._supportedEvents);
Root.initClass.apply(ConversationMessage, [ConversationMessage, 'ConversationMessage']);
module.exports = ConversationMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY29udmVyc2F0aW9uLW1lc3NhZ2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztBQU1BLElBQU0sT0FBTyxRQUFRLFNBQVIsQ0FBYjtBQUNBLElBQU0sVUFBVSxRQUFRLFdBQVIsQ0FBaEI7QUFDQSxJQUFNLGlCQUFpQixRQUFRLG9CQUFSLENBQXZCO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFNLFlBQVksUUFBUSxVQUFSLENBQWxCO0FBQ0EsSUFBTSxPQUFPLFFBQVEsaUJBQVIsQ0FBYjs7SUFFTSxtQjs7O0FBQ0osK0JBQVksT0FBWixFQUFxQjtBQUFBOztBQUNuQixRQUFJLFFBQVEsWUFBWixFQUEwQixRQUFRLGNBQVIsR0FBeUIsUUFBUSxZQUFSLENBQXFCLEVBQTlDOztBQURQLHVHQUViLE9BRmE7O0FBSW5CLFVBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBLFFBQUksQ0FBQyxRQUFRLFVBQWIsRUFBeUIsTUFBSyxlQUFMLEdBQXVCLEVBQXZCLENBQXpCLEtBQ0ssTUFBSyx1QkFBTCxDQUE2QixNQUFLLGVBQWxDO0FBQ0wsVUFBSyxjQUFMLEdBQXNCLEtBQXRCOztBQUVBLFFBQU0sU0FBUyxNQUFLLFNBQUwsRUFBZjtBQUNBLFVBQUssY0FBTCxHQUFzQixLQUF0QjtBQUNBLFFBQUksV0FBVyxRQUFRLFVBQXZCLEVBQW1DO0FBQ2pDLGFBQU8sV0FBUDtBQUNBLFVBQU0sU0FBUyxNQUFLLGVBQUwsQ0FBcUIsT0FBTyxJQUFQLENBQVksRUFBakMsQ0FBZjtBQUNBLFVBQUksVUFBVSxXQUFXLFVBQVUsYUFBVixDQUF3QixJQUE3QyxJQUFxRCxXQUFXLFVBQVUsYUFBVixDQUF3QixTQUE1RixFQUF1RztBQUNyRyxhQUFLLEtBQUwsQ0FBVztBQUFBLGlCQUFNLE1BQUssWUFBTCxDQUFrQixVQUFsQixDQUFOO0FBQUEsU0FBWDtBQUNEO0FBQ0Y7QUFqQmtC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QUgsQ0FBVSxRQUFRLGdCQUFsQixDQUF2QztBQUNBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsbUJBQXJCLEVBQTBDLENBQUMsbUJBQUQsRUFBc0IscUJBQXRCLENBQTFDO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLG1CQUFqQiIsImZpbGUiOiJjb252ZXJzYXRpb24tbWVzc2FnZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBsYXllci5NZXNzYWdlIGluc3RhbmNlIGZvciB1c2Ugd2l0aGluIGxheWVyLkNvbnZlcnNhdGlvbi5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlXG4gKiBAZXh0ZW5kcyBsYXllci5NZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuLi9yb290Jyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi9tZXNzYWdlJyk7XG5jb25zdCBDbGllbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4uL2NsaWVudC1yZWdpc3RyeScpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4uL2xheWVyLWVycm9yJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL2NsaWVudC11dGlscycpO1xuXG5jbGFzcyBDb252ZXJzYXRpb25NZXNzYWdlIGV4dGVuZHMgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5jb252ZXJzYXRpb24pIG9wdGlvbnMuY29udmVyc2F0aW9uSWQgPSBvcHRpb25zLmNvbnZlcnNhdGlvbi5pZDtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSB0cnVlO1xuICAgIGlmICghb3B0aW9ucy5mcm9tU2VydmVyKSB0aGlzLnJlY2lwaWVudFN0YXR1cyA9IHt9O1xuICAgIGVsc2UgdGhpcy5fX3VwZGF0ZVJlY2lwaWVudFN0YXR1cyh0aGlzLnJlY2lwaWVudFN0YXR1cyk7XG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mcm9tU2VydmVyKSB7XG4gICAgICBjbGllbnQuX2FkZE1lc3NhZ2UodGhpcyk7XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnJlY2lwaWVudFN0YXR1c1tjbGllbnQudXNlci5pZF07XG4gICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cyAhPT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCAmJiBzdGF0dXMgIT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLkRFTElWRVJFRCkge1xuICAgICAgICBVdGlsLmRlZmVyKCgpID0+IHRoaXMuX3NlbmRSZWNlaXB0KCdkZWxpdmVyeScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllci5Db252ZXJzYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldENvbnZlcnNhdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWQgICAgICAgUGFzcyBpbiB0cnVlIGlmIHRoZSBsYXllci5Db252ZXJzYXRpb24gc2hvdWxkIGJlIGxvYWRlZCBpZiBub3QgZm91bmQgbG9jYWxseVxuICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259XG4gICAqL1xuICBnZXRDb252ZXJzYXRpb24obG9hZCkge1xuICAgIGlmICh0aGlzLmNvbnZlcnNhdGlvbklkKSB7XG4gICAgICByZXR1cm4gQ2xpZW50UmVnaXN0cnkuZ2V0KHRoaXMuY2xpZW50SWQpLmdldENvbnZlcnNhdGlvbih0aGlzLmNvbnZlcnNhdGlvbklkLCBsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogT24gbG9hZGluZyB0aGlzIG9uZSBpdGVtIGZyb20gdGhlIHNlcnZlciwgYWZ0ZXIgX3BvcHVsYXRlRnJvbVNlcnZlciBoYXMgYmVlbiBjYWxsZWQsIGR1ZSBmaW5hbCBzZXR1cC5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICBEYXRhIGZyb20gc2VydmVyXG4gICAqL1xuICBfbG9hZGVkKGRhdGEpIHtcbiAgICB0aGlzLmNvbnZlcnNhdGlvbklkID0gZGF0YS5jb252ZXJzYXRpb24uaWQ7XG4gICAgdGhpcy5nZXRDbGllbnQoKS5fYWRkTWVzc2FnZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3NvciBjYWxsZWQgd2hlbmV2ZXIgdGhlIGFwcCBhY2Nlc3NlcyBgbWVzc2FnZS5yZWNpcGllbnRTdGF0dXNgLlxuICAgKlxuICAgKiBJbnN1cmVzIHRoYXQgcGFydGljaXBhbnRzIHdobyBoYXZlbid0IHlldCBiZWVuIHNlbnQgdGhlIE1lc3NhZ2UgYXJlIG1hcmtlZCBhcyBsYXllci5Db25zdGFudHMuUkVDRUlQVF9TVEFURS5QRU5ESU5HXG4gICAqXG4gICAqIEBtZXRob2QgX19nZXRSZWNpcGllbnRTdGF0dXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBLZXkgLSBUaGUgYWN0dWFsIHByb3BlcnR5IGtleSB3aGVyZSB0aGUgdmFsdWUgaXMgc3RvcmVkXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9fZ2V0UmVjaXBpZW50U3RhdHVzKHBLZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXNbcEtleV0gfHwge307XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoY2xpZW50KSB7XG4gICAgICBjb25zdCBpZCA9IGNsaWVudC51c2VyLmlkO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5nZXRDb252ZXJzYXRpb24oZmFsc2UpO1xuICAgICAgaWYgKGNvbnZlcnNhdGlvbikge1xuICAgICAgICBjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgaWYgKCF2YWx1ZVtwYXJ0aWNpcGFudC5pZF0pIHtcbiAgICAgICAgICAgIHZhbHVlW3BhcnRpY2lwYW50LmlkXSA9IHBhcnRpY2lwYW50LmlkID09PSBpZCA/XG4gICAgICAgICAgICAgIENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQgOiBDb25zdGFudHMuUkVDRUlQVF9TVEFURS5QRU5ESU5HO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyB0byB0aGUgcmVjaXBpZW50U3RhdHVzIHByb3BlcnR5LlxuICAgKlxuICAgKiBBbnkgdGltZSB0aGUgcmVjaXBpZW50U3RhdHVzIHByb3BlcnR5IGlzIHNldCxcbiAgICogUmVjYWxjdWxhdGUgYWxsIG9mIHRoZSByZWNlaXB0IHJlbGF0ZWQgcHJvcGVydGllczpcbiAgICpcbiAgICogMS4gaXNSZWFkXG4gICAqIDIuIHJlYWRTdGF0dXNcbiAgICogMy4gZGVsaXZlcnlTdGF0dXNcbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZVJlY2lwaWVudFN0YXR1c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXR1cyAtIE9iamVjdCBkZXNjcmliaW5nIHRoZSBkZWxpdmVyZWQvcmVhZC9zZW50IHZhbHVlIGZvciBlYWNoIHBhcnRpY2lwYW50XG4gICAqXG4gICAqL1xuICBfX3VwZGF0ZVJlY2lwaWVudFN0YXR1cyhzdGF0dXMsIG9sZFN0YXR1cykge1xuICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuZ2V0Q29udmVyc2F0aW9uKGZhbHNlKTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuXG4gICAgaWYgKCFjb252ZXJzYXRpb24gfHwgVXRpbC5kb2VzT2JqZWN0TWF0Y2goc3RhdHVzLCBvbGRTdGF0dXMpKSByZXR1cm47XG5cbiAgICBjb25zdCBpZCA9IGNsaWVudC51c2VyLmlkO1xuICAgIGNvbnN0IGlzU2VuZGVyID0gdGhpcy5zZW5kZXIuc2Vzc2lvbk93bmVyO1xuICAgIGNvbnN0IHVzZXJIYXNSZWFkID0gc3RhdHVzW2lkXSA9PT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRDtcblxuICAgIHRyeSB7XG4gICAgICAvLyAtMSBzbyB3ZSBkb24ndCBjb3VudCB0aGlzIHVzZXJcbiAgICAgIGNvbnN0IHVzZXJDb3VudCA9IGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gSWYgc2VudCBieSB0aGlzIHVzZXIgb3IgcmVhZCBieSB0aGlzIHVzZXIsIHVwZGF0ZSBpc1JlYWQvdW5yZWFkXG4gICAgICBpZiAoIXRoaXMuX19pc1JlYWQgJiYgKGlzU2VuZGVyIHx8IHVzZXJIYXNSZWFkKSkge1xuICAgICAgICB0aGlzLl9faXNSZWFkID0gdHJ1ZTsgLy8gbm8gX191cGRhdGVJc1JlYWQgZXZlbnQgZmlyZWRcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSByZWFkU3RhdHVzL2RlbGl2ZXJ5U3RhdHVzIHByb3BlcnRpZXNcbiAgICAgIGNvbnN0IHsgcmVhZENvdW50LCBkZWxpdmVyZWRDb3VudCB9ID0gdGhpcy5fZ2V0UmVjZWlwdFN0YXR1cyhzdGF0dXMsIGlkKTtcbiAgICAgIHRoaXMuX3NldFJlY2VpcHRTdGF0dXMocmVhZENvdW50LCBkZWxpdmVyZWRDb3VudCwgdXNlckNvdW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cblxuICAgIC8vIE9ubHkgdHJpZ2dlciBhbiBldmVudFxuICAgIC8vIDEuIHdlJ3JlIG5vdCBpbml0aWFsaXppbmcgYSBuZXcgTWVzc2FnZVxuICAgIC8vIDIuIHRoZSB1c2VyJ3Mgc3RhdGUgaGFzIGJlZW4gdXBkYXRlZCB0byByZWFkOyB3ZSBkb24ndCBjYXJlIGFib3V0IHVwZGF0ZXMgZnJvbSBvdGhlciB1c2VycyBpZiB3ZSBhcmVuJ3QgdGhlIHNlbmRlci5cbiAgICAvLyAgICBXZSBhbHNvIGRvbid0IGNhcmUgYWJvdXQgc3RhdGUgY2hhbmdlcyB0byBkZWxpdmVyZWQ7IHRoZXNlIGRvIG5vdCBpbmZvcm0gcmVuZGVyaW5nIGFzIHRoZSBmYWN0IHdlIGFyZSBwcm9jZXNzaW5nIGl0XG4gICAgLy8gICAgcHJvdmVzIGl0cyBkZWxpdmVyZWQuXG4gICAgLy8gMy4gVGhlIHVzZXIgaXMgdGhlIHNlbmRlcjsgaW4gdGhhdCBjYXNlIHdlIGRvIGNhcmUgYWJvdXQgcmVuZGVyaW5nIHJlY2VpcHRzIGZyb20gb3RoZXIgdXNlcnNcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXppbmcgJiYgb2xkU3RhdHVzKSB7XG4gICAgICBjb25zdCB1c2Vyc1N0YXRlVXBkYXRlZFRvUmVhZCA9IHVzZXJIYXNSZWFkICYmIG9sZFN0YXR1c1tpZF0gIT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQ7XG4gICAgICBpZiAodXNlcnNTdGF0ZVVwZGF0ZWRUb1JlYWQgfHwgaXNTZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlczpjaGFuZ2UnLCB7XG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFN0YXR1cyxcbiAgICAgICAgICBuZXdWYWx1ZTogc3RhdHVzLFxuICAgICAgICAgIHByb3BlcnR5OiAncmVjaXBpZW50U3RhdHVzJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSByZWFkIGFuZCBiZWVuIGRlbGl2ZXJlZFxuICAgKiB0aGlzIE1lc3NhZ2VcbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0UmVjZWlwdFN0YXR1c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXR1cyAtIE9iamVjdCBkZXNjcmliaW5nIHRoZSBkZWxpdmVyZWQvcmVhZC9zZW50IHZhbHVlIGZvciBlYWNoIHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgLSBJZGVudGl0eSBJRCBmb3IgdGhpcyB1c2VyOyBub3QgY291bnRlZCB3aGVuIHJlcG9ydGluZyBvbiBob3cgbWFueSBwZW9wbGUgaGF2ZSByZWFkL3JlY2VpdmVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJlc3VsdC5yZWFkQ291bnRcbiAgICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQuZGVsaXZlcmVkQ291bnRcbiAgICovXG4gIF9nZXRSZWNlaXB0U3RhdHVzKHN0YXR1cywgaWQpIHtcbiAgICBsZXQgcmVhZENvdW50ID0gMCxcbiAgICAgIGRlbGl2ZXJlZENvdW50ID0gMDtcbiAgICBPYmplY3Qua2V5cyhzdGF0dXMpXG4gICAgICAuZmlsdGVyKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50ICE9PSBpZClcbiAgICAgIC5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzW3BhcnRpY2lwYW50XSA9PT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCkge1xuICAgICAgICAgIHJlYWRDb3VudCsrO1xuICAgICAgICAgIGRlbGl2ZXJlZENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzW3BhcnRpY2lwYW50XSA9PT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuREVMSVZFUkVEKSB7XG4gICAgICAgICAgZGVsaXZlcmVkQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVhZENvdW50LFxuICAgICAgZGVsaXZlcmVkQ291bnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsYXllci5NZXNzYWdlLkNvbnZlcnNhdGlvbk1lc3NhZ2UucmVhZFN0YXR1cyBhbmQgbGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlLmRlbGl2ZXJ5U3RhdHVzIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBtZXRob2QgX3NldFJlY2VpcHRTdGF0dXNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSByZWFkQ291bnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkZWxpdmVyZWRDb3VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHVzZXJDb3VudFxuICAgKi9cbiAgX3NldFJlY2VpcHRTdGF0dXMocmVhZENvdW50LCBkZWxpdmVyZWRDb3VudCwgdXNlckNvdW50KSB7XG4gICAgaWYgKHJlYWRDb3VudCA9PT0gdXNlckNvdW50KSB7XG4gICAgICB0aGlzLnJlYWRTdGF0dXMgPSBDb25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLkFMTDtcbiAgICB9IGVsc2UgaWYgKHJlYWRDb3VudCA+IDApIHtcbiAgICAgIHRoaXMucmVhZFN0YXR1cyA9IENvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuU09NRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkU3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5OT05FO1xuICAgIH1cbiAgICBpZiAoZGVsaXZlcmVkQ291bnQgPT09IHVzZXJDb3VudCkge1xuICAgICAgdGhpcy5kZWxpdmVyeVN0YXR1cyA9IENvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuQUxMO1xuICAgIH0gZWxzZSBpZiAoZGVsaXZlcmVkQ291bnQgPiAwKSB7XG4gICAgICB0aGlzLmRlbGl2ZXJ5U3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5TT01FO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbGl2ZXJ5U3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5OT05FO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyB0byB0aGUgaXNSZWFkIHByb3BlcnR5LlxuICAgKlxuICAgKiBJZiBzb21lb25lIGNhbGxlZCBtLmlzUmVhZCA9IHRydWUsIEFORFxuICAgKiBpZiBpdCB3YXMgcHJldmlvdXNseSBmYWxzZSwgQU5EXG4gICAqIGlmIHRoZSBjYWxsIGRpZG4ndCBjb21lIGZyb20gbGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlLl9fdXBkYXRlUmVjaXBpZW50U3RhdHVzLFxuICAgKiBUaGVuIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZUlzUmVhZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSB2YWx1ZSAtIFRydWUgaWYgaXNSZWFkIGlzIHRydWUuXG4gICAqL1xuICBfX3VwZGF0ZUlzUmVhZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLl9pblBvcHVsYXRlRnJvbVNlcnZlcikge1xuICAgICAgICB0aGlzLl9zZW5kUmVjZWlwdChDb25zdGFudHMuUkVDRUlQVF9TVEFURS5SRUFEKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RyaWdnZXJNZXNzYWdlUmVhZCgpO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5nZXRDb252ZXJzYXRpb24oZmFsc2UpO1xuICAgICAgaWYgKGNvbnZlcnNhdGlvbikgY29udmVyc2F0aW9uLnVucmVhZENvdW50LS07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgZXZlbnRzIGluZGljYXRpbmcgY2hhbmdlcyB0byB0aGUgaXNSZWFkL2lzVW5yZWFkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBtZXRob2QgX3RyaWdnZXJNZXNzYWdlUmVhZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyaWdnZXJNZXNzYWdlUmVhZCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaXNSZWFkO1xuICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6Y2hhbmdlJywge1xuICAgICAgcHJvcGVydHk6ICdpc1JlYWQnLFxuICAgICAgb2xkVmFsdWU6ICF2YWx1ZSxcbiAgICAgIG5ld1ZhbHVlOiB2YWx1ZSxcbiAgICB9KTtcbiAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgIHByb3BlcnR5OiAnaXNVbnJlYWQnLFxuICAgICAgb2xkVmFsdWU6IHZhbHVlLFxuICAgICAgbmV3VmFsdWU6ICF2YWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgUmVhZCBvciBEZWxpdmVyeSBSZWNlaXB0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEZvciBSZWFkIFJlY2VpcHQsIHlvdSBjYW4gYWxzbyBqdXN0IHdyaXRlOlxuICAgKlxuICAgKiBgYGBcbiAgICogbWVzc2FnZS5pc1JlYWQgPSB0cnVlO1xuICAgKiBgYGBcbiAgICpcbiAgICogWW91IGNhbiByZXRyYWN0IGEgRGVsaXZlcnkgb3IgUmVhZCBSZWNlaXB0OyBvbmNlIG1hcmtlZCBhcyBEZWxpdmVyZWQgb3IgUmVhZCwgaXQgY2FuJ3QgZ28gYmFjay5cbiAgICpcbiAgICogYGBgXG4gICAqIG1lc3NzYWdlLnNlbmRSZWNlaXB0KGxheWVyLkNvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQG1ldGhvZCBzZW5kUmVjZWlwdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9bGF5ZXIuQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRF0gLSBPbmUgb2YgbGF5ZXIuQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCBvciBsYXllci5Db25zdGFudHMuUkVDRUlQVF9TVEFURS5ERUxJVkVSWVxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlLkNvbnZlcnNhdGlvbk1lc3NhZ2V9IHRoaXNcbiAgICovXG4gIHNlbmRSZWNlaXB0KHR5cGUgPSBDb25zdGFudHMuUkVDRUlQVF9TVEFURS5SRUFEKSB7XG4gICAgaWYgKHR5cGUgPT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgZXZlbnQsIGNsZWFyT2JqZWN0IGlzbid0IGNhbGxlZCxcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgdGhvc2UgdXNpbmcgdGhlIHRvT2JqZWN0KCkgZGF0YSB3aWxsIGhhdmUgYW4gaXNSZWFkIHRoYXQgZG9lc24ndCBtYXRjaFxuICAgICAgICAvLyB0aGlzIGluc3RhbmNlLiAgV2hpY2ggdHlwaWNhbGx5IGxlYWRzIHRvIGxvdHMgb2YgZXh0cmEgYXR0ZW1wdHNcbiAgICAgICAgLy8gdG8gbWFyayB0aGUgbWVzc2FnZSBhcyByZWFkLlxuICAgICAgICB0aGlzLl9faXNSZWFkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck1lc3NhZ2VSZWFkKCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuZ2V0Q29udmVyc2F0aW9uKGZhbHNlKTtcbiAgICAgICAgaWYgKGNvbnZlcnNhdGlvbikgY29udmVyc2F0aW9uLnVucmVhZENvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NlbmRSZWNlaXB0KHR5cGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBSZWFkIG9yIERlbGl2ZXJ5IFJlY2VpcHQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogVGhpcyBieXBhc3NlcyBhbnkgdmFsaWRhdGlvbiBhbmQgZ29lcyBkaXJlY3QgdG8gc2VuZGluZyB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOT1RFOiBTZXJ2ZXIgZXJyb3JzIGFyZSBub3QgaGFuZGxlZDsgdGhlIGxvY2FsIHJlY2VpcHQgc3RhdGUgaXMgc3VpdGFibGUgZXZlblxuICAgKiBpZiBvdXQgb2Ygc3luYyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgX3NlbmRSZWNlaXB0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1yZWFkXSAtIE9uZSBvZiBsYXllci5Db25zdGFudHMuUkVDRUlQVF9TVEFURS5SRUFEIG9yIGxheWVyLkNvbnN0YW50cy5SRUNFSVBUX1NUQVRFLkRFTElWRVJZXG4gICAqL1xuICBfc2VuZFJlY2VpcHQodHlwZSkge1xuICAgIC8vIFRoaXMgbGl0dGxlIHRlc3QgZXhpc3RzIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCByZWNlaXB0cyBvbiBDb252ZXJzYXRpb25zIHdlIGFyZSBubyBsb25nZXJcbiAgICAvLyBwYXJ0aWNpcGFudHMgaW4gKHBhcnRpY2lwYW50cyA9IFtdIGlmIHdlIGFyZSBub3QgYSBwYXJ0aWNpcGFudClcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgaWYgKGNvbnZlcnNhdGlvbiAmJiBjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fc2V0U3luY2luZygpO1xuICAgIHRoaXMuX3hocih7XG4gICAgICB1cmw6ICcvcmVjZWlwdHMnLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGUsXG4gICAgICB9LFxuICAgICAgc3luYzoge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIFBPU1QvQ1JFQVRFIHJlcXVlc3Qgb24gdGhlIE1lc3NhZ2VcbiAgICAgICAgb3BlcmF0aW9uOiAnUkVDRUlQVCcsXG4gICAgICB9LFxuICAgIH0sICgpID0+IHRoaXMuX3NldFN5bmNlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgd2lsbCBzdXBwb3J0IHZhcmlvdXMgZGVsZXRpb24gbW9kZXMuICBDYWxsaW5nIHdpdGhvdXQgYSBkZWxldGlvbiBtb2RlIGlzIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIERlbGV0aW9uIE1vZGVzOlxuICAgKlxuICAgKiAqIGxheWVyLkNvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTDogVGhpcyBkZWxldGVzIHRoZSBsb2NhbCBjb3B5IGltbWVkaWF0ZWx5LCBhbmQgYXR0ZW1wdHMgdG8gYWxzb1xuICAgKiAgIGRlbGV0ZSB0aGUgc2VydmVyJ3MgY29weS5cbiAgICogKiBsYXllci5Db25zdGFudHMuREVMRVRJT05fTU9ERS5NWV9ERVZJQ0VTOiBEZWxldGVzIHRoaXMgTWVzc2FnZSBmcm9tIGFsbCBvZiBteSBkZXZpY2VzOyBubyBlZmZlY3Qgb24gb3RoZXIgdXNlcnMuXG4gICAqXG4gICAqIEBtZXRob2QgZGVsZXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxldGlvbk1vZGVcbiAgICovXG4gIC8vIEFic3RyYWN0IE1ldGhvZFxuICBkZWxldGUobW9kZSkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmlzRGVzdHJveWVkKTtcbiAgICBsZXQgcXVlcnlTdHI7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTDpcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcXVlcnlTdHIgPSAnbW9kZT1hbGxfcGFydGljaXBhbnRzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLk1ZX0RFVklDRVM6XG4gICAgICAgIHF1ZXJ5U3RyID0gJ21vZGU9bXlfZGV2aWNlcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5kZWxldGlvbk1vZGVVbnN1cHBvcnRlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSB0aGlzLmlkO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgdGhpcy5feGhyKHtcbiAgICAgIHVybDogJz8nICsgcXVlcnlTdHIsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0sIChyZXN1bHQpID0+IHtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgKCFyZXN1bHQuZGF0YSB8fCAocmVzdWx0LmRhdGEuaWQgIT09ICdub3RfZm91bmQnICYmIHJlc3VsdC5kYXRhLmlkICE9PSAnYXV0aGVudGljYXRpb25fcmVxdWlyZWQnKSkpIHtcbiAgICAgICAgTWVzc2FnZS5sb2FkKGlkLCBjbGllbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fZGVsZXRlZCgpO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG5cblxuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX3RvT2JqZWN0KSB7XG4gICAgICB0aGlzLl90b09iamVjdCA9IHN1cGVyLnRvT2JqZWN0KCk7XG4gICAgICB0aGlzLl90b09iamVjdC5yZWNpcGllbnRTdGF0dXMgPSBVdGlsLmNsb25lKHRoaXMucmVjaXBpZW50U3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0O1xuICB9XG5cbiAgLypcbiAgICogQ3JlYXRlcyBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBTaW1pbGFyIHRvIF9wb3B1bGF0ZUZyb21TZXJ2ZXIsIGhvd2V2ZXIsIHRoaXMgbWV0aG9kIHRha2VzIGFcbiAgICogbWVzc2FnZSBkZXNjcmlwdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBtZXNzYWdlIGluc3RhbmNlIHVzaW5nIF9wb3B1bGF0ZUZyb21TZXJ2ZXJcbiAgICogdG8gc2V0dXAgdGhlIHZhbHVlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlRnJvbVNlcnZlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtZXNzYWdlIC0gU2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlfVxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVGcm9tU2VydmVyKG1lc3NhZ2UsIGNsaWVudCkge1xuICAgIGNvbnN0IGZyb21XZWJzb2NrZXQgPSBtZXNzYWdlLmZyb21XZWJzb2NrZXQ7XG4gICAgbGV0IGNvbnZlcnNhdGlvbklkO1xuICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbikge1xuICAgICAgY29udmVyc2F0aW9uSWQgPSBtZXNzYWdlLmNvbnZlcnNhdGlvbi5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udmVyc2F0aW9uSWQgPSBtZXNzYWdlLmNvbnZlcnNhdGlvbklkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29udmVyc2F0aW9uTWVzc2FnZSh7XG4gICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgIGZyb21TZXJ2ZXI6IG1lc3NhZ2UsXG4gICAgICBjbGllbnRJZDogY2xpZW50LmFwcElkLFxuICAgICAgX2Zyb21EQjogbWVzc2FnZS5fZnJvbURCLFxuICAgICAgX25vdGlmeTogZnJvbVdlYnNvY2tldCAmJiBtZXNzYWdlLmlzX3VucmVhZCAmJiBtZXNzYWdlLnNlbmRlci51c2VyX2lkICE9PSBjbGllbnQudXNlci51c2VySWQsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoaXMgTWVzc2FnZSBoYXMgYmVlbiByZWFkIGJ5IHRoaXMgdXNlci5cbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSBpc1JlYWQgcHJvZ3JhbWF0aWNhbGx5XG4gKlxuICogICAgICBtLmlzUmVhZCA9IHRydWU7XG4gKlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB0aGUgbWVzc2FnZSB3YXMgcmVhZCBieSB5b3VyIHVzZXIuXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuQ29udmVyc2F0aW9uTWVzc2FnZS5wcm90b3R5cGUuaXNSZWFkID0gZmFsc2U7XG5cbi8qKlxuICogUmVhZC9kZWxpdmVyeSBTdGF0ZSBvZiBhbGwgcGFydGljaXBhbnRzLlxuICpcbiAqIFRoaXMgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBwYXJ0aWNpcGFudCxcbiAqIGFuZCBhIHZhbHVlIG9mOlxuICpcbiAqICogbGF5ZXIuUkVDRUlQVF9TVEFURS5TRU5UXG4gKiAqIGxheWVyLlJFQ0VJUFRfU1RBVEUuREVMSVZFUkVEXG4gKiAqIGxheWVyLlJFQ0VJUFRfU1RBVEUuUkVBRFxuICogKiBsYXllci5SRUNFSVBUX1NUQVRFLlBFTkRJTkdcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5Db252ZXJzYXRpb25NZXNzYWdlLnByb3RvdHlwZS5yZWNpcGllbnRTdGF0dXMgPSBudWxsO1xuXG4vKipcbiAqIEhhdmUgdGhlIG90aGVyIHBhcnRpY2lwYW50cyByZWFkIHRoaXMgTWVzc2FnZSB5ZXQuXG4gKlxuICogVGhpcyB2YWx1ZSBpcyBvbmUgb2Y6XG4gKlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5BTExcbiAqICAqIGxheWVyLkNvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuU09NRVxuICogICogbGF5ZXIuQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5OT05FXG4gKlxuICogIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCBhbnkgdGltZSByZWNpcGllbnRTdGF0dXMgY2hhbmdlcy5cbiAqXG4gKiBTZWUgbGF5ZXIuTWVzc2FnZS5Db252ZXJzYXRpb25NZXNzYWdlLnJlY2lwaWVudFN0YXR1cyBmb3IgYSBtb3JlIGRldGFpbGVkIHJlcG9ydC5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5Db252ZXJzYXRpb25NZXNzYWdlLnByb3RvdHlwZS5yZWFkU3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5OT05FO1xuXG4vKipcbiAqIEhhdmUgdGhlIG90aGVyIHBhcnRpY2lwYW50cyByZWNlaXZlZCB0aGlzIE1lc3NhZ2UgeWV0LlxuICpcbiAgKiBUaGlzIHZhbHVlIGlzIG9uZSBvZjpcbiAqXG4gKiAgKiBsYXllci5Db25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLkFMTFxuICogICogbGF5ZXIuQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5TT01FXG4gKiAgKiBsYXllci5Db25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLk5PTkVcbiAqXG4gKiAgVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGFueSB0aW1lIHJlY2lwaWVudFN0YXR1cyBjaGFuZ2VzLlxuICpcbiAqIFNlZSBsYXllci5NZXNzYWdlLkNvbnZlcnNhdGlvbk1lc3NhZ2UucmVjaXBpZW50U3RhdHVzIGZvciBhIG1vcmUgZGV0YWlsZWQgcmVwb3J0LlxuICpcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5Db252ZXJzYXRpb25NZXNzYWdlLnByb3RvdHlwZS5kZWxpdmVyeVN0YXR1cyA9IENvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuTk9ORTtcblxuQ29udmVyc2F0aW9uTWVzc2FnZS5pbk9iamVjdElnbm9yZSA9IE1lc3NhZ2UuaW5PYmplY3RJZ25vcmU7XG5Db252ZXJzYXRpb25NZXNzYWdlLl9zdXBwb3J0ZWRFdmVudHMgPSBbXS5jb25jYXQoTWVzc2FnZS5fc3VwcG9ydGVkRXZlbnRzKTtcblJvb3QuaW5pdENsYXNzLmFwcGx5KENvbnZlcnNhdGlvbk1lc3NhZ2UsIFtDb252ZXJzYXRpb25NZXNzYWdlLCAnQ29udmVyc2F0aW9uTWVzc2FnZSddKTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVyc2F0aW9uTWVzc2FnZTtcbiJdfQ==
