'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Channel object represents a dialog amongst a large set
 * of participants.
 *
 * ```
 * var channel = client.createChannel({
 *   name: "frodo-the-dodo",
 *   members: ["layer:///identities/samwise", "layer:///identities/orc-army"],
 *   metadata: {
 *     subtopic: "Sauruman is the man.  And a Saurian",
 *     tooMuchInfo: {
 *       nose: "stuffed"
 *     }
 *   }
 * });
 *
 * channel.createMessage("Please don't eat me").send();
 * ```
 * NOTE: Sending a Message creates the Channel; this avoids having lots of unused channels being created.
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Channel.id: this property is worth being familiar with; it identifies the
 *   Channel and can be used in `client.getChannel(id)` to retrieve it.
 * * layer.Channel.name: this property names the channel; this may be human readable, though for localization purposes,
 *   you may instead want to use a common name that is distinct from your displayed name.  There can only be a single
 *   channel with a given name per app.
 * * layer.Channel.membership: Contains status information about your user's role in this Channel.
 * * layer.Channel.isCurrentParticipant: Shorthand for determining if your user is a member of the Channel.
 *
 * Methods:
 *
 * * layer.Channel.join() to join the Channel
 * * layer.Channel.leave() to leave the Channel
 * * layer.Channel.on() and layer.Channel.off(): event listeners built on top of the `backbone-events-standalone` npm project
 * * layer.Channel.createMessage() to send a message on the Channel.
 *
 * Events:
 *
 * * `channels:change`: Useful for observing changes to Channel name
 *   and updating rendering of your Channel
 *
 * Finally, to access a list of Messages in a Channel, see layer.Query.
 *
 * @class  layer.Channel
 * @experimental This feature is incomplete, and available as Preview only.
 * @extends layer.Container
 * @author  Michael Kantor
 */
var Root = require('../root');
var Syncable = require('./syncable');
var Container = require('./container');
var ChannelMessage = require('./channel-message');
var LayerError = require('../layer-error');
var LayerEvent = require('../layer-event');
var Util = require('../client-utils');
var Constants = require('../const');

var Channel = function (_Container) {
  _inherits(Channel, _Container);

  function Channel() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Channel);

    // Setup default values
    if (!options.membership) options.membership = {};

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Channel).call(this, options));

    _this._members = _this.getClient()._fixIdentities(options.members || []).map(function (item) {
      return item.id;
    });
    _this._register();
    return _this;
  }

  /**
   * Destroy the local copy of this Channel, cleaning up all resources
   * it consumes.
   *
   * @method destroy
   */


  _createClass(Channel, [{
    key: 'destroy',
    value: function destroy() {
      this.lastMessage = null;
      this.getClient()._removeChannel(this);
      _get(Object.getPrototypeOf(Channel.prototype), 'destroy', this).call(this);
      this.membership = null;
    }

    /**
     * Create a new layer.Message.ChannelMessage instance within this conversation
     *
     *      var message = channel.createMessage('hello');
     *
     *      var message = channel.createMessage({
     *          parts: [new layer.MessagePart({
     *                      body: 'hello',
     *                      mimeType: 'text/plain'
     *                  })]
     *      });
     *
     * See layer.Message.ChannelMessage for more options for creating the message.
     *
     * @method createMessage
     * @param  {String|Object} options - If its a string, a MessagePart is created around that string.
     * @param {layer.MessagePart[]} options.parts - An array of MessageParts.  There is some tolerance for
     *                                               it not being an array, or for it being a string to be turned
     *                                               into a MessagePart.
     * @return {layer.Message.ChannelMessage}
     */

  }, {
    key: 'createMessage',
    value: function createMessage() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var messageConfig = typeof options === 'string' ? {
        parts: [{ body: options, mimeType: 'text/plain' }]
      } : options;
      messageConfig.clientId = this.clientId;
      messageConfig.conversationId = this.id;

      return new ChannelMessage(messageConfig);
    }
  }, {
    key: '_setupMessage',
    value: function _setupMessage(message) {
      message.position = Channel.nextPosition;
      Channel.nextPosition += 8192;
    }

    /**
     * Gets the data for a Create request.
     *
     * The layer.SyncManager needs a callback to create the Conversation as it
     * looks NOW, not back when `send()` was called.  This method is called
     * by the layer.SyncManager to populate the POST data of the call.
     *
     * @method _getSendData
     * @private
     * @return {Object} Websocket data for the request
     */

  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      var isMetadataEmpty = Util.isEmpty(this.metadata);
      var members = this._members || [];
      if (members.indexOf(this.getClient().user.id) === -1) members.push(this.getClient().user.id);
      return {
        method: 'Channel.create',
        data: {
          name: this.name,
          metadata: isMetadataEmpty ? null : this.metadata,
          id: this.id,
          members: members
        }
      };
    }
  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(channel) {
      this._inPopulateFromServer = true;

      // Disable events if creating a new Conversation
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;
      this.name = channel.name;

      this.isCurrentParticipant = Boolean(channel.membership);
      this.membership = !channel.membership || !channel.membership.id ? null : this.getClient()._createObject(channel.membership);

      _get(Object.getPrototypeOf(Channel.prototype), '_populateFromServer', this).call(this, channel);
      this._register();

      this._disableEvents = false;
    }
  }, {
    key: '_createResultConflict',
    value: function _createResultConflict(data) {
      var channel = data.data;
      if (channel) {
        this._createSuccess(channel);
      } else {
        this.syncState = Constants.SYNC_STATE.NEW;
        this._syncCounter = 0;
        this.trigger('channels:sent-error', { error: data });
      }

      this._inPopulateFromServer = false;
    }
  }, {
    key: '__adjustName',
    value: function __adjustName(newValue) {
      if (this._inPopulateFromServer || this._inLayerParser || this.isNew() || this.isLoading) return;
      throw new Error(LayerError.dictionary.permissionDenied);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the name property will call this method and fire a
     * change event.
     *
     * @method __updateName
     * @private
     * @param  {string} newValue
     * @param  {string} oldValue
     */

  }, {
    key: '__updateName',
    value: function __updateName(newValue, oldValue) {
      this._triggerAsync('channels:change', {
        property: 'name',
        oldValue: oldValue,
        newValue: newValue
      });
    }

    /**
     * Add the following members to the Channel.
     *
     * Unlike Conversations, Channels do not maintain state information about their members.
     * As such, if the operation fails there is no actual state change
     * for the channel.  Currently the only errors exposed are from the layer.Client.SyncManager.
     *
     * @method addMembers
     * @param {String[]} members   Identity IDs of users to add to this Channel
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'addMembers',
    value: function addMembers(members) {
      var _this2 = this;

      members = this.getClient()._fixIdentities(members).map(function (item) {
        return item.id;
      });
      if (this.syncState === Constants.SYNC_STATE.NEW) {
        this._members = this._members.concat(members);
        return this;
      }

      // TODO: Should use the bulk operation when it becomes available.
      members.forEach(function (identityId) {
        _this2._xhr({
          url: '/members/' + identityId.replace(/^layer:\/\/\/identities\//, ''),
          method: 'PUT'
        });
      });
      return this;
    }

    /**
     * Remove the following members from the Channel.
     *
     * Not yet supported.
     *
     * @method removeMembers
     * @param {String[]} members   Identity IDs of users to remove from this Channel
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'removeMembers',
    value: function removeMembers(members) {
      var _this3 = this;

      members = this.getClient()._fixIdentities(members).map(function (item) {
        return item.id;
      });

      if (this.syncState === Constants.SYNC_STATE.NEW) {
        members.forEach(function (id) {
          var index = _this3._members.indexOf(id);
          if (index !== -1) _this3._members.splice(index, 1);
        });
        return this;
      }

      // TODO: Should use the bulk operation when it becomes available.
      members.forEach(function (identityId) {
        _this3._xhr({
          url: '/members/' + identityId.replace(/^layer:\/\/\/identities\//, ''),
          method: 'DELETE'
        });
      });
      return this;
    }

    /**
     * Add the current user to this channel.
     *
     * @method join
     * @return {layer.Channel} this
     *
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'join',
    value: function join() {
      return this.addMembers([this.getClient().user.id]);
    }

    /**
     * remove the current user from this channel.
     *
     * @method leave
     * @return {layer.Channel} this
     *
     *
     *
     *
     * @ignore until server supports it
     */

  }, {
    key: 'leave',
    value: function leave() {
      return this.removeMembers([this.getClient().user.id]);
    }

    /**
     * Return a Membership object for the specified Identity ID.
     *
     * If `members:loaded` is triggered, then your membership object
     * has been populated with data.
     *
     * If `members:loaded-error` is triggered, then your membership object
     * could not be loaded, either you have a connection error, or the user is not a member.
     *
     * ```
     * var membership = channel.getMember('FrodoTheDodo');
     * membership.on('membership:loaded', function(evt) {
     *    alert('He IS a member, quick, kick him out!');
     * });
     * membership.on('membership:loaded-error', function(evt) {
     *    if (evt.error.id === 'not_found') {
     *      alert('Sauruman, he is with the Elves!');
     *    } else {
     *      alert('Sauruman, would you please pick up your Palantir already? I can't connect!');
     *    }
     * });
     * ```
     * @method getMember
     * @param {String} identityId
     * @returns {layer.Membership}
     */

  }, {
    key: 'getMember',
    value: function getMember(identityId) {
      identityId = this.getClient()._fixIdentities([identityId])[0].id;
      var membershipId = this.id + '/members/' + identityId.replace(/layer:\/\/\/identities\//, '');
      return this.getClient().getMember(membershipId, true);
    }

    /**
     * Delete the channel; not currently supported.
     *
     * @method delete
     */

  }, {
    key: 'delete',
    value: function _delete() {
      this._delete('');
    }

    /**
     * LayerPatch will call this after changing any properties.
     *
     * Trigger any cleanup or events needed after these changes.
     *
     * TODO: Move this to layer.Container
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Mixed} newValue - New value of the property
     * @param  {Mixed} oldValue - Prior value of the property
     * @param  {string[]} paths - Array of paths specifically modified: ['participants'], ['metadata.keyA', 'metadata.keyB']
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      // Certain types of __update handlers are disabled while values are being set by
      // layer patch parser because the difference between setting a value (triggers an event)
      // and change a property of a value (triggers only this callback) result in inconsistent
      // behaviors.  Enable them long enough to allow __update calls to be made
      this._inLayerParser = false;
      try {
        var events = this._disableEvents;
        this._disableEvents = false;
        _get(Object.getPrototypeOf(Channel.prototype), '_handlePatchEvent', this).call(this, newValue, oldValue, paths);
        this._disableEvents = events;
      } catch (err) {
        // do nothing
      }
      this._inLayerParser = true;
    }

    /**
     * Register this Channel with the Client
     *
     * @method _register
     * @private
     */

  }, {
    key: '_register',
    value: function _register() {
      var client = this.getClient();
      client._addChannel(this);
    }
  }, {
    key: '_deleteResult',
    value: function _deleteResult(result, id) {
      var client = this.getClient();
      if (!result.success && (!result.data || result.data.id !== 'not_found' && result.data.id !== 'authentication_required')) {
        Channel.load(id, client);
      }
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Conversation instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Channel.prototype), 'toObject', this).call(this);
        this._toObject.membership = Util.clone(this.membership);
      }
      return this._toObject;
    }

    /**
     * Create a channel instance from a server representation of the channel.
     *
     * If the Channel already exists, will update the existing copy with
     * presumably newer values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} channel - Server representation of a Channel
     * @param  {layer.Client} client
     * @return {layer.Channel}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(channel, client) {
      return new Channel({
        client: client,
        fromServer: channel,
        _fromDB: channel._fromDB
      });
    }

    /**
     * Find or create a new Channel.
     *
     *      var channel = layer.Channel.create({
     *          members: ['a', 'b'],
     *          private: true,
     *          metadata: {
     *              titleDetails: 'I am not a detail!'
     *          },
     *          client: client,
     *          'channels:loaded': function(evt) {
     *
     *          }
     *      });
     *
     * Recommend using `client.createChannel({...})`
     * instead of `Channel.create({...})`.
     *
     * @method create
     * @static
     * @protected
     * @param  {Object} options
     * @param  {layer.Client} options.client
     * @param  {string[]/layer.Identity[]} options.members - Array of Participant IDs or layer.Identity objects to create a channel with.
     * @param {boolean} [options.private=false] - Create a private channel
     * @param {Object} [options.metadata={}] - Initial metadata for Channel
     * @return {layer.Channel}
     */

  }, {
    key: 'create',
    value: function create(options) {
      if (!options.client) throw new Error(LayerError.dictionary.clientMissing);
      if (!options.name) options.name = 'channel-' + String(Math.random()).replace(/\./, '');
      var newOptions = {
        name: options.name,
        private: options.private,
        members: options.members ? options.client._fixIdentities(options.members).map(function (item) {
          return item.id;
        }) : [],
        metadata: options.metadata,
        client: options.client
      };

      var channel = options.client.findCachedChannel(function (aChannel) {
        return aChannel.name === newOptions.name;
      });

      if (channel) {
        channel._sendDistinctEvent = new LayerEvent({
          target: channel,
          result: !options.metadata || Util.doesObjectMatch(options.metadata, channel.metadata) ? Channel.FOUND : Channel.FOUND_WITHOUT_REQUESTED_METADATA
        }, 'channels:sent');
      }

      return channel || new Channel(newOptions);
    }
  }]);

  return Channel;
}(Container);

/**
 * The Channel's name; this must be unique.
 *
 * Note that while you can use a displayable human readable name, you may also choose to use this
 * as an ID that you can easily localize to different languages.
 *
 * Must not be a UUID.
 *
 * @property {String} name
 */


Channel.prototype.name = '';

/**
 * The `membership` object contains details of this user's membership within this channel.
 *
 * NOTE: Initially, only `isMember` will be available.
 *
 * ```
 * {
 *     "isMember": true,
 *     "role": "user",
 *     "lastUnreadMessageId: "layer:///messages/UUID"
 * }
 * ```
 * @property {Object}
 */
Channel.prototype.membership = null;

Channel.prototype._members = null;

Channel.eventPrefix = 'channels';

// Math.pow(2, 64); a number larger than Number.MAX_SAFE_INTEGER, and larger than Java's Max Unsigned Long. And an easy to work with
// factor of 2
Channel.nextPosition = 18446744073709552000;

/**
 * Prefix to use when generating an ID for instances of this class
 * @type {String}
 * @static
 * @private
 */
Channel.prefixUUID = 'layer:///channels/';

Channel._supportedEvents = [

/**
 * The conversation is now on the server.
 *
 * Called after successfully creating the conversation
 * on the server.  The Result property is one of:
 *
 * * Channel.CREATED: A new Channel has been created
 * * Channel.FOUND: A matching named Channel has been found
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {string} event.result
 */
'channels:sent',

/**
 * An attempt to send this channel to the server has failed.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'channels:sent-error',

/**
 * The conversation is now loaded from the server.
 *
 * Note that this is only used in response to the layer.Channel.load() method.
 * from the server.
 * @event
 * @param {layer.LayerEvent} event
 */
'channels:loaded',

/**
 * An attempt to load this conversation from the server has failed.
 *
 * Note that this is only used in response to the layer.Channel.load() method.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'channels:loaded-error',

/**
 * The conversation has been deleted from the server.
 *
 * Caused by either a successful call to delete() on this instance
 * or by a remote user.
 * @event
 * @param {layer.LayerEvent} event
 */
'channels:delete',

/**
 * This channel has changed.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {Object[]} event.changes - Array of changes reported by this event
 * @param {Mixed} event.changes.newValue
 * @param {Mixed} event.changes.oldValue
 * @param {string} event.changes.property - Name of the property that changed
 * @param {layer.Conversation} event.target
 */
'channels:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Channel, [Channel, 'Channel']);
Syncable.subclasses.push(Channel);
module.exports = Channel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvY2hhbm5lbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURBLElBQU0sT0FBTyxRQUFRLFNBQVIsQ0FBYjtBQUNBLElBQU0sV0FBVyxRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFNLFlBQVksUUFBUSxhQUFSLENBQWxCO0FBQ0EsSUFBTSxpQkFBaUIsUUFBUSxtQkFBUixDQUF2QjtBQUNBLElBQU0sYUFBYSxRQUFRLGdCQUFSLENBQW5CO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7QUFDQSxJQUFNLE9BQU8sUUFBUSxpQkFBUixDQUFiO0FBQ0EsSUFBTSxZQUFZLFFBQVEsVUFBUixDQUFsQjs7SUFFTSxPOzs7QUFDSixxQkFBMEI7QUFBQSxRQUFkLE9BQWMseURBQUosRUFBSTs7QUFBQTs7QUFDeEI7QUFDQSxRQUFJLENBQUMsUUFBUSxVQUFiLEVBQXlCLFFBQVEsVUFBUixHQUFxQixFQUFyQjs7QUFGRCwyRkFHbEIsT0FIa0I7O0FBSXhCLFVBQUssUUFBTCxHQUFnQixNQUFLLFNBQUwsR0FBaUIsY0FBakIsQ0FBZ0MsUUFBUSxPQUFSLElBQW1CLEVBQW5ELEVBQXVELEdBQXZELENBQTJEO0FBQUEsYUFBUSxLQUFLLEVBQWI7QUFBQSxLQUEzRCxDQUFoQjtBQUNBLFVBQUssU0FBTDtBQUx3QjtBQU16Qjs7QUFFRDs7Ozs7Ozs7Ozs4QkFNVTtBQUNSLFdBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFdBQUssU0FBTCxHQUFpQixjQUFqQixDQUFnQyxJQUFoQztBQUNBO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQ0FxQjRCO0FBQUEsVUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQzFCLFVBQU0sZ0JBQWlCLE9BQU8sT0FB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QWxFeUIsRUFrRU4sTUFsRU0sQ0FrRUMsU0FBUyxnQkFsRVYsQ0FBM0I7O0FBcUVBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsT0FBckIsRUFBOEIsQ0FBQyxPQUFELEVBQVUsU0FBVixDQUE5QjtBQUNBLFNBQVMsVUFBVCxDQUFvQixJQUFwQixDQUF5QixPQUF6QjtBQUNBLE9BQU8sT0FBUCxHQUFpQixPQUFqQiIsImZpbGUiOiJjaGFubmVsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIENoYW5uZWwgb2JqZWN0IHJlcHJlc2VudHMgYSBkaWFsb2cgYW1vbmdzdCBhIGxhcmdlIHNldFxuICogb2YgcGFydGljaXBhbnRzLlxuICpcbiAqIGBgYFxuICogdmFyIGNoYW5uZWwgPSBjbGllbnQuY3JlYXRlQ2hhbm5lbCh7XG4gKiAgIG5hbWU6IFwiZnJvZG8tdGhlLWRvZG9cIixcbiAqICAgbWVtYmVyczogW1wibGF5ZXI6Ly8vaWRlbnRpdGllcy9zYW13aXNlXCIsIFwibGF5ZXI6Ly8vaWRlbnRpdGllcy9vcmMtYXJteVwiXSxcbiAqICAgbWV0YWRhdGE6IHtcbiAqICAgICBzdWJ0b3BpYzogXCJTYXVydW1hbiBpcyB0aGUgbWFuLiAgQW5kIGEgU2F1cmlhblwiLFxuICogICAgIHRvb011Y2hJbmZvOiB7XG4gKiAgICAgICBub3NlOiBcInN0dWZmZWRcIlxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKlxuICogY2hhbm5lbC5jcmVhdGVNZXNzYWdlKFwiUGxlYXNlIGRvbid0IGVhdCBtZVwiKS5zZW5kKCk7XG4gKiBgYGBcbiAqIE5PVEU6IFNlbmRpbmcgYSBNZXNzYWdlIGNyZWF0ZXMgdGhlIENoYW5uZWw7IHRoaXMgYXZvaWRzIGhhdmluZyBsb3RzIG9mIHVudXNlZCBjaGFubmVscyBiZWluZyBjcmVhdGVkLlxuICpcbiAqIEtleSBtZXRob2RzLCBldmVudHMgYW5kIHByb3BlcnRpZXMgZm9yIGdldHRpbmcgc3RhcnRlZDpcbiAqXG4gKiBQcm9wZXJ0aWVzOlxuICpcbiAqICogbGF5ZXIuQ2hhbm5lbC5pZDogdGhpcyBwcm9wZXJ0eSBpcyB3b3J0aCBiZWluZyBmYW1pbGlhciB3aXRoOyBpdCBpZGVudGlmaWVzIHRoZVxuICogICBDaGFubmVsIGFuZCBjYW4gYmUgdXNlZCBpbiBgY2xpZW50LmdldENoYW5uZWwoaWQpYCB0byByZXRyaWV2ZSBpdC5cbiAqICogbGF5ZXIuQ2hhbm5lbC5uYW1lOiB0aGlzIHByb3BlcnR5IG5hbWVzIHRoZSBjaGFubmVsOyB0aGlzIG1heSBiZSBodW1hbiByZWFkYWJsZSwgdGhvdWdoIGZvciBsb2NhbGl6YXRpb24gcHVycG9zZXMsXG4gKiAgIHlvdSBtYXkgaW5zdGVhZCB3YW50IHRvIHVzZSBhIGNvbW1vbiBuYW1lIHRoYXQgaXMgZGlzdGluY3QgZnJvbSB5b3VyIGRpc3BsYXllZCBuYW1lLiAgVGhlcmUgY2FuIG9ubHkgYmUgYSBzaW5nbGVcbiAqICAgY2hhbm5lbCB3aXRoIGEgZ2l2ZW4gbmFtZSBwZXIgYXBwLlxuICogKiBsYXllci5DaGFubmVsLm1lbWJlcnNoaXA6IENvbnRhaW5zIHN0YXR1cyBpbmZvcm1hdGlvbiBhYm91dCB5b3VyIHVzZXIncyByb2xlIGluIHRoaXMgQ2hhbm5lbC5cbiAqICogbGF5ZXIuQ2hhbm5lbC5pc0N1cnJlbnRQYXJ0aWNpcGFudDogU2hvcnRoYW5kIGZvciBkZXRlcm1pbmluZyBpZiB5b3VyIHVzZXIgaXMgYSBtZW1iZXIgb2YgdGhlIENoYW5uZWwuXG4gKlxuICogTWV0aG9kczpcbiAqXG4gKiAqIGxheWVyLkNoYW5uZWwuam9pbigpIHRvIGpvaW4gdGhlIENoYW5uZWxcbiAqICogbGF5ZXIuQ2hhbm5lbC5sZWF2ZSgpIHRvIGxlYXZlIHRoZSBDaGFubmVsXG4gKiAqIGxheWVyLkNoYW5uZWwub24oKSBhbmQgbGF5ZXIuQ2hhbm5lbC5vZmYoKTogZXZlbnQgbGlzdGVuZXJzIGJ1aWx0IG9uIHRvcCBvZiB0aGUgYGJhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lYCBucG0gcHJvamVjdFxuICogKiBsYXllci5DaGFubmVsLmNyZWF0ZU1lc3NhZ2UoKSB0byBzZW5kIGEgbWVzc2FnZSBvbiB0aGUgQ2hhbm5lbC5cbiAqXG4gKiBFdmVudHM6XG4gKlxuICogKiBgY2hhbm5lbHM6Y2hhbmdlYDogVXNlZnVsIGZvciBvYnNlcnZpbmcgY2hhbmdlcyB0byBDaGFubmVsIG5hbWVcbiAqICAgYW5kIHVwZGF0aW5nIHJlbmRlcmluZyBvZiB5b3VyIENoYW5uZWxcbiAqXG4gKiBGaW5hbGx5LCB0byBhY2Nlc3MgYSBsaXN0IG9mIE1lc3NhZ2VzIGluIGEgQ2hhbm5lbCwgc2VlIGxheWVyLlF1ZXJ5LlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuQ2hhbm5lbFxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGZlYXR1cmUgaXMgaW5jb21wbGV0ZSwgYW5kIGF2YWlsYWJsZSBhcyBQcmV2aWV3IG9ubHkuXG4gKiBAZXh0ZW5kcyBsYXllci5Db250YWluZXJcbiAqIEBhdXRob3IgIE1pY2hhZWwgS2FudG9yXG4gKi9cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuLi9yb290Jyk7XG5jb25zdCBTeW5jYWJsZSA9IHJlcXVpcmUoJy4vc3luY2FibGUnKTtcbmNvbnN0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJyk7XG5jb25zdCBDaGFubmVsTWVzc2FnZSA9IHJlcXVpcmUoJy4vY2hhbm5lbC1tZXNzYWdlJyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IExheWVyRXZlbnQgPSByZXF1aXJlKCcuLi9sYXllci1ldmVudCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL2NsaWVudC11dGlscycpO1xuY29uc3QgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFNldHVwIGRlZmF1bHQgdmFsdWVzXG4gICAgaWYgKCFvcHRpb25zLm1lbWJlcnNoaXApIG9wdGlvbnMubWVtYmVyc2hpcCA9IHt9O1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuX21lbWJlcnMgPSB0aGlzLmdldENsaWVudCgpLl9maXhJZGVudGl0aWVzKG9wdGlvbnMubWVtYmVycyB8fCBbXSkubWFwKGl0ZW0gPT4gaXRlbS5pZCk7XG4gICAgdGhpcy5fcmVnaXN0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBsb2NhbCBjb3B5IG9mIHRoaXMgQ2hhbm5lbCwgY2xlYW5pbmcgdXAgYWxsIHJlc291cmNlc1xuICAgKiBpdCBjb25zdW1lcy5cbiAgICpcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGFzdE1lc3NhZ2UgPSBudWxsO1xuICAgIHRoaXMuZ2V0Q2xpZW50KCkuX3JlbW92ZUNoYW5uZWwodGhpcyk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMubWVtYmVyc2hpcCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGxheWVyLk1lc3NhZ2UuQ2hhbm5lbE1lc3NhZ2UgaW5zdGFuY2Ugd2l0aGluIHRoaXMgY29udmVyc2F0aW9uXG4gICAqXG4gICAqICAgICAgdmFyIG1lc3NhZ2UgPSBjaGFubmVsLmNyZWF0ZU1lc3NhZ2UoJ2hlbGxvJyk7XG4gICAqXG4gICAqICAgICAgdmFyIG1lc3NhZ2UgPSBjaGFubmVsLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgKiAgICAgICAgICBwYXJ0czogW25ldyBsYXllci5NZXNzYWdlUGFydCh7XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdoZWxsbycsXG4gICAqICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbidcbiAgICogICAgICAgICAgICAgICAgICB9KV1cbiAgICogICAgICB9KTtcbiAgICpcbiAgICogU2VlIGxheWVyLk1lc3NhZ2UuQ2hhbm5lbE1lc3NhZ2UgZm9yIG1vcmUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlTWVzc2FnZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zIC0gSWYgaXRzIGEgc3RyaW5nLCBhIE1lc3NhZ2VQYXJ0IGlzIGNyZWF0ZWQgYXJvdW5kIHRoYXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2VQYXJ0W119IG9wdGlvbnMucGFydHMgLSBBbiBhcnJheSBvZiBNZXNzYWdlUGFydHMuICBUaGVyZSBpcyBzb21lIHRvbGVyYW5jZSBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IG5vdCBiZWluZyBhbiBhcnJheSwgb3IgZm9yIGl0IGJlaW5nIGEgc3RyaW5nIHRvIGJlIHR1cm5lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50byBhIE1lc3NhZ2VQYXJ0LlxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlLkNoYW5uZWxNZXNzYWdlfVxuICAgKi9cbiAgY3JlYXRlTWVzc2FnZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlQ29uZmlnID0gKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykgPyB7XG4gICAgICBwYXJ0czogW3sgYm9keTogb3B0aW9ucywgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyB9XSxcbiAgICB9IDogb3B0aW9ucztcbiAgICBtZXNzYWdlQ29uZmlnLmNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcbiAgICBtZXNzYWdlQ29uZmlnLmNvbnZlcnNhdGlvbklkID0gdGhpcy5pZDtcblxuICAgIHJldHVybiBuZXcgQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZUNvbmZpZyk7XG4gIH1cblxuICBfc2V0dXBNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlLnBvc2l0aW9uID0gQ2hhbm5lbC5uZXh0UG9zaXRpb247XG4gICAgQ2hhbm5lbC5uZXh0UG9zaXRpb24gKz0gODE5MjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhIGZvciBhIENyZWF0ZSByZXF1ZXN0LlxuICAgKlxuICAgKiBUaGUgbGF5ZXIuU3luY01hbmFnZXIgbmVlZHMgYSBjYWxsYmFjayB0byBjcmVhdGUgdGhlIENvbnZlcnNhdGlvbiBhcyBpdFxuICAgKiBsb29rcyBOT1csIG5vdCBiYWNrIHdoZW4gYHNlbmQoKWAgd2FzIGNhbGxlZC4gIFRoaXMgbWV0aG9kIGlzIGNhbGxlZFxuICAgKiBieSB0aGUgbGF5ZXIuU3luY01hbmFnZXIgdG8gcG9wdWxhdGUgdGhlIFBPU1QgZGF0YSBvZiB0aGUgY2FsbC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0U2VuZERhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBXZWJzb2NrZXQgZGF0YSBmb3IgdGhlIHJlcXVlc3RcbiAgICovXG4gIF9nZXRTZW5kRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaXNNZXRhZGF0YUVtcHR5ID0gVXRpbC5pc0VtcHR5KHRoaXMubWV0YWRhdGEpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLl9tZW1iZXJzIHx8IFtdO1xuICAgIGlmIChtZW1iZXJzLmluZGV4T2YodGhpcy5nZXRDbGllbnQoKS51c2VyLmlkKSA9PT0gLTEpIG1lbWJlcnMucHVzaCh0aGlzLmdldENsaWVudCgpLnVzZXIuaWQpO1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6ICdDaGFubmVsLmNyZWF0ZScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbWV0YWRhdGE6IGlzTWV0YWRhdGFFbXB0eSA/IG51bGwgOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG5cbiAgX3BvcHVsYXRlRnJvbVNlcnZlcihjaGFubmVsKSB7XG4gICAgdGhpcy5faW5Qb3B1bGF0ZUZyb21TZXJ2ZXIgPSB0cnVlO1xuXG4gICAgLy8gRGlzYWJsZSBldmVudHMgaWYgY3JlYXRpbmcgYSBuZXcgQ29udmVyc2F0aW9uXG4gICAgLy8gV2Ugc3RpbGwgd2FudCBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnRzIGZvciBhbnl0aGluZyB0aGF0IERPRVMgY2hhbmdlXG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9ICh0aGlzLnN5bmNTdGF0ZSA9PT0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXKTtcbiAgICB0aGlzLm5hbWUgPSBjaGFubmVsLm5hbWU7XG5cbiAgICB0aGlzLmlzQ3VycmVudFBhcnRpY2lwYW50ID0gQm9vbGVhbihjaGFubmVsLm1lbWJlcnNoaXApO1xuICAgIHRoaXMubWVtYmVyc2hpcCA9ICFjaGFubmVsLm1lbWJlcnNoaXAgfHxcbiAgICAgICFjaGFubmVsLm1lbWJlcnNoaXAuaWQgPyBudWxsIDogdGhpcy5nZXRDbGllbnQoKS5fY3JlYXRlT2JqZWN0KGNoYW5uZWwubWVtYmVyc2hpcCk7XG5cbiAgICBzdXBlci5fcG9wdWxhdGVGcm9tU2VydmVyKGNoYW5uZWwpO1xuICAgIHRoaXMuX3JlZ2lzdGVyKCk7XG5cbiAgICB0aGlzLl9kaXNhYmxlRXZlbnRzID0gZmFsc2U7XG4gIH1cblxuICBfY3JlYXRlUmVzdWx0Q29uZmxpY3QoZGF0YSkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBkYXRhLmRhdGE7XG4gICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVN1Y2Nlc3MoY2hhbm5lbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3luY1N0YXRlID0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXO1xuICAgICAgdGhpcy5fc3luY0NvdW50ZXIgPSAwO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFubmVsczpzZW50LWVycm9yJywgeyBlcnJvcjogZGF0YSB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9pblBvcHVsYXRlRnJvbVNlcnZlciA9IGZhbHNlO1xuICB9XG5cbiAgX19hZGp1c3ROYW1lKG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2luUG9wdWxhdGVGcm9tU2VydmVyIHx8IHRoaXMuX2luTGF5ZXJQYXJzZXIgfHwgdGhpcy5pc05ldygpIHx8IHRoaXMuaXNMb2FkaW5nKSByZXR1cm47XG4gICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5wZXJtaXNzaW9uRGVuaWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBfXyBNZXRob2RzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgKlxuICAgKiBBbnkgY2hhbmdlIGluIHRoZSBuYW1lIHByb3BlcnR5IHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBhbmQgZmlyZSBhXG4gICAqIGNoYW5nZSBldmVudC5cbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZU5hbWVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG9sZFZhbHVlXG4gICAqL1xuICBfX3VwZGF0ZU5hbWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjaGFubmVsczpjaGFuZ2UnLCB7XG4gICAgICBwcm9wZXJ0eTogJ25hbWUnLFxuICAgICAgb2xkVmFsdWUsXG4gICAgICBuZXdWYWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGZvbGxvd2luZyBtZW1iZXJzIHRvIHRoZSBDaGFubmVsLlxuICAgKlxuICAgKiBVbmxpa2UgQ29udmVyc2F0aW9ucywgQ2hhbm5lbHMgZG8gbm90IG1haW50YWluIHN0YXRlIGluZm9ybWF0aW9uIGFib3V0IHRoZWlyIG1lbWJlcnMuXG4gICAqIEFzIHN1Y2gsIGlmIHRoZSBvcGVyYXRpb24gZmFpbHMgdGhlcmUgaXMgbm8gYWN0dWFsIHN0YXRlIGNoYW5nZVxuICAgKiBmb3IgdGhlIGNoYW5uZWwuICBDdXJyZW50bHkgdGhlIG9ubHkgZXJyb3JzIGV4cG9zZWQgYXJlIGZyb20gdGhlIGxheWVyLkNsaWVudC5TeW5jTWFuYWdlci5cbiAgICpcbiAgICogQG1ldGhvZCBhZGRNZW1iZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IG1lbWJlcnMgICBJZGVudGl0eSBJRHMgb2YgdXNlcnMgdG8gYWRkIHRvIHRoaXMgQ2hhbm5lbFxuICAgKiBAcmV0dXJuIHtsYXllci5DaGFubmVsfSB0aGlzXG4gICAqXG4gICAqXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBpZ25vcmUgdW50aWwgc2VydmVyIHN1cHBvcnRzIGl0XG4gICAqL1xuICBhZGRNZW1iZXJzKG1lbWJlcnMpIHtcbiAgICBtZW1iZXJzID0gdGhpcy5nZXRDbGllbnQoKS5fZml4SWRlbnRpdGllcyhtZW1iZXJzKS5tYXAoaXRlbSA9PiBpdGVtLmlkKTtcbiAgICBpZiAodGhpcy5zeW5jU3RhdGUgPT09IENvbnN0YW50cy5TWU5DX1NUQVRFLk5FVykge1xuICAgICAgdGhpcy5fbWVtYmVycyA9IHRoaXMuX21lbWJlcnMuY29uY2F0KG1lbWJlcnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU2hvdWxkIHVzZSB0aGUgYnVsayBvcGVyYXRpb24gd2hlbiBpdCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAgICBtZW1iZXJzLmZvckVhY2goKGlkZW50aXR5SWQpID0+IHtcbiAgICAgIHRoaXMuX3hocih7XG4gICAgICAgIHVybDogJy9tZW1iZXJzLycgKyBpZGVudGl0eUlkLnJlcGxhY2UoL15sYXllcjpcXC9cXC9cXC9pZGVudGl0aWVzXFwvLywgJycpLFxuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWVtYmVycyBmcm9tIHRoZSBDaGFubmVsLlxuICAgKlxuICAgKiBOb3QgeWV0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogQG1ldGhvZCByZW1vdmVNZW1iZXJzXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IG1lbWJlcnMgICBJZGVudGl0eSBJRHMgb2YgdXNlcnMgdG8gcmVtb3ZlIGZyb20gdGhpcyBDaGFubmVsXG4gICAqIEByZXR1cm4ge2xheWVyLkNoYW5uZWx9IHRoaXNcbiAgICpcbiAgICpcbiAgICpcbiAgICpcbiAgICpcbiAgICogQGlnbm9yZSB1bnRpbCBzZXJ2ZXIgc3VwcG9ydHMgaXRcbiAgICovXG4gIHJlbW92ZU1lbWJlcnMobWVtYmVycykge1xuICAgIG1lbWJlcnMgPSB0aGlzLmdldENsaWVudCgpLl9maXhJZGVudGl0aWVzKG1lbWJlcnMpLm1hcChpdGVtID0+IGl0ZW0uaWQpO1xuXG4gICAgaWYgKHRoaXMuc3luY1N0YXRlID09PSBDb25zdGFudHMuU1lOQ19TVEFURS5ORVcpIHtcbiAgICAgIG1lbWJlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9tZW1iZXJzLmluZGV4T2YoaWQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB0aGlzLl9tZW1iZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZCB1c2UgdGhlIGJ1bGsgb3BlcmF0aW9uIHdoZW4gaXQgYmVjb21lcyBhdmFpbGFibGUuXG4gICAgbWVtYmVycy5mb3JFYWNoKChpZGVudGl0eUlkKSA9PiB7XG4gICAgICB0aGlzLl94aHIoe1xuICAgICAgICB1cmw6ICcvbWVtYmVycy8nICsgaWRlbnRpdHlJZC5yZXBsYWNlKC9ebGF5ZXI6XFwvXFwvXFwvaWRlbnRpdGllc1xcLy8sICcnKSxcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgY3VycmVudCB1c2VyIHRvIHRoaXMgY2hhbm5lbC5cbiAgICpcbiAgICogQG1ldGhvZCBqb2luXG4gICAqIEByZXR1cm4ge2xheWVyLkNoYW5uZWx9IHRoaXNcbiAgICpcbiAgICpcbiAgICpcbiAgICpcbiAgICpcbiAgICogQGlnbm9yZSB1bnRpbCBzZXJ2ZXIgc3VwcG9ydHMgaXRcbiAgICovXG4gIGpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTWVtYmVycyhbdGhpcy5nZXRDbGllbnQoKS51c2VyLmlkXSk7XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIHRoZSBjdXJyZW50IHVzZXIgZnJvbSB0aGlzIGNoYW5uZWwuXG4gICAqXG4gICAqIEBtZXRob2QgbGVhdmVcbiAgICogQHJldHVybiB7bGF5ZXIuQ2hhbm5lbH0gdGhpc1xuICAgKlxuICAgKlxuICAgKlxuICAgKlxuICAgKiBAaWdub3JlIHVudGlsIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgKi9cbiAgbGVhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWVtYmVycyhbdGhpcy5nZXRDbGllbnQoKS51c2VyLmlkXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgTWVtYmVyc2hpcCBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgSWRlbnRpdHkgSUQuXG4gICAqXG4gICAqIElmIGBtZW1iZXJzOmxvYWRlZGAgaXMgdHJpZ2dlcmVkLCB0aGVuIHlvdXIgbWVtYmVyc2hpcCBvYmplY3RcbiAgICogaGFzIGJlZW4gcG9wdWxhdGVkIHdpdGggZGF0YS5cbiAgICpcbiAgICogSWYgYG1lbWJlcnM6bG9hZGVkLWVycm9yYCBpcyB0cmlnZ2VyZWQsIHRoZW4geW91ciBtZW1iZXJzaGlwIG9iamVjdFxuICAgKiBjb3VsZCBub3QgYmUgbG9hZGVkLCBlaXRoZXIgeW91IGhhdmUgYSBjb25uZWN0aW9uIGVycm9yLCBvciB0aGUgdXNlciBpcyBub3QgYSBtZW1iZXIuXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgbWVtYmVyc2hpcCA9IGNoYW5uZWwuZ2V0TWVtYmVyKCdGcm9kb1RoZURvZG8nKTtcbiAgICogbWVtYmVyc2hpcC5vbignbWVtYmVyc2hpcDpsb2FkZWQnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgYWxlcnQoJ0hlIElTIGEgbWVtYmVyLCBxdWljaywga2ljayBoaW0gb3V0IScpO1xuICAgKiB9KTtcbiAgICogbWVtYmVyc2hpcC5vbignbWVtYmVyc2hpcDpsb2FkZWQtZXJyb3InLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgaWYgKGV2dC5lcnJvci5pZCA9PT0gJ25vdF9mb3VuZCcpIHtcbiAgICogICAgICBhbGVydCgnU2F1cnVtYW4sIGhlIGlzIHdpdGggdGhlIEVsdmVzIScpO1xuICAgKiAgICB9IGVsc2Uge1xuICAgKiAgICAgIGFsZXJ0KCdTYXVydW1hbiwgd291bGQgeW91IHBsZWFzZSBwaWNrIHVwIHlvdXIgUGFsYW50aXIgYWxyZWFkeT8gSSBjYW4ndCBjb25uZWN0IScpO1xuICAgKiAgICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogQG1ldGhvZCBnZXRNZW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aXR5SWRcbiAgICogQHJldHVybnMge2xheWVyLk1lbWJlcnNoaXB9XG4gICAqL1xuICBnZXRNZW1iZXIoaWRlbnRpdHlJZCkge1xuICAgIGlkZW50aXR5SWQgPSB0aGlzLmdldENsaWVudCgpLl9maXhJZGVudGl0aWVzKFtpZGVudGl0eUlkXSlbMF0uaWQ7XG4gICAgY29uc3QgbWVtYmVyc2hpcElkID0gdGhpcy5pZCArICcvbWVtYmVycy8nICsgaWRlbnRpdHlJZC5yZXBsYWNlKC9sYXllcjpcXC9cXC9cXC9pZGVudGl0aWVzXFwvLywgJycpO1xuICAgIHJldHVybiB0aGlzLmdldENsaWVudCgpLmdldE1lbWJlcihtZW1iZXJzaGlwSWQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgY2hhbm5lbDsgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgZGVsZXRlXG4gICAqL1xuICBkZWxldGUoKSB7XG4gICAgdGhpcy5fZGVsZXRlKCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMYXllclBhdGNoIHdpbGwgY2FsbCB0aGlzIGFmdGVyIGNoYW5naW5nIGFueSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUcmlnZ2VyIGFueSBjbGVhbnVwIG9yIGV2ZW50cyBuZWVkZWQgYWZ0ZXIgdGhlc2UgY2hhbmdlcy5cbiAgICpcbiAgICogVE9ETzogTW92ZSB0aGlzIHRvIGxheWVyLkNvbnRhaW5lclxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVQYXRjaEV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge01peGVkfSBuZXdWYWx1ZSAtIE5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtICB7TWl4ZWR9IG9sZFZhbHVlIC0gUHJpb3IgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyAtIEFycmF5IG9mIHBhdGhzIHNwZWNpZmljYWxseSBtb2RpZmllZDogWydwYXJ0aWNpcGFudHMnXSwgWydtZXRhZGF0YS5rZXlBJywgJ21ldGFkYXRhLmtleUInXVxuICAgKi9cbiAgX2hhbmRsZVBhdGNoRXZlbnQobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocykge1xuICAgIC8vIENlcnRhaW4gdHlwZXMgb2YgX191cGRhdGUgaGFuZGxlcnMgYXJlIGRpc2FibGVkIHdoaWxlIHZhbHVlcyBhcmUgYmVpbmcgc2V0IGJ5XG4gICAgLy8gbGF5ZXIgcGF0Y2ggcGFyc2VyIGJlY2F1c2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzZXR0aW5nIGEgdmFsdWUgKHRyaWdnZXJzIGFuIGV2ZW50KVxuICAgIC8vIGFuZCBjaGFuZ2UgYSBwcm9wZXJ0eSBvZiBhIHZhbHVlICh0cmlnZ2VycyBvbmx5IHRoaXMgY2FsbGJhY2spIHJlc3VsdCBpbiBpbmNvbnNpc3RlbnRcbiAgICAvLyBiZWhhdmlvcnMuICBFbmFibGUgdGhlbSBsb25nIGVub3VnaCB0byBhbGxvdyBfX3VwZGF0ZSBjYWxscyB0byBiZSBtYWRlXG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9kaXNhYmxlRXZlbnRzO1xuICAgICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgc3VwZXIuX2hhbmRsZVBhdGNoRXZlbnQobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocyk7XG4gICAgICB0aGlzLl9kaXNhYmxlRXZlbnRzID0gZXZlbnRzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICB0aGlzLl9pbkxheWVyUGFyc2VyID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB0aGlzIENoYW5uZWwgd2l0aCB0aGUgQ2xpZW50XG4gICAqXG4gICAqIEBtZXRob2QgX3JlZ2lzdGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXIoKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBjbGllbnQuX2FkZENoYW5uZWwodGhpcyk7XG4gIH1cblxuICBfZGVsZXRlUmVzdWx0KHJlc3VsdCwgaWQpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgKCFyZXN1bHQuZGF0YSB8fCAocmVzdWx0LmRhdGEuaWQgIT09ICdub3RfZm91bmQnICYmIHJlc3VsdC5kYXRhLmlkICE9PSAnYXV0aGVudGljYXRpb25fcmVxdWlyZWQnKSkpIHtcbiAgICAgIENoYW5uZWwubG9hZChpZCwgY2xpZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogT2JqZWN0IHdpbGwgaGF2ZSBhbGwgdGhlIHNhbWUgcHVibGljIHByb3BlcnRpZXMgYXMgdGhpc1xuICAgKiBDb252ZXJzYXRpb24gaW5zdGFuY2UuICBOZXcgb2JqZWN0IGlzIHJldHVybmVkIGFueSB0aW1lXG4gICAqIGFueSBvZiB0aGlzIG9iamVjdCdzIHByb3BlcnRpZXMgY2hhbmdlLlxuICAgKlxuICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gUE9KTyB2ZXJzaW9uIG9mIHRoaXMuXG4gICAqL1xuICB0b09iamVjdCgpIHtcbiAgICBpZiAoIXRoaXMuX3RvT2JqZWN0KSB7XG4gICAgICB0aGlzLl90b09iamVjdCA9IHN1cGVyLnRvT2JqZWN0KCk7XG4gICAgICB0aGlzLl90b09iamVjdC5tZW1iZXJzaGlwID0gVXRpbC5jbG9uZSh0aGlzLm1lbWJlcnNoaXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgY2hhbm5lbCBpbnN0YW5jZSBmcm9tIGEgc2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjaGFubmVsLlxuICAgKlxuICAgKiBJZiB0aGUgQ2hhbm5lbCBhbHJlYWR5IGV4aXN0cywgd2lsbCB1cGRhdGUgdGhlIGV4aXN0aW5nIGNvcHkgd2l0aFxuICAgKiBwcmVzdW1hYmx5IG5ld2VyIHZhbHVlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlRnJvbVNlcnZlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjaGFubmVsIC0gU2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgQ2hhbm5lbFxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcmV0dXJuIHtsYXllci5DaGFubmVsfVxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVGcm9tU2VydmVyKGNoYW5uZWwsIGNsaWVudCkge1xuICAgIHJldHVybiBuZXcgQ2hhbm5lbCh7XG4gICAgICBjbGllbnQsXG4gICAgICBmcm9tU2VydmVyOiBjaGFubmVsLFxuICAgICAgX2Zyb21EQjogY2hhbm5lbC5fZnJvbURCLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgb3IgY3JlYXRlIGEgbmV3IENoYW5uZWwuXG4gICAqXG4gICAqICAgICAgdmFyIGNoYW5uZWwgPSBsYXllci5DaGFubmVsLmNyZWF0ZSh7XG4gICAqICAgICAgICAgIG1lbWJlcnM6IFsnYScsICdiJ10sXG4gICAqICAgICAgICAgIHByaXZhdGU6IHRydWUsXG4gICAqICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAqICAgICAgICAgICAgICB0aXRsZURldGFpbHM6ICdJIGFtIG5vdCBhIGRldGFpbCEnXG4gICAqICAgICAgICAgIH0sXG4gICAqICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgKiAgICAgICAgICAnY2hhbm5lbHM6bG9hZGVkJzogZnVuY3Rpb24oZXZ0KSB7XG4gICAqXG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICpcbiAgICogUmVjb21tZW5kIHVzaW5nIGBjbGllbnQuY3JlYXRlQ2hhbm5lbCh7Li4ufSlgXG4gICAqIGluc3RlYWQgb2YgYENoYW5uZWwuY3JlYXRlKHsuLi59KWAuXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEBzdGF0aWNcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7bGF5ZXIuQ2xpZW50fSBvcHRpb25zLmNsaWVudFxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXS9sYXllci5JZGVudGl0eVtdfSBvcHRpb25zLm1lbWJlcnMgLSBBcnJheSBvZiBQYXJ0aWNpcGFudCBJRHMgb3IgbGF5ZXIuSWRlbnRpdHkgb2JqZWN0cyB0byBjcmVhdGUgYSBjaGFubmVsIHdpdGguXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJpdmF0ZT1mYWxzZV0gLSBDcmVhdGUgYSBwcml2YXRlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1ldGFkYXRhPXt9XSAtIEluaXRpYWwgbWV0YWRhdGEgZm9yIENoYW5uZWxcbiAgICogQHJldHVybiB7bGF5ZXIuQ2hhbm5lbH1cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5jbGllbnQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIG9wdGlvbnMubmFtZSA9ICdjaGFubmVsLScgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFwuLywgJycpO1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7XG4gICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICBwcml2YXRlOiBvcHRpb25zLnByaXZhdGUsXG4gICAgICBtZW1iZXJzOiBvcHRpb25zLm1lbWJlcnMgPyBvcHRpb25zLmNsaWVudC5fZml4SWRlbnRpdGllcyhvcHRpb25zLm1lbWJlcnMpLm1hcChpdGVtID0+IGl0ZW0uaWQpIDogW10sXG4gICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgIGNsaWVudDogb3B0aW9ucy5jbGllbnQsXG4gICAgfTtcblxuICAgIGNvbnN0IGNoYW5uZWwgPSBvcHRpb25zLmNsaWVudC5maW5kQ2FjaGVkQ2hhbm5lbChhQ2hhbm5lbCA9PiBhQ2hhbm5lbC5uYW1lID09PSBuZXdPcHRpb25zLm5hbWUpO1xuXG4gICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgIGNoYW5uZWwuX3NlbmREaXN0aW5jdEV2ZW50ID0gbmV3IExheWVyRXZlbnQoe1xuICAgICAgICB0YXJnZXQ6IGNoYW5uZWwsXG4gICAgICAgIHJlc3VsdDogIW9wdGlvbnMubWV0YWRhdGEgfHwgVXRpbC5kb2VzT2JqZWN0TWF0Y2gob3B0aW9ucy5tZXRhZGF0YSwgY2hhbm5lbC5tZXRhZGF0YSkgP1xuICAgICAgICAgIENoYW5uZWwuRk9VTkQgOiBDaGFubmVsLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBLFxuICAgICAgfSwgJ2NoYW5uZWxzOnNlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbm5lbCB8fCBuZXcgQ2hhbm5lbChuZXdPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBDaGFubmVsJ3MgbmFtZTsgdGhpcyBtdXN0IGJlIHVuaXF1ZS5cbiAqXG4gKiBOb3RlIHRoYXQgd2hpbGUgeW91IGNhbiB1c2UgYSBkaXNwbGF5YWJsZSBodW1hbiByZWFkYWJsZSBuYW1lLCB5b3UgbWF5IGFsc28gY2hvb3NlIHRvIHVzZSB0aGlzXG4gKiBhcyBhbiBJRCB0aGF0IHlvdSBjYW4gZWFzaWx5IGxvY2FsaXplIHRvIGRpZmZlcmVudCBsYW5ndWFnZXMuXG4gKlxuICogTXVzdCBub3QgYmUgYSBVVUlELlxuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLm5hbWUgPSAnJztcblxuLyoqXG4gKiBUaGUgYG1lbWJlcnNoaXBgIG9iamVjdCBjb250YWlucyBkZXRhaWxzIG9mIHRoaXMgdXNlcidzIG1lbWJlcnNoaXAgd2l0aGluIHRoaXMgY2hhbm5lbC5cbiAqXG4gKiBOT1RFOiBJbml0aWFsbHksIG9ubHkgYGlzTWVtYmVyYCB3aWxsIGJlIGF2YWlsYWJsZS5cbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAgICBcImlzTWVtYmVyXCI6IHRydWUsXG4gKiAgICAgXCJyb2xlXCI6IFwidXNlclwiLFxuICogICAgIFwibGFzdFVucmVhZE1lc3NhZ2VJZDogXCJsYXllcjovLy9tZXNzYWdlcy9VVUlEXCJcbiAqIH1cbiAqIGBgYFxuICogQHByb3BlcnR5IHtPYmplY3R9XG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLm1lbWJlcnNoaXAgPSBudWxsO1xuXG5DaGFubmVsLnByb3RvdHlwZS5fbWVtYmVycyA9IG51bGw7XG5cbkNoYW5uZWwuZXZlbnRQcmVmaXggPSAnY2hhbm5lbHMnO1xuXG4vLyBNYXRoLnBvdygyLCA2NCk7IGEgbnVtYmVyIGxhcmdlciB0aGFuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBhbmQgbGFyZ2VyIHRoYW4gSmF2YSdzIE1heCBVbnNpZ25lZCBMb25nLiBBbmQgYW4gZWFzeSB0byB3b3JrIHdpdGhcbi8vIGZhY3RvciBvZiAyXG5DaGFubmVsLm5leHRQb3NpdGlvbiA9IDE4NDQ2NzQ0MDczNzA5NTUyMDAwO1xuXG4vKipcbiAqIFByZWZpeCB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIGFuIElEIGZvciBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzc1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBzdGF0aWNcbiAqIEBwcml2YXRlXG4gKi9cbkNoYW5uZWwucHJlZml4VVVJRCA9ICdsYXllcjovLy9jaGFubmVscy8nO1xuXG5DaGFubmVsLl9zdXBwb3J0ZWRFdmVudHMgPSBbXG5cbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gaXMgbm93IG9uIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIENhbGxlZCBhZnRlciBzdWNjZXNzZnVsbHkgY3JlYXRpbmcgdGhlIGNvbnZlcnNhdGlvblxuICAgKiBvbiB0aGUgc2VydmVyLiAgVGhlIFJlc3VsdCBwcm9wZXJ0eSBpcyBvbmUgb2Y6XG4gICAqXG4gICAqICogQ2hhbm5lbC5DUkVBVEVEOiBBIG5ldyBDaGFubmVsIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICogKiBDaGFubmVsLkZPVU5EOiBBIG1hdGNoaW5nIG5hbWVkIENoYW5uZWwgaGFzIGJlZW4gZm91bmRcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnJlc3VsdFxuICAgKi9cbiAgJ2NoYW5uZWxzOnNlbnQnLFxuXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHRvIHNlbmQgdGhpcyBjaGFubmVsIHRvIHRoZSBzZXJ2ZXIgaGFzIGZhaWxlZC5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldmVudC5lcnJvclxuICAgKi9cbiAgJ2NoYW5uZWxzOnNlbnQtZXJyb3InLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udmVyc2F0aW9uIGlzIG5vdyBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHVzZWQgaW4gcmVzcG9uc2UgdG8gdGhlIGxheWVyLkNoYW5uZWwubG9hZCgpIG1ldGhvZC5cbiAgICogZnJvbSB0aGUgc2VydmVyLlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldmVudFxuICAgKi9cbiAgJ2NoYW5uZWxzOmxvYWRlZCcsXG5cbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgdG8gbG9hZCB0aGlzIGNvbnZlcnNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaGFzIGZhaWxlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgb25seSB1c2VkIGluIHJlc3BvbnNlIHRvIHRoZSBsYXllci5DaGFubmVsLmxvYWQoKSBtZXRob2QuXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gZXZlbnQuZXJyb3JcbiAgICovXG4gICdjaGFubmVsczpsb2FkZWQtZXJyb3InLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udmVyc2F0aW9uIGhhcyBiZWVuIGRlbGV0ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBDYXVzZWQgYnkgZWl0aGVyIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGRlbGV0ZSgpIG9uIHRoaXMgaW5zdGFuY2VcbiAgICogb3IgYnkgYSByZW1vdGUgdXNlci5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICovXG4gICdjaGFubmVsczpkZWxldGUnLFxuXG4gIC8qKlxuICAgKiBUaGlzIGNoYW5uZWwgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGV2ZW50LmNoYW5nZXMgLSBBcnJheSBvZiBjaGFuZ2VzIHJlcG9ydGVkIGJ5IHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gZXZlbnQuY2hhbmdlcy5uZXdWYWx1ZVxuICAgKiBAcGFyYW0ge01peGVkfSBldmVudC5jaGFuZ2VzLm9sZFZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5jaGFuZ2VzLnByb3BlcnR5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9ufSBldmVudC50YXJnZXRcbiAgICovXG4gICdjaGFubmVsczpjaGFuZ2UnXS5jb25jYXQoU3luY2FibGUuX3N1cHBvcnRlZEV2ZW50cyk7XG5cblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoQ2hhbm5lbCwgW0NoYW5uZWwsICdDaGFubmVsJ10pO1xuU3luY2FibGUuc3ViY2xhc3Nlcy5wdXNoKENoYW5uZWwpO1xubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuIl19
