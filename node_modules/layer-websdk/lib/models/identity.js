'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Identity class represents an Identity of a user of your application.
 *
 * Identities are created by the System, never directly by apps.
 *
 * @class layer.Identity
 * @extends layer.Syncable
 */

/*
 * How Identities fit into the system:
 *
 * 1. As part of initialization, load the authenticated user's full Identity record so that the Client knows more than just the `userId` of its user.
 *    client.user = <Identity>
 * 2. Any time we get a Basic Identity via `message.sender` or Conversations, see if we have an Identity for that sender,
 *    and if not create one using the Basic Identity.  There should never be a duplicate Identity.
 * 3. Websocket CHANGE events will update Identity objects, as well as add new Full Identities, and downgrade Full Identities to Basic Identities.
 * 4. The Query API supports querying and paging through Identities
 * 5. The Query API loads Full Identities; these results will update the client._models.identities;
 *    upgrading Basic Identities if they match, and adding new Identities if they don't.
 * 6. DbManager will persist only UserIdentities, and only those that are Full Identities.  Basic Identities will be written
 *    to the Messages and Conversations tables anyways as part of those larger objects.
 * 7. API For explicit follows/unfollows
 */

var Syncable = require('./syncable');
var Root = require('../root');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var LayerError = require('../layer-error');

var Identity = function (_Syncable) {
  _inherits(Identity, _Syncable);

  function Identity() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Identity);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) {
      options.id = options.fromServer.id || '-';
    } else if (!options.id && options.userId) {
      options.id = Identity.prefixUUID + encodeURIComponent(options.userId);
    } else if (options.id && !options.userId) {
      options.userId = options.id.substring(Identity.prefixUUID.length);
    }

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    // The - is here to prevent Root from generating a UUID for an ID.  ID must map to UserID
    // and can't be randomly generated.  This only occurs from Platform API sending with `sender.name` and no identity.
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Identity).call(this, options));

    if (_this.id === '-') _this.id = '';

    _this.isInitializing = true;

    if (!_this._presence) {
      _this._presence = {
        status: null,
        lastSeenAt: null
      };
    }

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Identity
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.url && _this.id) {
      _this.url = _this.getClient().url + '/' + _this.id.substring(9);
    } else if (!_this.url) {
      _this.url = '';
    }
    _this.getClient()._addIdentity(_this);

    _this.getClient().on('online', function (evt) {
      if (!evt.isOnline) _this._updateValue(['_presence', 'status'], Identity.STATUS.OFFLINE);
    }, _this);

    _this.isInitializing = false;
    return _this;
  }

  _createClass(Identity, [{
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeIdentity(this);
      _get(Object.getPrototypeOf(Identity.prototype), 'destroy', this).call(this);
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Identity.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Identity.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} identity - Server representation of the identity
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(identity) {
      var _this2 = this;

      var client = this.getClient();

      // Disable events if creating a new Identity
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === SYNC_STATE.NEW;

      this._setSynced();

      this.userId = identity.user_id || '';

      this._updateValue(['avatarUrl'], identity.avatar_url);
      this._updateValue(['displayName'], identity.display_name);

      var isFullIdentity = 'metadata' in identity;

      // Handle Full Identity vs Basic Identity
      if (isFullIdentity) {
        this.url = identity.url;
        this.type = identity.type;

        this._updateValue(['emailAddress'], identity.email_address);
        this._updateValue(['lastName'], identity.last_name);
        this._updateValue(['firstName'], identity.first_name);
        this._updateValue(['metadata'], identity.metadata);
        this._updateValue(['publicKey'], identity.public_key);
        this._updateValue(['phoneNumber'], identity.phone_number);
        this.isFullIdentity = true;
      }

      if (!this.url && this.id) {
        this.url = this.getClient().url + this.id.substring(8);
      }

      this._disableEvents = false;

      // See if we have the Full Identity Object in database
      if (!this.isFullIdentity && client.isAuthenticated) {
        client.dbManager.getObjects('identities', [this.id], function (result) {
          if (result.length) _this2._populateFromServer(result[0]);
        });
      }
    }

    /**
     * Update the property; trigger a change event, IF the value has changed.
     *
     * @method _updateValue
     * @private
     * @param {string[]} keys - Property name parts
     * @param {Mixed} value - Property value
     */

  }, {
    key: '_updateValue',
    value: function _updateValue(keys, value) {
      if (value === null || value === undefined) value = '';
      var pointer = this;
      for (var i = 0; i < keys.length - 1; i++) {
        pointer = pointer[keys[i]];
      }
      var lastKey = keys[keys.length - 1];

      if (pointer[lastKey] !== value) {
        if (!this.isInitializing) {
          if (keys[0] === '_presence') keys = [keys[1]];
          this._triggerAsync('identities:change', {
            property: keys.join('.'),
            oldValue: pointer[lastKey],
            newValue: value
          });
        }
        pointer[lastKey] = value;
      }
    }

    /**
     * Accepts json-patch operations for modifying recipientStatus.
     *
     * Note that except for a camelcase error in last_seen_at,
     * all properties are set prior to calling this method.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValueIn, oldValueIn, paths) {
      var _this3 = this;

      paths.forEach(function (path) {
        var newValue = newValueIn,
            oldValue = oldValueIn;
        if (path === 'presence.last_seen_at') {
          _this3._presence.lastSeenAt = new Date(newValue.last_seen_at);
          newValue = _this3._presence.lastSeenAt;
          oldValue = oldValue.lastSeenAt;
          delete _this3._presence.last_seen_at; // Flaw in layer-patch assumes that subproperties don't get camel cased (correct assumption for `recipient_status` and `metadata`)
        } else if (path === 'presence.status') {
          newValue = _this3._presence.status;
          oldValue = oldValue.status;
        }
        var property = path.replace(/_(.)/g, function (match, value) {
          return value.toUpperCase();
        }).replace(/^presence\./, '');

        _this3._triggerAsync('identities:change', {
          property: property,
          oldValue: oldValue,
          newValue: newValue
        });
      });
    }

    /**
     * Follow this User.
     *
     * Following a user grants access to their Full Identity,
     * as well as websocket events that update the Identity.
     * @method follow
     */

  }, {
    key: 'follow',
    value: function follow() {
      var _this4 = this;

      if (this.isFullIdentity) return;
      this._xhr({
        method: 'PUT',
        url: this.url.replace(/identities/, 'following/users'),
        syncable: {}
      }, function (result) {
        if (result.success) _this4._load();
      });
      this.syncState = SYNC_STATE.LOADING;
    }

    /**
     * Unfollow this User.
     *
     * Unfollowing the user will reduce your access to only having their Basic Identity,
     * and this Basic Identity will only show up when a relevant Message or Conversation has been loaded.
     *
     * Websocket change notifications for this user will not arrive.
     *
     * @method unfollow
     */

  }, {
    key: 'unfollow',
    value: function unfollow() {
      this._xhr({
        url: this.url.replace(/identities/, 'following/users'),
        method: 'DELETE',
        syncable: {}
      });
    }

    /**
     * Set the status of the current user.
     *
     * @method setStatus
     * @param {String} status    One of layer.Identity.STATUS.AVAILABLE, layer.Identity.STATUS.AWAY,
     *        layer.Identity.STATUS.BUSY, layer.Identity.STATUS.OFLINE
     */

  }, {
    key: 'setStatus',
    value: function setStatus(status) {
      var _this5 = this;

      status = (status || '').toLowerCase();
      if (!Identity.STATUS[status.toUpperCase()]) throw new Error(LayerError.dictionary.valueNotSupported);
      if (this !== this.getClient().user) throw new Error(LayerError.dictionary.permissionDenied);
      if (status === Identity.STATUS.INVISIBLE) status = Identity.STATUS.OFFLINE; // these are equivalent; only one supported by server

      var oldValue = this._presence.status;
      this.getClient().sendSocketRequest({
        method: 'PATCH',
        body: {
          method: 'Presence.update',
          data: [{ operation: 'set', property: 'status', value: status }]
        },
        sync: {
          depends: [this.id],
          target: this.id
        }
      }, function (result) {
        if (!result.success && result.data.id !== 'authentication_required') _this5._updateValue(['_presence', 'status'], oldValue);
      });

      // these are equivalent; only one is useful for understanding your state given that your still connected/online.
      if (status === Identity.STATUS.OFFLINE) status = Identity.STATUS.INVISIBLE;

      this._updateValue(['_presence', 'status'], status);
    }

    /**
     * Update the UserID.
     *
     * This will not only update the User ID, but also the ID,
     * URL, and reregister it with the Client.
     *
     * @method _setUserId
     * @private
     * @param {string} userId
     */

  }, {
    key: '_setUserId',
    value: function _setUserId(userId) {
      var client = this.getClient();
      client._removeIdentity(this);
      this.__userId = userId;
      var encoded = encodeURIComponent(userId);
      this.id = Identity.prefixUUID + encoded;
      this.url = this.getClient().url + '/identities/' + encoded;
      client._addIdentity(this);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.userId = 'xxx'` will cause an error to be thrown.
     * These are not intended to be writable properties
     *
     * @private
     * @method __adjustUserId
     * @param {string} value - New appId value
     */

  }, {
    key: '__adjustUserId',
    value: function __adjustUserId(userId) {
      if (this.__userId) {
        throw new Error(LayerError.dictionary.cantChangeUserId);
      }
    }

    /**
     * Handle a Websocket DELETE event received from the server.
     *
     * A DELETE event means we have unfollowed this user; and should downgrade to a Basic Identity.
     *
     * @method _handleWebsocketDelete
     * @protected
     * @param {Object} data - Deletion parameters; typically null in this case.
    */
    // Turn a Full Identity into a Basic Identity and delete the Full Identity from the database

  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      var _this6 = this;

      this.getClient().dbManager.deleteObjects('identities', [this]);
      ['firstName', 'lastName', 'emailAddress', 'phoneNumber', 'metadata', 'publicKey', 'isFullIdentity', 'type'].forEach(function (key) {
        return delete _this6[key];
      });
      this._triggerAsync('identities:unfollow');
    }

    /**
     * Create a new Identity based on a Server description of the user.
     *
     * @method _createFromServer
     * @static
     * @param {Object} identity - Server Identity Object
     * @param {layer.Client} client
     * @returns {layer.Identity}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(identity, client) {
      return new Identity({
        client: client,
        fromServer: identity,
        _fromDB: identity._fromDB
      });
    }
  }]);

  return Identity;
}(Syncable);

/**
 * Display name for the User or System Identity.
 * @type {string}
 */


Identity.prototype.displayName = '';

/**
 * The Identity matching `layer.Client.user` will have this be true.
 *
 * All other Identities will have this as false.
 * @type {boolean}
 */
Identity.prototype.sessionOwner = false;

/**
 * ID of the Client this Identity is associated with.
 * @type {string}
 */
Identity.prototype.clientId = '';

/**
 * Is this a Full Identity or Basic Identity?
 *
 * Note that Service Identities are always considered to be Basic.
 * @type {boolean}
 */
Identity.prototype.isFullIdentity = false;

/**
 * Unique ID for this User.
 * @type {string}
 */
Identity.prototype.userId = '';

/**
 * Optional URL for the user's icon.
 * @type {string}
 */
Identity.prototype.avatarUrl = '';

/**
 * Optional first name for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.firstName = '';

/**
 * Optional last name for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.lastName = '';

/**
 * Optional email address for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.emailAddress = '';

/**
 * Optional phone number for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.phoneNumber = '';

/**
 * Optional metadata for this user.
 *
 * Full Identities Only.
 *
 * @type {Object}
 */
Identity.prototype.metadata = null;

/**
 * Optional public key for encrypting message text for this user.
 *
 * Full Identities Only.
 *
 * @type {string}
 */
Identity.prototype.publicKey = '';

/**
 * @static
 * @type {string} The Identity represents a user.  Value used in the layer.Identity.type field.
 */
Identity.UserType = 'user';

/**
 * @static
 * @type {string} The Identity represents a bot.  Value used in the layer.Identity.type field.
 */
Identity.BotType = 'bot';

/**
 * What type of Identity does this represent?
 *
 * * A bot? Use layer.Identity.BotType
 * * A User? Use layer.Identity.UserType
 * @type {string}
 */
Identity.prototype.type = Identity.UserType;

/**
 * Presence object contains presence information for this user.
 *
 * Properties of the sub-object are:
 *
 * * `status`: has the following possible values:
 * ** `available`: User has set their status to `available`.  This is the default initial state
 * ** `away`: App or User has changed their status to `away`
 * ** `busy`: App or User has changed their status to `busy`
 * ** `offline`: User is not connected or has set their status to `offline`
 * ** `invisible`: When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 * * `lastSeenAt`: Approximate time that the user was last known to be connected (and not `invisible`)
 *
 * @property {Object} _presence
 * @property {String} _presence.status
 * @property {Date} _presence.lastSeenAt
 * @private
 */
Identity.prototype._presence = null;

/**
 * The user's current status or availability.
 *
 * Value is one of:
 *
 * * `layer.Identity.STATUS.AVAILABLE`: User has set their status to `available`.  This is the default initial state
 * * `layer.Identity.STATUS.AWAY`: App or User has changed their status to `away`
 * * `layer.Identity.STATUS.BUSY`: App or User has changed their status to `busy`
 * * `layer.Identity.STATUS.OFFLINE`: User is not connected or has set their status to `offline`
 * * `layer.Identity.STATUS.INVISIBLE`: When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 *
 * This property can only be set on the session owner's identity, not on other identities via:
 *
 * ```
 * client.user.setStatus(layer.Identity.STATUS.AVAILABLE);
 * ```
 *
 * @property {String} status
 * @readonly
 */
Object.defineProperty(Identity.prototype, 'status', {
  enumerable: true,
  get: function get() {
    return this._presence && this._presence.status || Identity.STATUS.OFFLINE;
  }
});

/**
 * Time that the user was last known to be online.
 *
 * Accurate to within about 15 minutes.  User's who are online, but set their status
 * to `layer.Identity.STATUS.INVISIBLE` will not have their `lastSeenAt` value updated.
 *
 * @property {Date} lastSeenAt
 * @readonly
 */
Object.defineProperty(Identity.prototype, 'lastSeenAt', {
  enumerable: true,
  get: function get() {
    return this._presence && this._presence.lastSeenAt;
  }
});

/**
 * Is this Identity a bot?
 *
 * If the layer.Identity.type field is equal to layer.Identity.BotType then this will return true.
 * @property {boolean} isBot
 */
Object.defineProperty(Identity.prototype, 'isBot', {
  enumerable: true,
  get: function get() {
    return this.type === Identity.BotType;
  }
});

/**
 * Possible values for layer.Identity.status field to be used in `setStatus()`
 *
 * @property {Object} STATUS
 * @property {String} STATUS.AVAILABLE   User has set their status to `available`.  This is the default initial state
 * @property {String} STATUS.AWAY        App or User has changed their status to `away`
 * @property {String} STATUS.BUSY     App or User has changed their status to `busy`
 * @property {String} STATUS.OFFLINE  User is not connected or has set their status to `offline`
 * @property {String} STATUS.INVISIBLE  When a user has set their status to `offline` they instead see a status of `invisible` so that they know
 *    that they have deliberately set their status to `offline` but are still connected.
 * @static
 */
Identity.STATUS = {
  AVAILABLE: 'available',
  AWAY: 'away',
  OFFLINE: 'offline',
  BUSY: 'busy',
  INVISIBLE: 'invisible'
};

Identity.inObjectIgnore = Root.inObjectIgnore;

Identity.bubbleEventParent = 'getClient';

Identity._supportedEvents = ['identities:change', 'identities:loaded', 'identities:loaded-error', 'identities:unfollow'].concat(Syncable._supportedEvents);

Identity.eventPrefix = 'identities';
Identity.prefixUUID = 'layer:///identities/';
Identity.enableOpsIfNew = true;

Root.initClass.apply(Identity, [Identity, 'Identity']);
Syncable.subclasses.push(Identity);

module.exports = Identity;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvaWRlbnRpdHkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLElBQU0sV0FBVyxRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFNLE9BQU8sUUFBUSxTQUFSLENBQWI7O2VBQ3VCLFFBQVEsVUFBUixDOztJQUFmLFUsWUFBQSxVOztBQUNSLElBQU0sYUFBYSxRQUFRLGdCQUFSLENBQW5COztJQUVNLFE7OztBQUNKLHNCQUEwQjtBQUFBLFFBQWQsT0FBYyx5REFBSixFQUFJOztBQUFBOztBQUN4QjtBQUNBLFFBQUksUUFBUSxVQUFaLEVBQXdCO0FBQ3RCLGNBQVEsRUFBUixHQUFhLFFBQVEsVUFBUixDQUFtQixFQUFuQixJQUF5QixHQUF0QztBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMsUUFBUSxFQUFULElBQWUsUUFBUSxNQUEzQixFQUFtQztBQUN4QyxjQUFRLEVBQVIsR0FBYSxTQUFTLFVBQVQsR0FBc0IsbUJBQW1CLFFBQVEsTUFBM0IsQ0FBbkM7QUFDRCxLQUZNLE1BRUEsSUFBSSxRQUFRLEVBQVIsSUFBYyxDQUFDLFFBQVEsTUFBM0IsRUFBbUM7QUFDeEMsY0FBUSxNQUFSLEdBQWlCLFFBQVEsRUFBUixDQUFXLFNBQVgsQ0FBcUIsU0FBUyxVQUFULENBQW9CLE1BQXpDLENBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLFFBQVEsTUFBWixFQUFvQixRQUFRLFFBQVIsR0FBbUIsUUFBUSxNQUFSLENBQWUsS0FBbEM7QUFDcEIsUUFBSSxDQUFDLFFBQVEsUUFBYixFQUF1QixNQUFNLElBQUksS0FBSixDQUFVLFdBQVcsVUFBWCxDQUFzQixhQUFoQyxDQUFOOztBQUl2QjtBQUNBO0FBakJ3Qiw0RkFjbEIsT0Fka0I7O0FBa0J4QixRQUFJLE1BQUssRUFBTCxLQUFZLEdBQWhCLEVBQXFCLE1BQUssRUFBTCxHQUFVLEVBQVY7O0FBRXJCLFVBQUssY0FBTCxHQUFzQixJQUF0Qjs7QUFFQSxRQUFJLENBQUMsTUFBSyxTQUFWLEVBQXFCO0FBQ25CLFlBQUssU0FBTCxHQUFpQjtBQUNmLGdCQUFRLElBRE87QUFFZixvQkFBWTtBQUZHLE9BQWpCO0FBSUQ7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSSxXQUFXLFFBQVEsVUFBdkIsRUFBbUM7QUFDakMsWUFBSyxtQkFBTCxDQUF5QixRQUFRLFVBQWpDO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDLE1BQUssR0FBTixJQUFhLE1BQUssRUFBdEIsRUFBMEI7QUFDeEIsWUFBSyxHQUFMLEdBQWMsTUFBSyxTQUFMLEdBQWlCLEdBQS9CLFNBQXNDLE1BQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsQ0FBbEIsQ0FBdEM7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDLE1BQUssR0FBVixFQUFlO0FBQ3BCLFlBQUssR0FBTCxHQUFXLEVBQVg7QUFDRDtBQUNELFVBQUssU0FBTCxHQUFpQixZQUFqQjs7QUFFQSxVQUFLLFNBQUwsR0FBaUIsRUFBakIsQ0FBb0IsUUFBcEIsRUFBOEIsVUFBQyxHQUFELEVBQVM7QUFDckMsVUFBSSxDQUFDLElBQUksUUFBVCxFQUFtQixNQUFLLFlBQUwsQ0FBa0IsQ0FBQyxXQUFELEVBQWMsUUFBZCxDQUFsQixFQUEyQyxTQUFTLE1BQVQsQ0FBZ0IsT0FBM0Q7QUFDcEIsS0FGRDs7QUFJQSxVQUFLLGNBQUwsR0FBc0IsS0FBdEI7QUEvQ3dCO0FBZ0R6Qjs7Ozs4QkFFUztBQUNSLFVBQU0sU0FBUyxLQUFLLFNBQUwsRUFBZjtBQUNBLFVBQUksTUFBSixFQUFZLE9BQU8sZUFBUCxDQUF1QixJQUF2QjtBQUNaO0FBQ0Q7OztrQ0FFYSxPLEVBQVMsSSxFQUFNO0FBQzNCLFdBQUssWUFBTDtBQUNBLHdGQUFvQixPQUFwQixFQUE2QixJQUE3QjtBQUNEOzs7NEJBRU8sTyxFQUFTLEksRUFBTTtBQUNyQixXQUFLLFlBQUw7QUFDQSxrRkFBYyxPQUFkLEVBQXVCLElBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozt3Q0FTb0IsUSxFQUFVO0FBQUE7O0FBQzVCLFVBQU0sU0FBUyxLQUFLLFNBQUwsRUFBZjs7QUFFQTtBQUNBO0FBQ0EsV0FBSyxjQUFMLEdBQXVCLEtBQUssU0FBTCxLQUFtQixXQUFXLEdBQXJEOztBQUVBLFdBQUssVUFBTDs7QUFFQSxXQUFLLE1BQUwsR0FBYyxTQUFTLE9BQVQsSUFBb0IsRUFBbEM7O0FBRUEsV0FBSyxZQUFMLENBQWtCLENBQUMsV0FBRCxDQUFsQixFQUFpQyxTQUFTLFVBQTFDO0FBQ0EsV0FBSyxZQUFMLENBQWtCLENBQUMsYUFBRCxDQUFsQixFQUFtQyxTQUFTLFlBQTVDOztBQUVBLFVBQU0saUJBQWlCLGNBQWMsUUFBckM7O0FBRUE7QUFDQSxVQUFJLGNBQUosRUFBb0I7QUFDbEIsYUFBSyxHQUFMLEdBQVcsU0FBUyxHQUFwQjtBQUNBLGFBQUssSUFBTCxHQUFZLFNBQVMsSUFBckI7O0FBRUEsYUFBSyxZQUFMLENBQWtCLENBQUMsY0FBRCxDQUFsQixFQUFvQyxTQUFTLGFBQTdDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLENBQUMsVUFBRCxDQUFsQixFQUFnQyxTQUFTLFNBQXpDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLENBQUMsV0FBRCxDQUFsQixFQUFpQyxTQUFTLFVBQTFDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLENBQUMsVUFBRCxDQUFsQixFQUFnQyxTQUFTLFFBQXpDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLENBQUMsV0FBRCxDQUFsQixFQUFpQyxTQUFTLFVBQTFDO0FBQ0EsYUFBSyxZQUFMLENBQWtCLENBQUMsYUFBRCxDQUFsQixFQUFtQyxTQUFTLFlBQTVDO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDLEtBQUssR0FBTixJQUFhLEtBQUssRUFBdEIsRUFBMEI7QUFDeEIsYUFBSyxHQUFMLEdBQVcsS0FBSyxTQUFMLEdBQWlCLEdBQWpCLEdBQXVCLEtBQUssRUFBTCxDQUFRLFNBQVIsQ0FBa0IsQ0FBbEIsQ0FBbEM7QUFDRDs7QUFFRCxXQUFLLGNBQUwsR0FBc0IsS0FBdEI7O0FBRUE7QUFDQSxVQUFJLENBQUMsS0FBSyxjQUFOLElBQXdCLE9BQU8sZUFBbkMsRUFBb0Q7QUFDbEQsZUFBTyxTQUFQLENBQWlCLFVBQWpCLENBQTRCLFlBQTVCLEVBQTBDLENBQUMsS0FBSyxFQUFOLENBQTFDLEVBQXFELFVBQUMsTUFBRCxFQUFZO0FBQy9ELGNBQUksT0FBTyxNQUFYLEVBQW1CLE9BQUssbUJBQUwsQ0FBeUIsT0FBTyxDQUFQLENBQXpCO0FBQ3BCLFNBRkQ7QUFHRDtBQUNGOztBQUVEOzs7Ozs7Ozs7OztpQ0FRYSxJLEVBQU0sSyxFQUFPO0FBQ3hCLFVBQUksVUFBVSxJQUFWLElBQWtCLFVBQVUsU0FBaEMsRUFBMkMsUUFBUSxFQUFSO0FBQzNDLFVBQUksVUFBVSxJQUFkO0FBQ0EsV0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBTCxHQUFjLENBQWxDLEVBQXFDLEdBQXJDLEVBQTBDO0FBQ3hDLGtCQUFVLFFBQVEsS0FBSyxDQUFMLENBQVIsQ0FBVjtBQUNEO0FBQ0QsVUFBTSxVQUFVLEtBQUssS0FBSyxNQUFMLEdBQWMsQ0FBbkIsQ0FBaEI7O0FBRUEsVUFBSSxRQUFRLE9BQVIsTUFBcUIsS0FBekIsRUFBZ0M7QUFDOUIsWUFBSSxDQUFDLEtBQUssY0FBVixFQUEwQjtBQUN4QixjQUFJLEtBQUssQ0FBTCxNQUFZLFdBQWhCLEVBQTZCLE9BQU8sQ0FBQyxLQUFLLENBQUwsQ0FBRCxDQUFQO0FBQzdCLGVBQUssYUFBTCxDQUFtQixtQkFBbkIsRUFBd0M7QUFDdEMsc0JBQVUsS0FBSyxJQUFMLENBQVUsR0FBVixDQUQ0QjtBQUV0QyxzQkFBVSxRQUFRLE9BQVIsQ0FGNEI7QUFHdEMsc0JBQVU7QUFINEIsV0FBeEM7QUFLRDtBQUNELGdCQUFRLE9BQVIsSUFBbUIsS0FBbkI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7O3NDQVVrQixVLEVBQVksVSxFQUFZLEssRUFBTztBQUFBOztBQUMvQyxZQUFNLE9BQU4sQ0FBYyxVQUFDLElBQUQsRUFBVTtBQUN0QixZQUFJLFdBQVcsVUFBZjtBQUFBLFlBQ0UsV0FBVyxVQURiO0FBRUEsWUFBSSxTQUFTLHVCQUFiLEVBQXNDO0FBQ3BDLGlCQUFLLFNBQUwsQ0FBZSxVQUFmLEdBQTRCLElBQUksSUFBSixDQUFTLFNBQVMsWUFBbEIsQ0FBNUI7QUFDQSxxQkFBVyxPQUFLLFNBQUwsQ0FBZSxVQUExQjtBQUNBLHFCQUFXLFNBQVMsVUFBcEI7QUFDQSxpQkFBTyxPQUFLLFNBQUwsQ0FBZSxZQUF0QixDQUpvQyxDQUlBO0FBQ3JDLFNBTEQsTUFLTyxJQUFJLFNBQVMsaUJBQWIsRUFBZ0M7QUFDckMscUJBQVcsT0FBSyxTQUFMLENBQWUsTUFBMUI7QUFDQSxxQkFBVyxTQUFTLE1BQXBCO0FBQ0Q7QUFDRCxZQUFNLFdBQVcsS0FDZCxPQURjLENBQ04sT0FETSxFQUNHLFVBQUMsS0FBRCxFQUFRLEtBQVI7QUFBQSxpQkFBa0IsTUFBTSxXQUFOLEVBQWxCO0FBQUEsU0FESCxFQUVkLE9BRmMsQ0FFTixhQUZNLEVBRVMsRUFGVCxDQUFqQjs7QUFJQSxlQUFLLGFBQUwsQ0FBbUIsbUJBQW5CLEVBQXdDO0FBQ3RDLDRCQURzQztBQUV0Qyw0QkFGc0M7QUFHdEM7QUFIc0MsU0FBeEM7QUFLRCxPQXJCRDtBQXNCRDs7QUFFRDs7Ozs7Ozs7Ozs2QkFPUztBQUFBOztBQUNQLFVBQUksS0FBSyxjQUFULEVBQXlCO0FBQ3pCLFdBQUssSUFBTCxDQUFVO0FBQ1IsZ0JBQVEsS0FEQTtBQUVSLGFBQUssS0FBSyxHQUFMLENBQVMsT0FBVCxDQUFpQixZQUFqQixFQUErQixpQkFBL0IsQ0FGRztBQUdSLGtCQUFVO0FBSEYsT0FBVixFQUlHLFVBQUMsTUFBRCxFQUFZO0FBQ2IsWUFBSSxPQUFPLE9BQVgsRUFBb0IsT0FBSyxLQUFMO0FBQ3JCLE9BTkQ7QUFPQSxXQUFLLFNBQUwsR0FBaUIsV0FBVyxPQUE1QjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OytCQVVXO0FBQ1QsV0FBSyxJQUFMLENBQVU7QUFDUixhQUFLLEtBQUssR0FBTCxDQUFTLE9BQVQsQ0FBaUIsWUFBakIsRUFBK0IsaUJBQS9CLENBREc7QUFFUixnQkFBUSxRQUZBO0FBR1Isa0JBQVU7QUFIRixPQUFWO0FBS0Q7O0FBRUQ7Ozs7Ozs7Ozs7OEJBT1UsTSxFQUFRO0FBQUE7O0FBQ2hCLGVBQVMsQ0FBQyxVQUFVLEVBQVgsRUFBZSxXQUFmLEVBQVQ7QUFDQSxVQUFJLENBQUMsU0FBUyxNQUFULENBQWdCLE9BQU8sV0FBUCxFQUFoQixDQUFMLEVBQTRDLE1BQU0sSUFBSSxLQUFKLENBQVUsV0FBVyxVQUFYLENBQXNCLGlCQUFoQyxDQUFOO0FBQzVDLFVBQUksU0FBUyxLQUFLLFNBQUwsR0FBaUIsSUFBOUIsRUFBb0MsTUFBTSxJQUFJLEtBQUosQ0FBVSxXQUFXLFVBQVgsQ0FBc0IsZ0JBQWhDLENBQU47QUFDcEMsVUFBSSxXQUFXLFNBQVMsTUFBVCxDQUFnQixTQUEvQixFQUEwQyxTQUFTLFNBQVMsTUFBVCxDQUFnQixPQUF6QixDQUoxQixDQUk0RDs7QUFFNUUsVUFBTSxXQUFXLEtBQUssU0FBTCxDQUFlLE1BQWhDO0FBQ0EsV0FBSyxTQUFMLEdBQWlCLGlCQUFqQixDQUFtQztBQUNqQyxnQkFBUSxPQUR5QjtBQUVqQyxjQUFNO0FBQ0osa0JBQVEsaUJBREo7QUFFSixnQkFBTSxDQUNKLEVBQUUsV0FBVyxLQUFiLEVBQW9CLFVBQVUsUUFBOUIsRUFBd0MsT0FBTyxNQUEvQyxFQURJO0FBRkYsU0FGMkI7QUFRakMsY0FBTTtBQUNKLG1CQUFTLENBQUMsS0FBSyxFQUFOLENBREw7QUFFSixrQkFBUSxLQUFLO0FBRlQ7QUFSMkIsT0FBbkMsRUFZRyxVQUFDLE1BQUQsRUFBWTtBQUNiLFlBQUksQ0FBQyxPQUFPLE9BQVIsSUFBbUIsT0FBTyxJQUFQLENBQVksRUFBWixLQUFtQix5QkFBMUMsRUFBcUUsT0FBSyxZQUFMLENBQWtCLENBQUMsV0FBRCxFQUFjLFFBQWQsQ0FBbEIsRUFBMkMsUUFBM0M7QUFDdEUsT0FkRDs7QUFnQkE7QUFDQSxVQUFJLFdBQVcsU0FBUyxNQUFULENBQWdCLE9BQS9CLEVBQXdDLFNBQVMsU0FBUyxNQUFULENBQWdCLFNBQXpCOztBQUV4QyxXQUFLLFlBQUwsQ0FBa0IsQ0FBQyxXQUFELEVBQWMsUUFBZCxDQUFsQixFQUEyQyxNQUEzQztBQUNEOztBQUVGOzs7Ozs7Ozs7Ozs7OytCQVVZLE0sRUFBUTtBQUNqQixVQUFNLFNBQVMsS0FBSyxTQUFMLEVBQWY7QUFDQSxhQUFPLGVBQVAsQ0FBdUIsSUFBdkI7QUFDQSxXQUFLLFFBQUwsR0FBZ0IsTUFBaEI7QUFDQSxVQUFNLFVBQVUsbUJBQW1CLE1BQW5CLENBQWhCO0FBQ0EsV0FBSyxFQUFMLEdBQVUsU0FBUyxVQUFULEdBQXNCLE9BQWhDO0FBQ0EsV0FBSyxHQUFMLEdBQWMsS0FBSyxTQUFMLEdBQWlCLEdBQS9CLG9CQUFpRCxPQUFqRDtBQUNBLGFBQU8sWUFBUCxDQUFvQixJQUFwQjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O21DQVVlLE0sRUFBUTtBQUNyQixVQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNqQixjQUFNLElBQUksS0FBSixDQUFVLFdBQVcsVUFBWCxDQUFzQixnQkFBaEMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7OzJDQUN1QixJLEVBQU07QUFBQTs7QUFDM0IsV0FBSyxTQUFMLEdBQWlCLFNBQWpCLENBQTJCLGFBQTNCLENBQXlDLFlBQXpDLEVBQXVELENBQUMsSUFBRCxDQUF2RDtBQUNBLE9BQUMsV0FBRCxFQUFjLFVBQWQsRUFBMEIsY0FBMUIsRUFBMEMsYUFBMUMsRUFBeUQsVUFBekQsRUFBcUUsV0FBckUsRUFBa0YsZ0JBQWxGLEVBQW9HLE1BQXBHLEVBQ0csT0FESCxDQUNXO0FBQUEsZUFBTyxPQUFPLE9BQUssR0FBTCxDQUFkO0FBQUEsT0FEWDtBQUVBLFdBQUssYUFBTCxDQUFtQixxQkFBbkI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O3NDQVN5QixRLEVBQVUsTSxFQUFRO0FBQ3pDLGFBQU8sSUFBSSxRQUFKLENBQWE7QUFDbEIsc0JBRGtCO0FBRWxCLG9CQUFZLFFBRk07QUFHbEIsaUJBQVMsU0FBUztBQUhBLE9BQWIsQ0FBUDtBQUtEOzs7O0VBclVvQixROztBQXdVdkI7Ozs7OztBQUlBLFNBQVMsU0FBVCxDQUFtQixXQUFuQixHQUFpQyxFQUFqQzs7QUFFQTs7Ozs7O0FBTUEsU0FBUyxTQUFULENBQW1CLFlBQW5CLEdBQWtDLEtBQWxDOztBQUVBOzs7O0FBSUEsU0FBUyxTQUFULENBQW1CLFFBQW5CLEdBQThCLEVBQTlCOztBQUVBOzs7Ozs7QUFNQSxTQUFTLFNBQVQsQ0FBbUIsY0FBbkIsR0FBb0MsS0FBcEM7O0FBRUE7Ozs7QUFJQSxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsR0FBNEIsRUFBNUI7O0FBRUE7Ozs7QUFJQSxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsRUFBL0I7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsRUFBL0I7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsR0FBOEIsRUFBOUI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsWUFBbkIsR0FBa0MsRUFBbEM7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsV0FBbkIsR0FBaUMsRUFBakM7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsR0FBOEIsSUFBOUI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsRUFBL0I7O0FBRUE7Ozs7QUFJQSxTQUFTLFFBQVQsR0FBb0IsTUFBcEI7O0FBRUE7Ozs7QUFJQSxTQUFTLE9BQVQsR0FBbUIsS0FBbkI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsR0FBMEIsU0FBUyxRQUFuQzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsSUFBL0I7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSxPQUFPLGNBQVAsQ0FBc0IsU0FBUyxTQUEvQixFQUEwQyxRQUExQyxFQUFvRDtBQUNsRCxjQUFZLElBRHNDO0FBRWxELE9BQUssU0FBUyxHQUFULEdBQWU7QUFDbEIsV0FBUSxLQUFLLFNBQUwsSUFBa0IsS0FBSyxTQUFMLENBQWUsTUFBbEMsSUFBNkMsU0FBUyxNQUFULENBQWdCLE9BQXBFO0FBQ0Q7QUFKaUQsQ0FBcEQ7O0FBT0E7Ozs7Ozs7OztBQVNBLE9BQU8sY0FBUCxDQUFzQixTQUFTLFNBQS9CLEVBQTBDLFlBQTFDLEVBQXdEO0FBQ3RELGNBQVksSUFEMEM7QUFFdEQsT0FBSyxTQUFTLEdBQVQsR0FBZTtBQUNsQixXQUFPLEtBQUssU0FBTCxJQUFrQixLQUFLLFNBQUwsQ0FBZSxVQUF4QztBQUNEO0FBSnFELENBQXhEOztBQU9BOzs7Ozs7QUFNQSxPQUFPLGNBQVAsQ0FBc0IsU0FBUyxTQUEvQixFQUEwQyxPQUExQyxFQUFtRDtBQUNqRCxjQUFZLElBRHFDO0FBRWpELE9BQUssU0FBUyxHQUFULEdBQWU7QUFDbEIsV0FBTyxLQUFLLElBQUwsS0FBYyxTQUFTLE9BQTlCO0FBQ0Q7QUFKZ0QsQ0FBbkQ7O0FBT0E7Ozs7Ozs7Ozs7OztBQVlBLFNBQVMsTUFBVCxHQUFrQjtBQUNoQixhQUFXLFdBREs7QUFFaEIsUUFBTSxNQUZVO0FBR2hCLFdBQVMsU0FITztBQUloQixRQUFNLE1BSlU7QUFLaEIsYUFBVztBQUxLLENBQWxCOztBQVFBLFNBQVMsY0FBVCxHQUEwQixLQUFLLGNBQS9COztBQUVBLFNBQVMsaUJBQVQsR0FBNkIsV0FBN0I7O0FBRUEsU0FBUyxnQkFBVCxHQUE0QixDQUMxQixtQkFEMEIsRUFFMUIsbUJBRjBCLEVBRzFCLHlCQUgwQixFQUkxQixxQkFKMEIsRUFLMUIsTUFMMEIsQ0FLbkIsU0FBUyxnQkFMVSxDQUE1Qjs7QUFPQSxTQUFTLFdBQVQsR0FBdUIsWUFBdkI7QUFDQSxTQUFTLFVBQVQsR0FBc0Isc0JBQXRCO0FBQ0EsU0FBUyxjQUFULEdBQTBCLElBQTFCOztBQUVBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsUUFBckIsRUFBK0IsQ0FBQyxRQUFELEVBQVcsVUFBWCxDQUEvQjtBQUNBLFNBQVMsVUFBVCxDQUFvQixJQUFwQixDQUF5QixRQUF6Qjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsUUFBakIiLCJmaWxlIjoiaWRlbnRpdHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBJZGVudGl0eSBjbGFzcyByZXByZXNlbnRzIGFuIElkZW50aXR5IG9mIGEgdXNlciBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIElkZW50aXRpZXMgYXJlIGNyZWF0ZWQgYnkgdGhlIFN5c3RlbSwgbmV2ZXIgZGlyZWN0bHkgYnkgYXBwcy5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuSWRlbnRpdHlcbiAqIEBleHRlbmRzIGxheWVyLlN5bmNhYmxlXG4gKi9cblxuLypcbiAqIEhvdyBJZGVudGl0aWVzIGZpdCBpbnRvIHRoZSBzeXN0ZW06XG4gKlxuICogMS4gQXMgcGFydCBvZiBpbml0aWFsaXphdGlvbiwgbG9hZCB0aGUgYXV0aGVudGljYXRlZCB1c2VyJ3MgZnVsbCBJZGVudGl0eSByZWNvcmQgc28gdGhhdCB0aGUgQ2xpZW50IGtub3dzIG1vcmUgdGhhbiBqdXN0IHRoZSBgdXNlcklkYCBvZiBpdHMgdXNlci5cbiAqICAgIGNsaWVudC51c2VyID0gPElkZW50aXR5PlxuICogMi4gQW55IHRpbWUgd2UgZ2V0IGEgQmFzaWMgSWRlbnRpdHkgdmlhIGBtZXNzYWdlLnNlbmRlcmAgb3IgQ29udmVyc2F0aW9ucywgc2VlIGlmIHdlIGhhdmUgYW4gSWRlbnRpdHkgZm9yIHRoYXQgc2VuZGVyLFxuICogICAgYW5kIGlmIG5vdCBjcmVhdGUgb25lIHVzaW5nIHRoZSBCYXNpYyBJZGVudGl0eS4gIFRoZXJlIHNob3VsZCBuZXZlciBiZSBhIGR1cGxpY2F0ZSBJZGVudGl0eS5cbiAqIDMuIFdlYnNvY2tldCBDSEFOR0UgZXZlbnRzIHdpbGwgdXBkYXRlIElkZW50aXR5IG9iamVjdHMsIGFzIHdlbGwgYXMgYWRkIG5ldyBGdWxsIElkZW50aXRpZXMsIGFuZCBkb3duZ3JhZGUgRnVsbCBJZGVudGl0aWVzIHRvIEJhc2ljIElkZW50aXRpZXMuXG4gKiA0LiBUaGUgUXVlcnkgQVBJIHN1cHBvcnRzIHF1ZXJ5aW5nIGFuZCBwYWdpbmcgdGhyb3VnaCBJZGVudGl0aWVzXG4gKiA1LiBUaGUgUXVlcnkgQVBJIGxvYWRzIEZ1bGwgSWRlbnRpdGllczsgdGhlc2UgcmVzdWx0cyB3aWxsIHVwZGF0ZSB0aGUgY2xpZW50Ll9tb2RlbHMuaWRlbnRpdGllcztcbiAqICAgIHVwZ3JhZGluZyBCYXNpYyBJZGVudGl0aWVzIGlmIHRoZXkgbWF0Y2gsIGFuZCBhZGRpbmcgbmV3IElkZW50aXRpZXMgaWYgdGhleSBkb24ndC5cbiAqIDYuIERiTWFuYWdlciB3aWxsIHBlcnNpc3Qgb25seSBVc2VySWRlbnRpdGllcywgYW5kIG9ubHkgdGhvc2UgdGhhdCBhcmUgRnVsbCBJZGVudGl0aWVzLiAgQmFzaWMgSWRlbnRpdGllcyB3aWxsIGJlIHdyaXR0ZW5cbiAqICAgIHRvIHRoZSBNZXNzYWdlcyBhbmQgQ29udmVyc2F0aW9ucyB0YWJsZXMgYW55d2F5cyBhcyBwYXJ0IG9mIHRob3NlIGxhcmdlciBvYmplY3RzLlxuICogNy4gQVBJIEZvciBleHBsaWNpdCBmb2xsb3dzL3VuZm9sbG93c1xuICovXG5cbmNvbnN0IFN5bmNhYmxlID0gcmVxdWlyZSgnLi9zeW5jYWJsZScpO1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4uL3Jvb3QnKTtcbmNvbnN0IHsgU1lOQ19TVEFURSB9ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuLi9sYXllci1lcnJvcicpO1xuXG5jbGFzcyBJZGVudGl0eSBleHRlbmRzIFN5bmNhYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBJRCBmcm9tIGhhbmRsZSBmcm9tU2VydmVyIHBhcmFtZXRlciBpcyB1c2VkIGJ5IHRoZSBSb290LmNvbnN0cnVjdG9yXG4gICAgaWYgKG9wdGlvbnMuZnJvbVNlcnZlcikge1xuICAgICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuZnJvbVNlcnZlci5pZCB8fCAnLSc7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5pZCAmJiBvcHRpb25zLnVzZXJJZCkge1xuICAgICAgb3B0aW9ucy5pZCA9IElkZW50aXR5LnByZWZpeFVVSUQgKyBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy51c2VySWQpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pZCAmJiAhb3B0aW9ucy51c2VySWQpIHtcbiAgICAgIG9wdGlvbnMudXNlcklkID0gb3B0aW9ucy5pZC5zdWJzdHJpbmcoSWRlbnRpdHkucHJlZml4VVVJRC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGNsaWVudElkIHByb3BlcnR5XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50KSBvcHRpb25zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnQuYXBwSWQ7XG4gICAgaWYgKCFvcHRpb25zLmNsaWVudElkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmNsaWVudE1pc3NpbmcpO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAvLyBUaGUgLSBpcyBoZXJlIHRvIHByZXZlbnQgUm9vdCBmcm9tIGdlbmVyYXRpbmcgYSBVVUlEIGZvciBhbiBJRC4gIElEIG11c3QgbWFwIHRvIFVzZXJJRFxuICAgIC8vIGFuZCBjYW4ndCBiZSByYW5kb21seSBnZW5lcmF0ZWQuICBUaGlzIG9ubHkgb2NjdXJzIGZyb20gUGxhdGZvcm0gQVBJIHNlbmRpbmcgd2l0aCBgc2VuZGVyLm5hbWVgIGFuZCBubyBpZGVudGl0eS5cbiAgICBpZiAodGhpcy5pZCA9PT0gJy0nKSB0aGlzLmlkID0gJyc7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcHJlc2VuY2UpIHtcbiAgICAgIHRoaXMuX3ByZXNlbmNlID0ge1xuICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgIGxhc3RTZWVuQXQ6IG51bGwsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcHRpb25zIGNvbnRhaW5zIGEgZnVsbCBzZXJ2ZXIgZGVmaW5pdGlvbiBvZiB0aGUgb2JqZWN0LFxuICAgIC8vIGNvcHkgaXQgaW4gd2l0aCBfcG9wdWxhdGVGcm9tU2VydmVyOyB0aGlzIHdpbGwgYWRkIHRoZSBJZGVudGl0eVxuICAgIC8vIHRvIHRoZSBDbGllbnQgYXMgd2VsbC5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZyb21TZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihvcHRpb25zLmZyb21TZXJ2ZXIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51cmwgJiYgdGhpcy5pZCkge1xuICAgICAgdGhpcy51cmwgPSBgJHt0aGlzLmdldENsaWVudCgpLnVybH0vJHt0aGlzLmlkLnN1YnN0cmluZyg5KX1gO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMudXJsKSB7XG4gICAgICB0aGlzLnVybCA9ICcnO1xuICAgIH1cbiAgICB0aGlzLmdldENsaWVudCgpLl9hZGRJZGVudGl0eSh0aGlzKTtcblxuICAgIHRoaXMuZ2V0Q2xpZW50KCkub24oJ29ubGluZScsIChldnQpID0+IHtcbiAgICAgIGlmICghZXZ0LmlzT25saW5lKSB0aGlzLl91cGRhdGVWYWx1ZShbJ19wcmVzZW5jZScsICdzdGF0dXMnXSwgSWRlbnRpdHkuU1RBVFVTLk9GRkxJTkUpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGlmIChjbGllbnQpIGNsaWVudC5fcmVtb3ZlSWRlbnRpdHkodGhpcyk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgX3RyaWdnZXJBc3luYyhldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci5fdHJpZ2dlckFzeW5jKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgdHJpZ2dlcihldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci50cmlnZ2VyKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGlzIGluc3RhbmNlIHVzaW5nIHNlcnZlci1kYXRhLlxuICAgKlxuICAgKiBTaWRlIGVmZmVjdHMgYWRkIHRoaXMgdG8gdGhlIENsaWVudC5cbiAgICpcbiAgICogQG1ldGhvZCBfcG9wdWxhdGVGcm9tU2VydmVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gaWRlbnRpdHkgLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlkZW50aXR5XG4gICAqL1xuICBfcG9wdWxhdGVGcm9tU2VydmVyKGlkZW50aXR5KSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcblxuICAgIC8vIERpc2FibGUgZXZlbnRzIGlmIGNyZWF0aW5nIGEgbmV3IElkZW50aXR5XG4gICAgLy8gV2Ugc3RpbGwgd2FudCBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnRzIGZvciBhbnl0aGluZyB0aGF0IERPRVMgY2hhbmdlXG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9ICh0aGlzLnN5bmNTdGF0ZSA9PT0gU1lOQ19TVEFURS5ORVcpO1xuXG4gICAgdGhpcy5fc2V0U3luY2VkKCk7XG5cbiAgICB0aGlzLnVzZXJJZCA9IGlkZW50aXR5LnVzZXJfaWQgfHwgJyc7XG5cbiAgICB0aGlzLl91cGRhdGVWYWx1ZShbJ2F2YXRhclVybCddLCBpZGVudGl0eS5hdmF0YXJfdXJsKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZShbJ2Rpc3BsYXlOYW1lJ10sIGlkZW50aXR5LmRpc3BsYXlfbmFtZSk7XG5cbiAgICBjb25zdCBpc0Z1bGxJZGVudGl0eSA9ICdtZXRhZGF0YScgaW4gaWRlbnRpdHk7XG5cbiAgICAvLyBIYW5kbGUgRnVsbCBJZGVudGl0eSB2cyBCYXNpYyBJZGVudGl0eVxuICAgIGlmIChpc0Z1bGxJZGVudGl0eSkge1xuICAgICAgdGhpcy51cmwgPSBpZGVudGl0eS51cmw7XG4gICAgICB0aGlzLnR5cGUgPSBpZGVudGl0eS50eXBlO1xuXG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZShbJ2VtYWlsQWRkcmVzcyddLCBpZGVudGl0eS5lbWFpbF9hZGRyZXNzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKFsnbGFzdE5hbWUnXSwgaWRlbnRpdHkubGFzdF9uYW1lKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKFsnZmlyc3ROYW1lJ10sIGlkZW50aXR5LmZpcnN0X25hbWUpO1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoWydtZXRhZGF0YSddLCBpZGVudGl0eS5tZXRhZGF0YSk7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZShbJ3B1YmxpY0tleSddLCBpZGVudGl0eS5wdWJsaWNfa2V5KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKFsncGhvbmVOdW1iZXInXSwgaWRlbnRpdHkucGhvbmVfbnVtYmVyKTtcbiAgICAgIHRoaXMuaXNGdWxsSWRlbnRpdHkgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51cmwgJiYgdGhpcy5pZCkge1xuICAgICAgdGhpcy51cmwgPSB0aGlzLmdldENsaWVudCgpLnVybCArIHRoaXMuaWQuc3Vic3RyaW5nKDgpO1xuICAgIH1cblxuICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSBmYWxzZTtcblxuICAgIC8vIFNlZSBpZiB3ZSBoYXZlIHRoZSBGdWxsIElkZW50aXR5IE9iamVjdCBpbiBkYXRhYmFzZVxuICAgIGlmICghdGhpcy5pc0Z1bGxJZGVudGl0eSAmJiBjbGllbnQuaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBjbGllbnQuZGJNYW5hZ2VyLmdldE9iamVjdHMoJ2lkZW50aXRpZXMnLCBbdGhpcy5pZF0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihyZXN1bHRbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvcGVydHk7IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIElGIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQG1ldGhvZCBfdXBkYXRlVmFsdWVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyAtIFByb3BlcnR5IG5hbWUgcGFydHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBQcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgX3VwZGF0ZVZhbHVlKGtleXMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gJyc7XG4gICAgbGV0IHBvaW50ZXIgPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyW2tleXNbaV1dO1xuICAgIH1cbiAgICBjb25zdCBsYXN0S2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHBvaW50ZXJbbGFzdEtleV0gIT09IHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgaWYgKGtleXNbMF0gPT09ICdfcHJlc2VuY2UnKSBrZXlzID0gW2tleXNbMV1dO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2lkZW50aXRpZXM6Y2hhbmdlJywge1xuICAgICAgICAgIHByb3BlcnR5OiBrZXlzLmpvaW4oJy4nKSxcbiAgICAgICAgICBvbGRWYWx1ZTogcG9pbnRlcltsYXN0S2V5XSxcbiAgICAgICAgICBuZXdWYWx1ZTogdmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcG9pbnRlcltsYXN0S2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGpzb24tcGF0Y2ggb3BlcmF0aW9ucyBmb3IgbW9kaWZ5aW5nIHJlY2lwaWVudFN0YXR1cy5cbiAgICpcbiAgICogTm90ZSB0aGF0IGV4Y2VwdCBmb3IgYSBjYW1lbGNhc2UgZXJyb3IgaW4gbGFzdF9zZWVuX2F0LFxuICAgKiBhbGwgcHJvcGVydGllcyBhcmUgc2V0IHByaW9yIHRvIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZVBhdGNoRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0W119IGRhdGEgLSBBcnJheSBvZiBvcGVyYXRpb25zXG4gICAqL1xuICBfaGFuZGxlUGF0Y2hFdmVudChuZXdWYWx1ZUluLCBvbGRWYWx1ZUluLCBwYXRocykge1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIGxldCBuZXdWYWx1ZSA9IG5ld1ZhbHVlSW4sXG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWVJbjtcbiAgICAgIGlmIChwYXRoID09PSAncHJlc2VuY2UubGFzdF9zZWVuX2F0Jykge1xuICAgICAgICB0aGlzLl9wcmVzZW5jZS5sYXN0U2VlbkF0ID0gbmV3IERhdGUobmV3VmFsdWUubGFzdF9zZWVuX2F0KTtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl9wcmVzZW5jZS5sYXN0U2VlbkF0O1xuICAgICAgICBvbGRWYWx1ZSA9IG9sZFZhbHVlLmxhc3RTZWVuQXQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wcmVzZW5jZS5sYXN0X3NlZW5fYXQ7IC8vIEZsYXcgaW4gbGF5ZXItcGF0Y2ggYXNzdW1lcyB0aGF0IHN1YnByb3BlcnRpZXMgZG9uJ3QgZ2V0IGNhbWVsIGNhc2VkIChjb3JyZWN0IGFzc3VtcHRpb24gZm9yIGByZWNpcGllbnRfc3RhdHVzYCBhbmQgYG1ldGFkYXRhYClcbiAgICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJ3ByZXNlbmNlLnN0YXR1cycpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLl9wcmVzZW5jZS5zdGF0dXM7XG4gICAgICAgIG9sZFZhbHVlID0gb2xkVmFsdWUuc3RhdHVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9fKC4pL2csIChtYXRjaCwgdmFsdWUpID0+IHZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKC9ecHJlc2VuY2VcXC4vLCAnJyk7XG5cbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnaWRlbnRpdGllczpjaGFuZ2UnLCB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2xsb3cgdGhpcyBVc2VyLlxuICAgKlxuICAgKiBGb2xsb3dpbmcgYSB1c2VyIGdyYW50cyBhY2Nlc3MgdG8gdGhlaXIgRnVsbCBJZGVudGl0eSxcbiAgICogYXMgd2VsbCBhcyB3ZWJzb2NrZXQgZXZlbnRzIHRoYXQgdXBkYXRlIHRoZSBJZGVudGl0eS5cbiAgICogQG1ldGhvZCBmb2xsb3dcbiAgICovXG4gIGZvbGxvdygpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGxJZGVudGl0eSkgcmV0dXJuO1xuICAgIHRoaXMuX3hocih7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgdXJsOiB0aGlzLnVybC5yZXBsYWNlKC9pZGVudGl0aWVzLywgJ2ZvbGxvd2luZy91c2VycycpLFxuICAgICAgc3luY2FibGU6IHt9LFxuICAgIH0sIChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2VzcykgdGhpcy5fbG9hZCgpO1xuICAgIH0pO1xuICAgIHRoaXMuc3luY1N0YXRlID0gU1lOQ19TVEFURS5MT0FESU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZm9sbG93IHRoaXMgVXNlci5cbiAgICpcbiAgICogVW5mb2xsb3dpbmcgdGhlIHVzZXIgd2lsbCByZWR1Y2UgeW91ciBhY2Nlc3MgdG8gb25seSBoYXZpbmcgdGhlaXIgQmFzaWMgSWRlbnRpdHksXG4gICAqIGFuZCB0aGlzIEJhc2ljIElkZW50aXR5IHdpbGwgb25seSBzaG93IHVwIHdoZW4gYSByZWxldmFudCBNZXNzYWdlIG9yIENvbnZlcnNhdGlvbiBoYXMgYmVlbiBsb2FkZWQuXG4gICAqXG4gICAqIFdlYnNvY2tldCBjaGFuZ2Ugbm90aWZpY2F0aW9ucyBmb3IgdGhpcyB1c2VyIHdpbGwgbm90IGFycml2ZS5cbiAgICpcbiAgICogQG1ldGhvZCB1bmZvbGxvd1xuICAgKi9cbiAgdW5mb2xsb3coKSB7XG4gICAgdGhpcy5feGhyKHtcbiAgICAgIHVybDogdGhpcy51cmwucmVwbGFjZSgvaWRlbnRpdGllcy8sICdmb2xsb3dpbmcvdXNlcnMnKSxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBzeW5jYWJsZToge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0dXMgb2YgdGhlIGN1cnJlbnQgdXNlci5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRTdGF0dXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1cyAgICBPbmUgb2YgbGF5ZXIuSWRlbnRpdHkuU1RBVFVTLkFWQUlMQUJMRSwgbGF5ZXIuSWRlbnRpdHkuU1RBVFVTLkFXQVksXG4gICAqICAgICAgICBsYXllci5JZGVudGl0eS5TVEFUVVMuQlVTWSwgbGF5ZXIuSWRlbnRpdHkuU1RBVFVTLk9GTElORVxuICAgKi9cbiAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIHN0YXR1cyA9IChzdGF0dXMgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFJZGVudGl0eS5TVEFUVVNbc3RhdHVzLnRvVXBwZXJDYXNlKCldKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LnZhbHVlTm90U3VwcG9ydGVkKTtcbiAgICBpZiAodGhpcyAhPT0gdGhpcy5nZXRDbGllbnQoKS51c2VyKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LnBlcm1pc3Npb25EZW5pZWQpO1xuICAgIGlmIChzdGF0dXMgPT09IElkZW50aXR5LlNUQVRVUy5JTlZJU0lCTEUpIHN0YXR1cyA9IElkZW50aXR5LlNUQVRVUy5PRkZMSU5FOyAvLyB0aGVzZSBhcmUgZXF1aXZhbGVudDsgb25seSBvbmUgc3VwcG9ydGVkIGJ5IHNlcnZlclxuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl9wcmVzZW5jZS5zdGF0dXM7XG4gICAgdGhpcy5nZXRDbGllbnQoKS5zZW5kU29ja2V0UmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICBib2R5OiB7XG4gICAgICAgIG1ldGhvZDogJ1ByZXNlbmNlLnVwZGF0ZScsXG4gICAgICAgIGRhdGE6IFtcbiAgICAgICAgICB7IG9wZXJhdGlvbjogJ3NldCcsIHByb3BlcnR5OiAnc3RhdHVzJywgdmFsdWU6IHN0YXR1cyB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIHN5bmM6IHtcbiAgICAgICAgZGVwZW5kczogW3RoaXMuaWRdLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuaWQsXG4gICAgICB9LFxuICAgIH0sIChyZXN1bHQpID0+IHtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEuaWQgIT09ICdhdXRoZW50aWNhdGlvbl9yZXF1aXJlZCcpIHRoaXMuX3VwZGF0ZVZhbHVlKFsnX3ByZXNlbmNlJywgJ3N0YXR1cyddLCBvbGRWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGVzZSBhcmUgZXF1aXZhbGVudDsgb25seSBvbmUgaXMgdXNlZnVsIGZvciB1bmRlcnN0YW5kaW5nIHlvdXIgc3RhdGUgZ2l2ZW4gdGhhdCB5b3VyIHN0aWxsIGNvbm5lY3RlZC9vbmxpbmUuXG4gICAgaWYgKHN0YXR1cyA9PT0gSWRlbnRpdHkuU1RBVFVTLk9GRkxJTkUpIHN0YXR1cyA9IElkZW50aXR5LlNUQVRVUy5JTlZJU0lCTEU7XG5cbiAgICB0aGlzLl91cGRhdGVWYWx1ZShbJ19wcmVzZW5jZScsICdzdGF0dXMnXSwgc3RhdHVzKTtcbiAgfVxuXG4gLyoqXG4gICogVXBkYXRlIHRoZSBVc2VySUQuXG4gICpcbiAgKiBUaGlzIHdpbGwgbm90IG9ubHkgdXBkYXRlIHRoZSBVc2VyIElELCBidXQgYWxzbyB0aGUgSUQsXG4gICogVVJMLCBhbmQgcmVyZWdpc3RlciBpdCB3aXRoIHRoZSBDbGllbnQuXG4gICpcbiAgKiBAbWV0aG9kIF9zZXRVc2VySWRcbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWRcbiAgKi9cbiAgX3NldFVzZXJJZCh1c2VySWQpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGNsaWVudC5fcmVtb3ZlSWRlbnRpdHkodGhpcyk7XG4gICAgdGhpcy5fX3VzZXJJZCA9IHVzZXJJZDtcbiAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlVVJJQ29tcG9uZW50KHVzZXJJZCk7XG4gICAgdGhpcy5pZCA9IElkZW50aXR5LnByZWZpeFVVSUQgKyBlbmNvZGVkO1xuICAgIHRoaXMudXJsID0gYCR7dGhpcy5nZXRDbGllbnQoKS51cmx9L2lkZW50aXRpZXMvJHtlbmNvZGVkfWA7XG4gICAgY2xpZW50Ll9hZGRJZGVudGl0eSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBfXyBNZXRob2RzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgKlxuICAgKiBBbnkgYXR0ZW1wdCB0byBleGVjdXRlIGB0aGlzLnVzZXJJZCA9ICd4eHgnYCB3aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICogVGhlc2UgYXJlIG5vdCBpbnRlbmRlZCB0byBiZSB3cml0YWJsZSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2QgX19hZGp1c3RVc2VySWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gTmV3IGFwcElkIHZhbHVlXG4gICAqL1xuICBfX2FkanVzdFVzZXJJZCh1c2VySWQpIHtcbiAgICBpZiAodGhpcy5fX3VzZXJJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jYW50Q2hhbmdlVXNlcklkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgV2Vic29ja2V0IERFTEVURSBldmVudCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEEgREVMRVRFIGV2ZW50IG1lYW5zIHdlIGhhdmUgdW5mb2xsb3dlZCB0aGlzIHVzZXI7IGFuZCBzaG91bGQgZG93bmdyYWRlIHRvIGEgQmFzaWMgSWRlbnRpdHkuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZVdlYnNvY2tldERlbGV0ZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGVsZXRpb24gcGFyYW1ldGVyczsgdHlwaWNhbGx5IG51bGwgaW4gdGhpcyBjYXNlLlxuICAqL1xuICAvLyBUdXJuIGEgRnVsbCBJZGVudGl0eSBpbnRvIGEgQmFzaWMgSWRlbnRpdHkgYW5kIGRlbGV0ZSB0aGUgRnVsbCBJZGVudGl0eSBmcm9tIHRoZSBkYXRhYmFzZVxuICBfaGFuZGxlV2Vic29ja2V0RGVsZXRlKGRhdGEpIHtcbiAgICB0aGlzLmdldENsaWVudCgpLmRiTWFuYWdlci5kZWxldGVPYmplY3RzKCdpZGVudGl0aWVzJywgW3RoaXNdKTtcbiAgICBbJ2ZpcnN0TmFtZScsICdsYXN0TmFtZScsICdlbWFpbEFkZHJlc3MnLCAncGhvbmVOdW1iZXInLCAnbWV0YWRhdGEnLCAncHVibGljS2V5JywgJ2lzRnVsbElkZW50aXR5JywgJ3R5cGUnXVxuICAgICAgLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzW2tleV0pO1xuICAgIHRoaXMuX3RyaWdnZXJBc3luYygnaWRlbnRpdGllczp1bmZvbGxvdycpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBJZGVudGl0eSBiYXNlZCBvbiBhIFNlcnZlciBkZXNjcmlwdGlvbiBvZiB0aGUgdXNlci5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlRnJvbVNlcnZlclxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpZGVudGl0eSAtIFNlcnZlciBJZGVudGl0eSBPYmplY3RcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcmV0dXJucyB7bGF5ZXIuSWRlbnRpdHl9XG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUZyb21TZXJ2ZXIoaWRlbnRpdHksIGNsaWVudCkge1xuICAgIHJldHVybiBuZXcgSWRlbnRpdHkoe1xuICAgICAgY2xpZW50LFxuICAgICAgZnJvbVNlcnZlcjogaWRlbnRpdHksXG4gICAgICBfZnJvbURCOiBpZGVudGl0eS5fZnJvbURCLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGxheSBuYW1lIGZvciB0aGUgVXNlciBvciBTeXN0ZW0gSWRlbnRpdHkuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5JZGVudGl0eS5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSAnJztcblxuLyoqXG4gKiBUaGUgSWRlbnRpdHkgbWF0Y2hpbmcgYGxheWVyLkNsaWVudC51c2VyYCB3aWxsIGhhdmUgdGhpcyBiZSB0cnVlLlxuICpcbiAqIEFsbCBvdGhlciBJZGVudGl0aWVzIHdpbGwgaGF2ZSB0aGlzIGFzIGZhbHNlLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbklkZW50aXR5LnByb3RvdHlwZS5zZXNzaW9uT3duZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBJRCBvZiB0aGUgQ2xpZW50IHRoaXMgSWRlbnRpdHkgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLmNsaWVudElkID0gJyc7XG5cbi8qKlxuICogSXMgdGhpcyBhIEZ1bGwgSWRlbnRpdHkgb3IgQmFzaWMgSWRlbnRpdHk/XG4gKlxuICogTm90ZSB0aGF0IFNlcnZpY2UgSWRlbnRpdGllcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdG8gYmUgQmFzaWMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLmlzRnVsbElkZW50aXR5ID0gZmFsc2U7XG5cbi8qKlxuICogVW5pcXVlIElEIGZvciB0aGlzIFVzZXIuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5JZGVudGl0eS5wcm90b3R5cGUudXNlcklkID0gJyc7XG5cbi8qKlxuICogT3B0aW9uYWwgVVJMIGZvciB0aGUgdXNlcidzIGljb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5JZGVudGl0eS5wcm90b3R5cGUuYXZhdGFyVXJsID0gJyc7XG5cbi8qKlxuICogT3B0aW9uYWwgZmlyc3QgbmFtZSBmb3IgdGhpcyB1c2VyLlxuICpcbiAqIEZ1bGwgSWRlbnRpdGllcyBPbmx5LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbklkZW50aXR5LnByb3RvdHlwZS5maXJzdE5hbWUgPSAnJztcblxuLyoqXG4gKiBPcHRpb25hbCBsYXN0IG5hbWUgZm9yIHRoaXMgdXNlci5cbiAqXG4gKiBGdWxsIElkZW50aXRpZXMgT25seS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5JZGVudGl0eS5wcm90b3R5cGUubGFzdE5hbWUgPSAnJztcblxuLyoqXG4gKiBPcHRpb25hbCBlbWFpbCBhZGRyZXNzIGZvciB0aGlzIHVzZXIuXG4gKlxuICogRnVsbCBJZGVudGl0aWVzIE9ubHkuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLmVtYWlsQWRkcmVzcyA9ICcnO1xuXG4vKipcbiAqIE9wdGlvbmFsIHBob25lIG51bWJlciBmb3IgdGhpcyB1c2VyLlxuICpcbiAqIEZ1bGwgSWRlbnRpdGllcyBPbmx5LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbklkZW50aXR5LnByb3RvdHlwZS5waG9uZU51bWJlciA9ICcnO1xuXG4vKipcbiAqIE9wdGlvbmFsIG1ldGFkYXRhIGZvciB0aGlzIHVzZXIuXG4gKlxuICogRnVsbCBJZGVudGl0aWVzIE9ubHkuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLm1ldGFkYXRhID0gbnVsbDtcblxuLyoqXG4gKiBPcHRpb25hbCBwdWJsaWMga2V5IGZvciBlbmNyeXB0aW5nIG1lc3NhZ2UgdGV4dCBmb3IgdGhpcyB1c2VyLlxuICpcbiAqIEZ1bGwgSWRlbnRpdGllcyBPbmx5LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbklkZW50aXR5LnByb3RvdHlwZS5wdWJsaWNLZXkgPSAnJztcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7c3RyaW5nfSBUaGUgSWRlbnRpdHkgcmVwcmVzZW50cyBhIHVzZXIuICBWYWx1ZSB1c2VkIGluIHRoZSBsYXllci5JZGVudGl0eS50eXBlIGZpZWxkLlxuICovXG5JZGVudGl0eS5Vc2VyVHlwZSA9ICd1c2VyJztcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7c3RyaW5nfSBUaGUgSWRlbnRpdHkgcmVwcmVzZW50cyBhIGJvdC4gIFZhbHVlIHVzZWQgaW4gdGhlIGxheWVyLklkZW50aXR5LnR5cGUgZmllbGQuXG4gKi9cbklkZW50aXR5LkJvdFR5cGUgPSAnYm90JztcblxuLyoqXG4gKiBXaGF0IHR5cGUgb2YgSWRlbnRpdHkgZG9lcyB0aGlzIHJlcHJlc2VudD9cbiAqXG4gKiAqIEEgYm90PyBVc2UgbGF5ZXIuSWRlbnRpdHkuQm90VHlwZVxuICogKiBBIFVzZXI/IFVzZSBsYXllci5JZGVudGl0eS5Vc2VyVHlwZVxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLnR5cGUgPSBJZGVudGl0eS5Vc2VyVHlwZTtcblxuLyoqXG4gKiBQcmVzZW5jZSBvYmplY3QgY29udGFpbnMgcHJlc2VuY2UgaW5mb3JtYXRpb24gZm9yIHRoaXMgdXNlci5cbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIHRoZSBzdWItb2JqZWN0IGFyZTpcbiAqXG4gKiAqIGBzdGF0dXNgOiBoYXMgdGhlIGZvbGxvd2luZyBwb3NzaWJsZSB2YWx1ZXM6XG4gKiAqKiBgYXZhaWxhYmxlYDogVXNlciBoYXMgc2V0IHRoZWlyIHN0YXR1cyB0byBgYXZhaWxhYmxlYC4gIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW5pdGlhbCBzdGF0ZVxuICogKiogYGF3YXlgOiBBcHAgb3IgVXNlciBoYXMgY2hhbmdlZCB0aGVpciBzdGF0dXMgdG8gYGF3YXlgXG4gKiAqKiBgYnVzeWA6IEFwcCBvciBVc2VyIGhhcyBjaGFuZ2VkIHRoZWlyIHN0YXR1cyB0byBgYnVzeWBcbiAqICoqIGBvZmZsaW5lYDogVXNlciBpcyBub3QgY29ubmVjdGVkIG9yIGhhcyBzZXQgdGhlaXIgc3RhdHVzIHRvIGBvZmZsaW5lYFxuICogKiogYGludmlzaWJsZWA6IFdoZW4gYSB1c2VyIGhhcyBzZXQgdGhlaXIgc3RhdHVzIHRvIGBvZmZsaW5lYCB0aGV5IGluc3RlYWQgc2VlIGEgc3RhdHVzIG9mIGBpbnZpc2libGVgIHNvIHRoYXQgdGhleSBrbm93XG4gKiAgICB0aGF0IHRoZXkgaGF2ZSBkZWxpYmVyYXRlbHkgc2V0IHRoZWlyIHN0YXR1cyB0byBgb2ZmbGluZWAgYnV0IGFyZSBzdGlsbCBjb25uZWN0ZWQuXG4gKiAqIGBsYXN0U2VlbkF0YDogQXBwcm94aW1hdGUgdGltZSB0aGF0IHRoZSB1c2VyIHdhcyBsYXN0IGtub3duIHRvIGJlIGNvbm5lY3RlZCAoYW5kIG5vdCBgaW52aXNpYmxlYClcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gX3ByZXNlbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gX3ByZXNlbmNlLnN0YXR1c1xuICogQHByb3BlcnR5IHtEYXRlfSBfcHJlc2VuY2UubGFzdFNlZW5BdFxuICogQHByaXZhdGVcbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLl9wcmVzZW5jZSA9IG51bGw7XG5cbi8qKlxuICogVGhlIHVzZXIncyBjdXJyZW50IHN0YXR1cyBvciBhdmFpbGFiaWxpdHkuXG4gKlxuICogVmFsdWUgaXMgb25lIG9mOlxuICpcbiAqICogYGxheWVyLklkZW50aXR5LlNUQVRVUy5BVkFJTEFCTEVgOiBVc2VyIGhhcyBzZXQgdGhlaXIgc3RhdHVzIHRvIGBhdmFpbGFibGVgLiAgVGhpcyBpcyB0aGUgZGVmYXVsdCBpbml0aWFsIHN0YXRlXG4gKiAqIGBsYXllci5JZGVudGl0eS5TVEFUVVMuQVdBWWA6IEFwcCBvciBVc2VyIGhhcyBjaGFuZ2VkIHRoZWlyIHN0YXR1cyB0byBgYXdheWBcbiAqICogYGxheWVyLklkZW50aXR5LlNUQVRVUy5CVVNZYDogQXBwIG9yIFVzZXIgaGFzIGNoYW5nZWQgdGhlaXIgc3RhdHVzIHRvIGBidXN5YFxuICogKiBgbGF5ZXIuSWRlbnRpdHkuU1RBVFVTLk9GRkxJTkVgOiBVc2VyIGlzIG5vdCBjb25uZWN0ZWQgb3IgaGFzIHNldCB0aGVpciBzdGF0dXMgdG8gYG9mZmxpbmVgXG4gKiAqIGBsYXllci5JZGVudGl0eS5TVEFUVVMuSU5WSVNJQkxFYDogV2hlbiBhIHVzZXIgaGFzIHNldCB0aGVpciBzdGF0dXMgdG8gYG9mZmxpbmVgIHRoZXkgaW5zdGVhZCBzZWUgYSBzdGF0dXMgb2YgYGludmlzaWJsZWAgc28gdGhhdCB0aGV5IGtub3dcbiAqICAgIHRoYXQgdGhleSBoYXZlIGRlbGliZXJhdGVseSBzZXQgdGhlaXIgc3RhdHVzIHRvIGBvZmZsaW5lYCBidXQgYXJlIHN0aWxsIGNvbm5lY3RlZC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHNldCBvbiB0aGUgc2Vzc2lvbiBvd25lcidzIGlkZW50aXR5LCBub3Qgb24gb3RoZXIgaWRlbnRpdGllcyB2aWE6XG4gKlxuICogYGBgXG4gKiBjbGllbnQudXNlci5zZXRTdGF0dXMobGF5ZXIuSWRlbnRpdHkuU1RBVFVTLkFWQUlMQUJMRSk7XG4gKiBgYGBcbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc3RhdHVzXG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aXR5LnByb3RvdHlwZSwgJ3N0YXR1cycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9wcmVzZW5jZSAmJiB0aGlzLl9wcmVzZW5jZS5zdGF0dXMpIHx8IElkZW50aXR5LlNUQVRVUy5PRkZMSU5FO1xuICB9LFxufSk7XG5cbi8qKlxuICogVGltZSB0aGF0IHRoZSB1c2VyIHdhcyBsYXN0IGtub3duIHRvIGJlIG9ubGluZS5cbiAqXG4gKiBBY2N1cmF0ZSB0byB3aXRoaW4gYWJvdXQgMTUgbWludXRlcy4gIFVzZXIncyB3aG8gYXJlIG9ubGluZSwgYnV0IHNldCB0aGVpciBzdGF0dXNcbiAqIHRvIGBsYXllci5JZGVudGl0eS5TVEFUVVMuSU5WSVNJQkxFYCB3aWxsIG5vdCBoYXZlIHRoZWlyIGBsYXN0U2VlbkF0YCB2YWx1ZSB1cGRhdGVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7RGF0ZX0gbGFzdFNlZW5BdFxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGl0eS5wcm90b3R5cGUsICdsYXN0U2VlbkF0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlc2VuY2UgJiYgdGhpcy5fcHJlc2VuY2UubGFzdFNlZW5BdDtcbiAgfSxcbn0pO1xuXG4vKipcbiAqIElzIHRoaXMgSWRlbnRpdHkgYSBib3Q/XG4gKlxuICogSWYgdGhlIGxheWVyLklkZW50aXR5LnR5cGUgZmllbGQgaXMgZXF1YWwgdG8gbGF5ZXIuSWRlbnRpdHkuQm90VHlwZSB0aGVuIHRoaXMgd2lsbCByZXR1cm4gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNCb3RcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aXR5LnByb3RvdHlwZSwgJ2lzQm90Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZGVudGl0eS5Cb3RUeXBlO1xuICB9LFxufSk7XG5cbi8qKlxuICogUG9zc2libGUgdmFsdWVzIGZvciBsYXllci5JZGVudGl0eS5zdGF0dXMgZmllbGQgdG8gYmUgdXNlZCBpbiBgc2V0U3RhdHVzKClgXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFNUQVRVU1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFNUQVRVUy5BVkFJTEFCTEUgICBVc2VyIGhhcyBzZXQgdGhlaXIgc3RhdHVzIHRvIGBhdmFpbGFibGVgLiAgVGhpcyBpcyB0aGUgZGVmYXVsdCBpbml0aWFsIHN0YXRlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gU1RBVFVTLkFXQVkgICAgICAgIEFwcCBvciBVc2VyIGhhcyBjaGFuZ2VkIHRoZWlyIHN0YXR1cyB0byBgYXdheWBcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBTVEFUVVMuQlVTWSAgICAgQXBwIG9yIFVzZXIgaGFzIGNoYW5nZWQgdGhlaXIgc3RhdHVzIHRvIGBidXN5YFxuICogQHByb3BlcnR5IHtTdHJpbmd9IFNUQVRVUy5PRkZMSU5FICBVc2VyIGlzIG5vdCBjb25uZWN0ZWQgb3IgaGFzIHNldCB0aGVpciBzdGF0dXMgdG8gYG9mZmxpbmVgXG4gKiBAcHJvcGVydHkge1N0cmluZ30gU1RBVFVTLklOVklTSUJMRSAgV2hlbiBhIHVzZXIgaGFzIHNldCB0aGVpciBzdGF0dXMgdG8gYG9mZmxpbmVgIHRoZXkgaW5zdGVhZCBzZWUgYSBzdGF0dXMgb2YgYGludmlzaWJsZWAgc28gdGhhdCB0aGV5IGtub3dcbiAqICAgIHRoYXQgdGhleSBoYXZlIGRlbGliZXJhdGVseSBzZXQgdGhlaXIgc3RhdHVzIHRvIGBvZmZsaW5lYCBidXQgYXJlIHN0aWxsIGNvbm5lY3RlZC5cbiAqIEBzdGF0aWNcbiAqL1xuSWRlbnRpdHkuU1RBVFVTID0ge1xuICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICBBV0FZOiAnYXdheScsXG4gIE9GRkxJTkU6ICdvZmZsaW5lJyxcbiAgQlVTWTogJ2J1c3knLFxuICBJTlZJU0lCTEU6ICdpbnZpc2libGUnLFxufTtcblxuSWRlbnRpdHkuaW5PYmplY3RJZ25vcmUgPSBSb290LmluT2JqZWN0SWdub3JlO1xuXG5JZGVudGl0eS5idWJibGVFdmVudFBhcmVudCA9ICdnZXRDbGllbnQnO1xuXG5JZGVudGl0eS5fc3VwcG9ydGVkRXZlbnRzID0gW1xuICAnaWRlbnRpdGllczpjaGFuZ2UnLFxuICAnaWRlbnRpdGllczpsb2FkZWQnLFxuICAnaWRlbnRpdGllczpsb2FkZWQtZXJyb3InLFxuICAnaWRlbnRpdGllczp1bmZvbGxvdycsXG5dLmNvbmNhdChTeW5jYWJsZS5fc3VwcG9ydGVkRXZlbnRzKTtcblxuSWRlbnRpdHkuZXZlbnRQcmVmaXggPSAnaWRlbnRpdGllcyc7XG5JZGVudGl0eS5wcmVmaXhVVUlEID0gJ2xheWVyOi8vL2lkZW50aXRpZXMvJztcbklkZW50aXR5LmVuYWJsZU9wc0lmTmV3ID0gdHJ1ZTtcblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoSWRlbnRpdHksIFtJZGVudGl0eSwgJ0lkZW50aXR5J10pO1xuU3luY2FibGUuc3ViY2xhc3Nlcy5wdXNoKElkZW50aXR5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eTtcbiJdfQ==
