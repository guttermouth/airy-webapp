'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Syncable abstract clas represents resources that are syncable with the server.
 * This is currently used for Messages and Conversations.
 * It represents the state of the object's sync, as one of:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * @class layer.Syncable
 * @extends layer.Root
 * @abstract
 */

var Root = require('../root');

var _require = require('../const');

var SYNC_STATE = _require.SYNC_STATE;

var LayerError = require('../layer-error');
var ClientRegistry = require('../client-registry');
var Constants = require('../const');

var Syncable = function (_Root) {
  _inherits(Syncable, _Root);

  function Syncable() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Syncable);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Syncable).call(this, options));

    _this.localCreatedAt = new Date();
    return _this;
  }

  /**
   * Get the client associated with this Object.
   *
   * @method getClient
   * @return {layer.Client}
   */


  _createClass(Syncable, [{
    key: 'getClient',
    value: function getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Fire an XHR request using the URL for this resource.
     *
     * For more info on xhr method parameters see {@link layer.ClientAuthenticator#xhr}
     *
     * @method _xhr
     * @protected
     * @return {layer.Syncable} this
     */

  }, {
    key: '_xhr',
    value: function _xhr(options, callback) {
      var _this2 = this;

      // initialize
      if (!options.url) options.url = '';
      if (!options.method) options.method = 'GET';
      var client = this.getClient();

      // Validatation
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      if (!client) throw new Error(LayerError.dictionary.clientMissing);
      if (!this.constructor.enableOpsIfNew && options.method !== 'POST' && options.method !== 'GET' && this.syncState === Constants.SYNC_STATE.NEW) return this;

      if (!options.url.match(/^http(s):\/\//)) {
        if (options.url && !options.url.match(/^(\/|\?)/)) options.url = '/' + options.url;
        if (!options.sync) options.url = this.url + options.url;
      }

      // Setup sync structure
      options.sync = this._setupSyncObject(options.sync);

      if (options.method !== 'GET') {
        this._setSyncing();
      }

      client.xhr(options, function (result) {
        if (result.success && options.method !== 'GET' && !_this2.isDestroyed) {
          _this2._setSynced();
        }
        if (callback) callback(result);
      });
      return this;
    }

    /**
     * Setup an object to pass in the `sync` parameter for any sync requests.
     *
     * @method _setupSyncObject
     * @private
     * @param {Object} sync - Known parameters of the sync object to be returned; or null.
     * @return {Object} fleshed out sync object
     */

  }, {
    key: '_setupSyncObject',
    value: function _setupSyncObject(sync) {
      if (sync !== false) {
        if (!sync) sync = {};
        if (!sync.target) sync.target = this.id;
      }
      return sync;
    }

    /**
     * A websocket event has been received specifying that this resource
     * has been deleted.
     *
     * @method handleWebsocketDelete
     * @protected
     * @param {Object} data
     */

  }, {
    key: '_handleWebsocketDelete',
    value: function _handleWebsocketDelete(data) {
      this._deleted();
      this.destroy();
    }

    /**
     * The Object has been deleted.
     *
     * Destroy must be called separately, and handles most cleanup.
     *
     * @method _deleted
     * @protected
     */

  }, {
    key: '_deleted',
    value: function _deleted() {
      this.trigger(this.constructor.eventPrefix + ':delete');
    }

    /**
     * Load the resource identified via a Layer ID.
     *
     * Will load the requested resource from persistence or server as needed,
     * and trigger `type-name:loaded` when its loaded.  Instance returned by this
     * method will have only ID and URL properties, all others are unset until
     * the `conversations:loaded`, `messages:loaded`, etc... event has fired.
     *
     * ```
     * var message = layer.Message.load(messageId, client);
     * message.once('messages:loaded', function(evt) {
     *    alert("Message loaded");
     * });
     * ```
     *
     * @method load
     * @static
     * @param {string} id - `layer:///messages/UUID`
     * @param {layer.Client} client
     * @return {layer.Syncable} - Returns an empty object that will be populated once data is loaded.
     */

  }, {
    key: '_load',


    /**
     * Load this resource from the server.
     *
     * Called from the static layer.Syncable.load() method
     *
     * @method _load
     * @private
     */
    value: function _load() {
      var _this3 = this;

      this.syncState = SYNC_STATE.LOADING;
      this._xhr({
        method: 'GET',
        sync: false
      }, function (result) {
        return _this3._loadResult(result);
      });
    }
  }, {
    key: '_loadResult',
    value: function _loadResult(result) {
      var _this4 = this;

      if (this.isDestroyed) return;
      var prefix = this.constructor.eventPrefix;
      if (!result.success) {
        this.syncState = SYNC_STATE.NEW;
        this._triggerAsync(prefix + ':loaded-error', { error: result.data });
        setTimeout(function () {
          if (!_this4.isDestroyed) _this4.destroy();
        }, 100); // Insure destroyed AFTER loaded-error event has triggered
      } else {
        this._populateFromServer(result.data);
        this._loaded(result.data);
        this.trigger(prefix + ':loaded');
      }
    }

    /**
     * Processing the result of a _load() call.
     *
     * Typically used to register the object and cleanup any properties not handled by _populateFromServer.
     *
     * @method _loaded
     * @private
     * @param  {Object} data - Response data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {}

    /**
     * Object is new, and is queued for syncing, but does not yet exist on the server.
     *
     * That means it is currently out of sync with the server.
     *
     * @method _setSyncing
     * @private
     */

  }, {
    key: '_setSyncing',
    value: function _setSyncing() {
      this._clearObject();
      switch (this.syncState) {
        case SYNC_STATE.SYNCED:
          this.syncState = SYNC_STATE.SYNCING;
          break;
        case SYNC_STATE.NEW:
          this.syncState = SYNC_STATE.SAVING;
          break;
      }
      this._syncCounter++;
    }

    /**
     * Object is synced with the server and up to date.
     *
     * @method _setSynced
     * @private
     */

  }, {
    key: '_setSynced',
    value: function _setSynced() {
      this._clearObject();
      if (this._syncCounter > 0) this._syncCounter--;

      this.syncState = this._syncCounter === 0 ? SYNC_STATE.SYNCED : SYNC_STATE.SYNCING;
      this.isSending = false;
    }

    /**
     * Any time the instance changes, we should clear the cached toObject value
     *
     * @method _clearObject
     * @private
     */

  }, {
    key: '_clearObject',
    value: function _clearObject() {
      this._toObject = null;
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Syncable instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this object.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Syncable.prototype), 'toObject', this).call(this);
        this._toObject.isNew = this.isNew();
        this._toObject.isSaving = this.isSaving();
        this._toObject.isSaved = this.isSaved();
        this._toObject.isSynced = this.isSynced();
      }
      return this._toObject;
    }

    /**
     * Object is new, and is not yet queued for syncing
     *
     * @method isNew
     * @returns {boolean}
     */

  }, {
    key: 'isNew',
    value: function isNew() {
      return this.syncState === SYNC_STATE.NEW;
    }

    /**
     * Object is new, and is queued for syncing
     *
     * @method isSaving
     * @returns {boolean}
     */

  }, {
    key: 'isSaving',
    value: function isSaving() {
      return this.syncState === SYNC_STATE.SAVING;
    }

    /**
     * Object exists on server.
     *
     * @method isSaved
     * @returns {boolean}
     */

  }, {
    key: 'isSaved',
    value: function isSaved() {
      return !(this.isNew() || this.isSaving());
    }

    /**
     * Object is fully synced.
     *
     * As best we know, server and client have the same values.
     *
     * @method isSynced
     * @returns {boolean}
     */

  }, {
    key: 'isSynced',
    value: function isSynced() {
      return this.syncState === SYNC_STATE.SYNCED;
    }
  }], [{
    key: 'load',
    value: function load(id, client) {
      if (!client || !(client instanceof Root)) throw new Error(LayerError.dictionary.clientMissing);

      var obj = {
        id: id,
        url: client.url + id.substring(8),
        clientId: client.appId
      };

      if (!Syncable.sortedSubclasses) {
        Syncable.sortedSubclasses = Syncable.subclasses.filter(function (item) {
          return item.prefixUUID;
        }).sort(function (a, b) {
          return a.prefixUUID.length - b.prefixUUID.length;
        });
      }

      var ConstructorClass = Syncable.sortedSubclasses.filter(function (aClass) {
        if (aClass.prefixUUID.indexOf('layer:///') === 0) {
          return obj.id.indexOf(aClass.prefixUUID) === 0;
        } else {
          return obj.id.indexOf(aClass.prefixUUID) !== -1;
        }
      })[0];
      var syncItem = new ConstructorClass(obj);
      var typeName = ConstructorClass.eventPrefix;

      if (typeName) {
        if (!client.dbManager) {
          syncItem.syncState = SYNC_STATE.LOADING;
          client.once('ready', function () {
            return syncItem._load();
          });
        } else {
          client.dbManager.getObject(typeName, id, function (item) {
            if (syncItem.isDestroyed) return;
            if (item) {
              syncItem._populateFromServer(item);
              syncItem.trigger(typeName + ':loaded');
            } else if (!client.isReady) {
              syncItem.syncState = SYNC_STATE.LOADING;
              client.once('ready', function () {
                return syncItem._load();
              });
            } else {
              syncItem._load();
            }
          });
        }
      } else {
        syncItem._load();
      }

      syncItem.syncState = SYNC_STATE.LOADING;
      return syncItem;
    }
  }]);

  return Syncable;
}(Root);

/**
 * Unique identifier.
 *
 * @type {string}
 */


Syncable.prototype.id = '';

/**
 * URL to access the object on the server.
 *
 * @type {string}
 * @readonly
 * @protected
 */
Syncable.prototype.url = '';

/**
 * The time that this client created this instance.
 *
 * This value is not tied to when it was first created on the server.  Creating a new instance
 * based on server data will result in a new `localCreateAt` value.
 *
 * @type {Date}
 */
Syncable.prototype.localCreatedAt = null;

/**
 * layer.Client that the object belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 * @protected
 * @readonly
 */
Syncable.prototype.clientId = '';

/**
 * Temporary property indicating that the instance was loaded from local database rather than server.
 *
 * @type {boolean}
 * @private
 */
Syncable.prototype._fromDB = false;

/**
 * The current sync state of this object.
 *
 * Possible values are:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * @type {string}
 */
Syncable.prototype.syncState = SYNC_STATE.NEW;

/**
 * Number of sync requests that have been requested.
 *
 * Counts down to zero; once it reaches zero, all sync
 * requests have been completed.
 *
 * @type {Number}
 * @private
 */
Syncable.prototype._syncCounter = 0;

/**
 * Prefix to use when triggering events
 * @private
 * @static
 */
Syncable.eventPrefix = '';

Syncable.enableOpsIfNew = false;

/**
 * Is the object loading from the server?
 *
 * @type {boolean}
 */
Object.defineProperty(Syncable.prototype, 'isLoading', {
  enumerable: true,
  get: function get() {
    return this.syncState === SYNC_STATE.LOADING;
  }
});

/**
 * Array of classes that are subclasses of Syncable.
 *
 * Used by Factory function.
 * @private
 */
Syncable.subclasses = [];

Syncable._supportedEvents = [].concat(Root._supportedEvents);
Syncable.inObjectIgnore = Root.inObjectIgnore;
module.exports = Syncable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvc3luY2FibGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsSUFBTSxPQUFPLFFBQVEsU0FBUixDQUFiOztlQUN1QixRQUFRLFVBQVIsQzs7SUFBZixVLFlBQUEsVTs7QUFDUixJQUFNLGFBQWEsUUFBUSxnQkFBUixDQUFuQjtBQUNBLElBQU0saUJBQWlCLFFBQVEsb0JBQVIsQ0FBdkI7QUFDQSxJQUFNLFlBQVksUUFBUSxVQUFSLENBQWxCOztJQUVNLFE7OztBQUNKLHNCQUEwQjtBQUFBLFFBQWQsT0FBYyx5REFBSixFQUFJOztBQUFBOztBQUFBLDRGQUNsQixPQURrQjs7QUFFeEIsVUFBSyxjQUFMLEdBQXNCLElBQUksSUFBSixFQUF0QjtBQUZ3QjtBQUd6Qjs7QUFFRDs7Ozs7Ozs7OztnQ0FNWTtBQUNWLGFBQU8sZUFBZSxHQUFmLENBQW1CLEtBQUssUUFBeEIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7eUJBU0ssTyxFQUFTLFEsRUFBVTtBQUFBOztBQUN0QjtBQUNBLFVBQUksQ0FBQyxRQUFRLEdBQWIsRUFBa0IsUUFBUSxHQUFSLEdBQWMsRUFBZDtBQUNsQixVQUFJLENBQUMsUUFBUSxNQUFiLEVBQXFCLFFBQVEsTUFBUixHQUFpQixLQUFqQjtBQUNyQixVQUFNLFNBQVMsS0FBSyxTQUFMLEVBQWY7O0FBRUE7QUFDQSxVQUFJLEtBQUssV0FBVCxFQUFzQixNQUFNLElBQUksS0FBSixDQUFVLFdBQVcsVUFBWCxDQUFzQixXQUFoQyxDQUFOO0FBQ3RCLFVBQUksQ0FBQyxNQUFMLEVBQWEsTUFBTSxJQUFJLEtBQUosQ0FBVSxXQUFXLFVBQVgsQ0FBc0IsYUFBaEMsQ0FBTjtBQUNiLFVBQUksQ0FBQyxLQUFLLFdBQUwsQ0FBaUIsY0FBbEIsSUFDRixRQUFRLE1BQVIsS0FBbUIsTUFEakIsSUFDMkIsUUFBUSxNQUFSLEtBQW1CLEtBRDlDLElBRUYs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O0FBRUEsU0FBUyxjQUFULEdBQTBCLEtBQTFCOztBQUVBOzs7OztBQUtBLE9BQU8sY0FBUCxDQUFzQixTQUFTLFNBQS9CLEVBQTBDLFdBQTFDLEVBQXVEO0FBQ3JELGNBQVksSUFEeUM7QUFFckQsT0FBSyxTQUFTLEdBQVQsR0FBZTtBQUNsQixXQUFPLEtBQUssU0FBTCxLQUFtQixXQUFXLE9BQXJDO0FBQ0Q7QUFKb0QsQ0FBdkQ7O0FBT0E7Ozs7OztBQU1BLFNBQVMsVUFBVCxHQUFzQixFQUF0Qjs7QUFFQSxTQUFTLGdCQUFULEdBQTRCLEdBQUcsTUFBSCxDQUFVLEtBQUssZ0JBQWYsQ0FBNUI7QUFDQSxTQUFTLGNBQVQsR0FBMEIsS0FBSyxjQUEvQjtBQUNBLE9BQU8sT0FBUCxHQUFpQixRQUFqQiIsImZpbGUiOiJzeW5jYWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIFN5bmNhYmxlIGFic3RyYWN0IGNsYXMgcmVwcmVzZW50cyByZXNvdXJjZXMgdGhhdCBhcmUgc3luY2FibGUgd2l0aCB0aGUgc2VydmVyLlxuICogVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBmb3IgTWVzc2FnZXMgYW5kIENvbnZlcnNhdGlvbnMuXG4gKiBJdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgb2JqZWN0J3Mgc3luYywgYXMgb25lIG9mOlxuICpcbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLk5FVzogTmV3bHkgY3JlYXRlZDsgbG9jYWwgb25seS5cbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLlNBVklORzogTmV3bHkgY3JlYXRlZDsgYmVpbmcgc2VudCB0byB0aGUgc2VydmVyXG4gKiAgKiBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5TWU5DSU5HOiBFeGlzdHMgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgYnV0IGNoYW5nZXMgYXJlIGJlaW5nIHNlbnQgdG8gc2VydmVyLlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuU1lOQ0VEOiBFeGlzdHMgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciBhbmQgaXMgc3luY2VkLlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuTE9BRElORzogRXhpc3RzIG9uIHNlcnZlcjsgbG9hZGluZyBpdCBpbnRvIGNsaWVudC5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuU3luY2FibGVcbiAqIEBleHRlbmRzIGxheWVyLlJvb3RcbiAqIEBhYnN0cmFjdFxuICovXG5cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuLi9yb290Jyk7XG5jb25zdCB7IFNZTkNfU1RBVEUgfSA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IENsaWVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vY2xpZW50LXJlZ2lzdHJ5Jyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG5jbGFzcyBTeW5jYWJsZSBleHRlbmRzIFJvb3Qge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLmxvY2FsQ3JlYXRlZEF0ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBPYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Q2xpZW50XG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudH1cbiAgICovXG4gIGdldENsaWVudCgpIHtcbiAgICByZXR1cm4gQ2xpZW50UmVnaXN0cnkuZ2V0KHRoaXMuY2xpZW50SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgYW4gWEhSIHJlcXVlc3QgdXNpbmcgdGhlIFVSTCBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICpcbiAgICogRm9yIG1vcmUgaW5mbyBvbiB4aHIgbWV0aG9kIHBhcmFtZXRlcnMgc2VlIHtAbGluayBsYXllci5DbGllbnRBdXRoZW50aWNhdG9yI3hocn1cbiAgICpcbiAgICogQG1ldGhvZCBfeGhyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7bGF5ZXIuU3luY2FibGV9IHRoaXNcbiAgICovXG4gIF94aHIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAvLyBpbml0aWFsaXplXG4gICAgaWYgKCFvcHRpb25zLnVybCkgb3B0aW9ucy51cmwgPSAnJztcbiAgICBpZiAoIW9wdGlvbnMubWV0aG9kKSBvcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG5cbiAgICAvLyBWYWxpZGF0YXRpb25cbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pc0Rlc3Ryb3llZCk7XG4gICAgaWYgKCFjbGllbnQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmVuYWJsZU9wc0lmTmV3ICYmXG4gICAgICBvcHRpb25zLm1ldGhvZCAhPT0gJ1BPU1QnICYmIG9wdGlvbnMubWV0aG9kICE9PSAnR0VUJyAmJlxuICAgICAgdGhpcy5zeW5jU3RhdGUgPT09IENvbnN0YW50cy5TWU5DX1NUQVRFLk5FVykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIW9wdGlvbnMudXJsLm1hdGNoKC9eaHR0cChzKTpcXC9cXC8vKSkge1xuICAgICAgaWYgKG9wdGlvbnMudXJsICYmICFvcHRpb25zLnVybC5tYXRjaCgvXihcXC98XFw/KS8pKSBvcHRpb25zLnVybCA9ICcvJyArIG9wdGlvbnMudXJsO1xuICAgICAgaWYgKCFvcHRpb25zLnN5bmMpIG9wdGlvbnMudXJsID0gdGhpcy51cmwgKyBvcHRpb25zLnVybDtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBzeW5jIHN0cnVjdHVyZVxuICAgIG9wdGlvbnMuc3luYyA9IHRoaXMuX3NldHVwU3luY09iamVjdChvcHRpb25zLnN5bmMpO1xuXG4gICAgaWYgKG9wdGlvbnMubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgdGhpcy5fc2V0U3luY2luZygpO1xuICAgIH1cblxuICAgIGNsaWVudC54aHIob3B0aW9ucywgKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIG9wdGlvbnMubWV0aG9kICE9PSAnR0VUJyAmJiAhdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9zZXRTeW5jZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2socmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBhbiBvYmplY3QgdG8gcGFzcyBpbiB0aGUgYHN5bmNgIHBhcmFtZXRlciBmb3IgYW55IHN5bmMgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBtZXRob2QgX3NldHVwU3luY09iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3luYyAtIEtub3duIHBhcmFtZXRlcnMgb2YgdGhlIHN5bmMgb2JqZWN0IHRvIGJlIHJldHVybmVkOyBvciBudWxsLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGZsZXNoZWQgb3V0IHN5bmMgb2JqZWN0XG4gICAqL1xuICBfc2V0dXBTeW5jT2JqZWN0KHN5bmMpIHtcbiAgICBpZiAoc3luYyAhPT0gZmFsc2UpIHtcbiAgICAgIGlmICghc3luYykgc3luYyA9IHt9O1xuICAgICAgaWYgKCFzeW5jLnRhcmdldCkgc3luYy50YXJnZXQgPSB0aGlzLmlkO1xuICAgIH1cbiAgICByZXR1cm4gc3luYztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHdlYnNvY2tldCBldmVudCBoYXMgYmVlbiByZWNlaXZlZCBzcGVjaWZ5aW5nIHRoYXQgdGhpcyByZXNvdXJjZVxuICAgKiBoYXMgYmVlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIGhhbmRsZVdlYnNvY2tldERlbGV0ZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICBfaGFuZGxlV2Vic29ja2V0RGVsZXRlKGRhdGEpIHtcbiAgICB0aGlzLl9kZWxldGVkKCk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9iamVjdCBoYXMgYmVlbiBkZWxldGVkLlxuICAgKlxuICAgKiBEZXN0cm95IG11c3QgYmUgY2FsbGVkIHNlcGFyYXRlbHksIGFuZCBoYW5kbGVzIG1vc3QgY2xlYW51cC5cbiAgICpcbiAgICogQG1ldGhvZCBfZGVsZXRlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZGVsZXRlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5ldmVudFByZWZpeCArICc6ZGVsZXRlJyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSByZXNvdXJjZSBpZGVudGlmaWVkIHZpYSBhIExheWVyIElELlxuICAgKlxuICAgKiBXaWxsIGxvYWQgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBmcm9tIHBlcnNpc3RlbmNlIG9yIHNlcnZlciBhcyBuZWVkZWQsXG4gICAqIGFuZCB0cmlnZ2VyIGB0eXBlLW5hbWU6bG9hZGVkYCB3aGVuIGl0cyBsb2FkZWQuICBJbnN0YW5jZSByZXR1cm5lZCBieSB0aGlzXG4gICAqIG1ldGhvZCB3aWxsIGhhdmUgb25seSBJRCBhbmQgVVJMIHByb3BlcnRpZXMsIGFsbCBvdGhlcnMgYXJlIHVuc2V0IHVudGlsXG4gICAqIHRoZSBgY29udmVyc2F0aW9uczpsb2FkZWRgLCBgbWVzc2FnZXM6bG9hZGVkYCwgZXRjLi4uIGV2ZW50IGhhcyBmaXJlZC5cbiAgICpcbiAgICogYGBgXG4gICAqIHZhciBtZXNzYWdlID0gbGF5ZXIuTWVzc2FnZS5sb2FkKG1lc3NhZ2VJZCwgY2xpZW50KTtcbiAgICogbWVzc2FnZS5vbmNlKCdtZXNzYWdlczpsb2FkZWQnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgYWxlcnQoXCJNZXNzYWdlIGxvYWRlZFwiKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBgbGF5ZXI6Ly8vbWVzc2FnZXMvVVVJRGBcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcmV0dXJuIHtsYXllci5TeW5jYWJsZX0gLSBSZXR1cm5zIGFuIGVtcHR5IG9iamVjdCB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIG9uY2UgZGF0YSBpcyBsb2FkZWQuXG4gICAqL1xuICBzdGF0aWMgbG9hZChpZCwgY2xpZW50KSB7XG4gICAgaWYgKCFjbGllbnQgfHwgIShjbGllbnQgaW5zdGFuY2VvZiBSb290KSkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jbGllbnRNaXNzaW5nKTtcblxuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgIGlkLFxuICAgICAgdXJsOiBjbGllbnQudXJsICsgaWQuc3Vic3RyaW5nKDgpLFxuICAgICAgY2xpZW50SWQ6IGNsaWVudC5hcHBJZCxcbiAgICB9O1xuXG4gICAgaWYgKCFTeW5jYWJsZS5zb3J0ZWRTdWJjbGFzc2VzKSB7XG4gICAgICBTeW5jYWJsZS5zb3J0ZWRTdWJjbGFzc2VzID0gU3luY2FibGUuc3ViY2xhc3Nlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnByZWZpeFVVSUQpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnByZWZpeFVVSUQubGVuZ3RoIC0gYi5wcmVmaXhVVUlELmxlbmd0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgQ29uc3RydWN0b3JDbGFzcyA9IFN5bmNhYmxlLnNvcnRlZFN1YmNsYXNzZXMuZmlsdGVyKChhQ2xhc3MpID0+IHtcbiAgICAgIGlmIChhQ2xhc3MucHJlZml4VVVJRC5pbmRleE9mKCdsYXllcjovLy8nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb2JqLmlkLmluZGV4T2YoYUNsYXNzLnByZWZpeFVVSUQpID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iai5pZC5pbmRleE9mKGFDbGFzcy5wcmVmaXhVVUlEKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfSlbMF07XG4gICAgY29uc3Qgc3luY0l0ZW0gPSBuZXcgQ29uc3RydWN0b3JDbGFzcyhvYmopO1xuICAgIGNvbnN0IHR5cGVOYW1lID0gQ29uc3RydWN0b3JDbGFzcy5ldmVudFByZWZpeDtcblxuICAgIGlmICh0eXBlTmFtZSkge1xuICAgICAgaWYgKCFjbGllbnQuZGJNYW5hZ2VyKSB7XG4gICAgICAgIHN5bmNJdGVtLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuTE9BRElORztcbiAgICAgICAgY2xpZW50Lm9uY2UoJ3JlYWR5JywgKCkgPT4gc3luY0l0ZW0uX2xvYWQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQuZGJNYW5hZ2VyLmdldE9iamVjdCh0eXBlTmFtZSwgaWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHN5bmNJdGVtLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHN5bmNJdGVtLl9wb3B1bGF0ZUZyb21TZXJ2ZXIoaXRlbSk7XG4gICAgICAgICAgICBzeW5jSXRlbS50cmlnZ2VyKHR5cGVOYW1lICsgJzpsb2FkZWQnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjbGllbnQuaXNSZWFkeSkge1xuICAgICAgICAgICAgc3luY0l0ZW0uc3luY1N0YXRlID0gU1lOQ19TVEFURS5MT0FESU5HO1xuICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ3JlYWR5JywgKCkgPT4gc3luY0l0ZW0uX2xvYWQoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bmNJdGVtLl9sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3luY0l0ZW0uX2xvYWQoKTtcbiAgICB9XG5cbiAgICBzeW5jSXRlbS5zeW5jU3RhdGUgPSBTWU5DX1NUQVRFLkxPQURJTkc7XG4gICAgcmV0dXJuIHN5bmNJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhpcyByZXNvdXJjZSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIENhbGxlZCBmcm9tIHRoZSBzdGF0aWMgbGF5ZXIuU3luY2FibGUubG9hZCgpIG1ldGhvZFxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZCgpIHtcbiAgICB0aGlzLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuTE9BRElORztcbiAgICB0aGlzLl94aHIoe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHN5bmM6IGZhbHNlLFxuICAgIH0sIHJlc3VsdCA9PiB0aGlzLl9sb2FkUmVzdWx0KHJlc3VsdCkpO1xuICB9XG5cblxuICBfbG9hZFJlc3VsdChyZXN1bHQpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuY29uc3RydWN0b3IuZXZlbnRQcmVmaXg7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhpcy5zeW5jU3RhdGUgPSBTWU5DX1NUQVRFLk5FVztcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYyhwcmVmaXggKyAnOmxvYWRlZC1lcnJvcicsIHsgZXJyb3I6IHJlc3VsdC5kYXRhIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCkgdGhpcy5kZXN0cm95KCk7XG4gICAgICB9LCAxMDApOyAvLyBJbnN1cmUgZGVzdHJveWVkIEFGVEVSIGxvYWRlZC1lcnJvciBldmVudCBoYXMgdHJpZ2dlcmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihyZXN1bHQuZGF0YSk7XG4gICAgICB0aGlzLl9sb2FkZWQocmVzdWx0LmRhdGEpO1xuICAgICAgdGhpcy50cmlnZ2VyKHByZWZpeCArICc6bG9hZGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NpbmcgdGhlIHJlc3VsdCBvZiBhIF9sb2FkKCkgY2FsbC5cbiAgICpcbiAgICogVHlwaWNhbGx5IHVzZWQgdG8gcmVnaXN0ZXIgdGhlIG9iamVjdCBhbmQgY2xlYW51cCBhbnkgcHJvcGVydGllcyBub3QgaGFuZGxlZCBieSBfcG9wdWxhdGVGcm9tU2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkZWRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIC0gUmVzcG9uc2UgZGF0YSBmcm9tIHNlcnZlclxuICAgKi9cbiAgX2xvYWRlZChkYXRhKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgaXMgbmV3LCBhbmQgaXMgcXVldWVkIGZvciBzeW5jaW5nLCBidXQgZG9lcyBub3QgeWV0IGV4aXN0IG9uIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIFRoYXQgbWVhbnMgaXQgaXMgY3VycmVudGx5IG91dCBvZiBzeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZCBfc2V0U3luY2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFN5bmNpbmcoKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3luY1N0YXRlKSB7XG4gICAgICBjYXNlIFNZTkNfU1RBVEUuU1lOQ0VEOlxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuU1lOQ0lORztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNZTkNfU1RBVEUuTkVXOlxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuU0FWSU5HO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fc3luY0NvdW50ZXIrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgaXMgc3luY2VkIHdpdGggdGhlIHNlcnZlciBhbmQgdXAgdG8gZGF0ZS5cbiAgICpcbiAgICogQG1ldGhvZCBfc2V0U3luY2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U3luY2VkKCkge1xuICAgIHRoaXMuX2NsZWFyT2JqZWN0KCk7XG4gICAgaWYgKHRoaXMuX3N5bmNDb3VudGVyID4gMCkgdGhpcy5fc3luY0NvdW50ZXItLTtcblxuICAgIHRoaXMuc3luY1N0YXRlID0gdGhpcy5fc3luY0NvdW50ZXIgPT09IDAgPyBTWU5DX1NUQVRFLlNZTkNFRCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFNZTkNfU1RBVEUuU1lOQ0lORztcbiAgICB0aGlzLmlzU2VuZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFueSB0aW1lIHRoZSBpbnN0YW5jZSBjaGFuZ2VzLCB3ZSBzaG91bGQgY2xlYXIgdGhlIGNhY2hlZCB0b09iamVjdCB2YWx1ZVxuICAgKlxuICAgKiBAbWV0aG9kIF9jbGVhck9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsZWFyT2JqZWN0KCkge1xuICAgIHRoaXMuX3RvT2JqZWN0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0LlxuICAgKlxuICAgKiBPYmplY3Qgd2lsbCBoYXZlIGFsbCB0aGUgc2FtZSBwdWJsaWMgcHJvcGVydGllcyBhcyB0aGlzXG4gICAqIFN5bmNhYmxlIGluc3RhbmNlLiAgTmV3IG9iamVjdCBpcyByZXR1cm5lZCBhbnkgdGltZVxuICAgKiBhbnkgb2YgdGhpcyBvYmplY3QncyBwcm9wZXJ0aWVzIGNoYW5nZS5cbiAgICpcbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFBPSk8gdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5fdG9PYmplY3QpIHtcbiAgICAgIHRoaXMuX3RvT2JqZWN0ID0gc3VwZXIudG9PYmplY3QoKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0LmlzTmV3ID0gdGhpcy5pc05ldygpO1xuICAgICAgdGhpcy5fdG9PYmplY3QuaXNTYXZpbmcgPSB0aGlzLmlzU2F2aW5nKCk7XG4gICAgICB0aGlzLl90b09iamVjdC5pc1NhdmVkID0gdGhpcy5pc1NhdmVkKCk7XG4gICAgICB0aGlzLl90b09iamVjdC5pc1N5bmNlZCA9IHRoaXMuaXNTeW5jZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBpcyBuZXcsIGFuZCBpcyBub3QgeWV0IHF1ZXVlZCBmb3Igc3luY2luZ1xuICAgKlxuICAgKiBAbWV0aG9kIGlzTmV3XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNOZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1N0YXRlID09PSBTWU5DX1NUQVRFLk5FVztcbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgaXMgbmV3LCBhbmQgaXMgcXVldWVkIGZvciBzeW5jaW5nXG4gICAqXG4gICAqIEBtZXRob2QgaXNTYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1NhdmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jU3RhdGUgPT09IFNZTkNfU1RBVEUuU0FWSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBleGlzdHMgb24gc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIGlzU2F2ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1NhdmVkKCkge1xuICAgIHJldHVybiAhKHRoaXMuaXNOZXcoKSB8fCB0aGlzLmlzU2F2aW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBpcyBmdWxseSBzeW5jZWQuXG4gICAqXG4gICAqIEFzIGJlc3Qgd2Uga25vdywgc2VydmVyIGFuZCBjbGllbnQgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZXRob2QgaXNTeW5jZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1N5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jU3RhdGUgPT09IFNZTkNfU1RBVEUuU1lOQ0VEO1xuICB9XG59XG5cbi8qKlxuICogVW5pcXVlIGlkZW50aWZpZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuU3luY2FibGUucHJvdG90eXBlLmlkID0gJyc7XG5cbi8qKlxuICogVVJMIHRvIGFjY2VzcyB0aGUgb2JqZWN0IG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEByZWFkb25seVxuICogQHByb3RlY3RlZFxuICovXG5TeW5jYWJsZS5wcm90b3R5cGUudXJsID0gJyc7XG5cbi8qKlxuICogVGhlIHRpbWUgdGhhdCB0aGlzIGNsaWVudCBjcmVhdGVkIHRoaXMgaW5zdGFuY2UuXG4gKlxuICogVGhpcyB2YWx1ZSBpcyBub3QgdGllZCB0byB3aGVuIGl0IHdhcyBmaXJzdCBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIuICBDcmVhdGluZyBhIG5ldyBpbnN0YW5jZVxuICogYmFzZWQgb24gc2VydmVyIGRhdGEgd2lsbCByZXN1bHQgaW4gYSBuZXcgYGxvY2FsQ3JlYXRlQXRgIHZhbHVlLlxuICpcbiAqIEB0eXBlIHtEYXRlfVxuICovXG5TeW5jYWJsZS5wcm90b3R5cGUubG9jYWxDcmVhdGVkQXQgPSBudWxsO1xuXG5cbi8qKlxuICogbGF5ZXIuQ2xpZW50IHRoYXQgdGhlIG9iamVjdCBiZWxvbmdzIHRvLlxuICpcbiAqIEFjdHVhbCB2YWx1ZSBvZiB0aGlzIHN0cmluZyBtYXRjaGVzIHRoZSBhcHBJZC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKiBAcmVhZG9ubHlcbiAqL1xuU3luY2FibGUucHJvdG90eXBlLmNsaWVudElkID0gJyc7XG5cbi8qKlxuICogVGVtcG9yYXJ5IHByb3BlcnR5IGluZGljYXRpbmcgdGhhdCB0aGUgaW5zdGFuY2Ugd2FzIGxvYWRlZCBmcm9tIGxvY2FsIGRhdGFiYXNlIHJhdGhlciB0aGFuIHNlcnZlci5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cblN5bmNhYmxlLnByb3RvdHlwZS5fZnJvbURCID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgc3luYyBzdGF0ZSBvZiB0aGlzIG9iamVjdC5cbiAqXG4gKiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICpcbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLk5FVzogTmV3bHkgY3JlYXRlZDsgbG9jYWwgb25seS5cbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLlNBVklORzogTmV3bHkgY3JlYXRlZDsgYmVpbmcgc2VudCB0byB0aGUgc2VydmVyXG4gKiAgKiBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5TWU5DSU5HOiBFeGlzdHMgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgYnV0IGNoYW5nZXMgYXJlIGJlaW5nIHNlbnQgdG8gc2VydmVyLlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuU1lOQ0VEOiBFeGlzdHMgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciBhbmQgaXMgc3luY2VkLlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuTE9BRElORzogRXhpc3RzIG9uIHNlcnZlcjsgbG9hZGluZyBpdCBpbnRvIGNsaWVudC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TeW5jYWJsZS5wcm90b3R5cGUuc3luY1N0YXRlID0gU1lOQ19TVEFURS5ORVc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHN5bmMgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIENvdW50cyBkb3duIHRvIHplcm87IG9uY2UgaXQgcmVhY2hlcyB6ZXJvLCBhbGwgc3luY1xuICogcmVxdWVzdHMgaGF2ZSBiZWVuIGNvbXBsZXRlZC5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuU3luY2FibGUucHJvdG90eXBlLl9zeW5jQ291bnRlciA9IDA7XG5cbi8qKlxuICogUHJlZml4IHRvIHVzZSB3aGVuIHRyaWdnZXJpbmcgZXZlbnRzXG4gKiBAcHJpdmF0ZVxuICogQHN0YXRpY1xuICovXG5TeW5jYWJsZS5ldmVudFByZWZpeCA9ICcnO1xuXG5TeW5jYWJsZS5lbmFibGVPcHNJZk5ldyA9IGZhbHNlO1xuXG4vKipcbiAqIElzIHRoZSBvYmplY3QgbG9hZGluZyBmcm9tIHRoZSBzZXJ2ZXI/XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW5jYWJsZS5wcm90b3R5cGUsICdpc0xvYWRpbmcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnN5bmNTdGF0ZSA9PT0gU1lOQ19TVEFURS5MT0FESU5HO1xuICB9LFxufSk7XG5cbi8qKlxuICogQXJyYXkgb2YgY2xhc3NlcyB0aGF0IGFyZSBzdWJjbGFzc2VzIG9mIFN5bmNhYmxlLlxuICpcbiAqIFVzZWQgYnkgRmFjdG9yeSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cblN5bmNhYmxlLnN1YmNsYXNzZXMgPSBbXTtcblxuU3luY2FibGUuX3N1cHBvcnRlZEV2ZW50cyA9IFtdLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuU3luY2FibGUuaW5PYmplY3RJZ25vcmUgPSBSb290LmluT2JqZWN0SWdub3JlO1xubW9kdWxlLmV4cG9ydHMgPSBTeW5jYWJsZTtcbiJdfQ==
