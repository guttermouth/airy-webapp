'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Membership class represents an Membership of a user within a channel.
 *
 * Identities are created by the System, never directly by apps.
 *
 * @class layer.Membership
 * @experimental This feature is incomplete, and available as Preview only.
 * @extends layer.Syncable
 */

var Syncable = require('./syncable');
var Root = require('../root');
var Constants = require('../const');
var LayerError = require('../layer-error');

var Membership = function (_Syncable) {
  _inherits(Membership, _Syncable);

  function Membership() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Membership);

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) {
      options.id = options.fromServer.id;
    } else if (options.id && !options.userId) {
      options.userId = options.id.replace(/^.*\//, '');
    }

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Membership).call(this, options));

    _this.isInitializing = true;

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Membership
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    if (!_this.url && _this.id) {
      _this.url = _this.getClient().url + '/' + _this.id.substring(9);
    } else if (!_this.url) {
      _this.url = '';
    }
    _this.getClient()._addMembership(_this);

    _this.isInitializing = false;
    return _this;
  }

  _createClass(Membership, [{
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeMembership(this);
      _get(Object.getPrototypeOf(Membership.prototype), 'destroy', this).call(this);
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Membership.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Membership.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} membership - Server representation of the membership
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(membership) {
      var _this2 = this;

      var client = this.getClient();

      // Disable events if creating a new Membership
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;

      this._setSynced();

      this.userId = membership.identity ? membership.identity.user_id || '' : client.user.userId;
      this.channelId = membership.channel.id;

      // this.role = client._createObject(membership.role);

      this.identity = membership.identity ? client._createObject(membership.identity) : client.user;
      this.identity.on('identities:change', function (evt) {
        _this2.trigger('members:change', {
          property: 'identity'
        });
      }, this);

      if (!this.url && this.id) {
        this.url = this.getClient().url + this.id.substring(8);
      }

      this._disableEvents = false;
    }

    /**
     * Update the property; trigger a change event, IF the value has changed.
     *
     * @method _updateValue
     * @private
     * @param {string} key - Property name
     * @param {Mixed} value - Property value
     */

  }, {
    key: '_updateValue',
    value: function _updateValue(key, value) {
      if (value === null || value === undefined) value = '';
      if (this[key] !== value) {
        if (!this.isInitializing) {
          this._triggerAsync('members:change', {
            property: key,
            oldValue: this[key],
            newValue: value
          });
        }
        this[key] = value;
      }
    }
  }, {
    key: '__getUserId',
    value: function __getUserId() {
      return this.identity ? this.identity.userId : '';
    }
  }, {
    key: '__updateIdentity',
    value: function __updateIdentity(newIdentity, oldIdentity) {
      if (oldIdentity) oldIdentity.off(null, null, this);
    }

    /**
     * Create a new Membership based on a Server description of the user.
     *
     * @method _createFromServer
     * @static
     * @param {Object} membership - Server Membership Object
     * @param {layer.Client} client
     * @returns {layer.Membership}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(membership, client) {
      return new Membership({
        client: client,
        fromServer: membership,
        _fromDB: membership._fromDB
      });
    }
  }]);

  return Membership;
}(Syncable);

/**
 * User ID that the Membership describes.
 *
 * @type {string}
 */


Membership.prototype.userId = '';

/**
 * Channel ID that the membership describes.
 *
 * @type {string}
 */
Membership.prototype.channelId = '';

/**
 * The user's role within the channel
 *
 * @ignore
 * @type {layer.Role}
 */
Membership.prototype.role = null;

/**
 * Identity associated with the membership
 *
 * @type {layer.Identity}
 */
Membership.prototype.identity = '';

Membership.inObjectIgnore = Root.inObjectIgnore;

Membership.bubbleEventParent = 'getClient';

Membership._supportedEvents = ['members:change', 'members:loaded', 'members:loaded-error'].concat(Syncable._supportedEvents);

Membership.eventPrefix = 'members';
Membership.prefixUUID = '/members/';

Root.initClass.apply(Membership, [Membership, 'Membership']);
Syncable.subclasses.push(Membership);

module.exports = Membership;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvbWVtYmVyc2hpcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztBQVVBLElBQU0sV0FBVyxRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFNLE9BQU8sUUFBUSxTQUFSLENBQWI7QUFDQSxJQUFNLFlBQVksUUFBUSxVQUFSLENBQWxCO0FBQ0EsSUFBTSxhQUFhLFFBQVEsZ0JBQVIsQ0FBbkI7O0lBRU0sVTs7O0FBQ0osd0JBQTBCO0FBQUEsUUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQUE7O0FBQ3hCO0FBQ0EsUUFBSSxRQUFRLFVBQVosRUFBd0I7QUFDdEIsY0FBUSxFQUFSLEdBQWEsUUFBUSxVQUFSLENBQW1CLEVBQWhDO0FBQ0QsS0FGRCxNQUVPLElBQUksUUFBUSxFQUFSLElBQWMsQ0FBQyxRQUFRLE1BQTNCLEVBQW1DO0FBQ3hDLGNBQVEsTUFBUixHQUFpQixRQUFRLEVBQVIsQ0FBVyxPQUFYLENBQW1CLE9BQW5CLEVBQTRCLEVBQTVCLENBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLFFBQVEsTUFBWixFQUFvQixRQUFRLFFBQVIsR0FBbUIsUUFBUSxNQUFSLENBQWUsS0FBbEM7QUFDcEIsUUFBSSxDQUFDLFFBQVEsUUFBYixFQUF1QixNQUFNLElBQUksS0FBSixDQUFVLFdBQVcsVUFBWCxDQUFzQixhQUFoQyxDQUFOOztBQVZDLDhGQVlsQixPQVprQjs7QUFjeEIsVUFBSyxjQUFMLEdBQXNCLElBQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUksV0FBVyxRQUFRLFVBQXZCLEVBQW1DO0FBQ2pDLFlBQUssbUJBQUwsQ0FBeUIsUUFBUSxVQUFqQztBQUNEOztBQUVELFFBQUksQ0FBQyxNQUFLLEdBQU4sSUFBYSxNQUFLLEVBQXRCLEVBQTBCO0FBQ3hCLFlBQUssR0FBTCxHQUFjLE1BQUssU0FBTCxHQUFpQixHQUEvQixTQUFzQyxNQUFLLEVBQUwsQ0FBUSxTQUFSLENBQWtC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RUFBakM7O0FBRUE7Ozs7OztBQU1BLFdBQVcsU0FBWCxDQUFxQixJQUFyQixHQUE0QixJQUE1Qjs7QUFFQTs7Ozs7QUFLQSxXQUFXLFNBQVgsQ0FBcUIsUUFBckIsR0FBZ0MsRUFBaEM7O0FBRUEsV0FBVyxjQUFYLEdBQTRCLEtBQUssY0FBakM7O0FBRUEsV0FBVyxpQkFBWCxHQUErQixXQUEvQjs7QUFFQSxXQUFXLGdCQUFYLEdBQThCLENBQzVCLGdCQUQ0QixFQUU1QixnQkFGNEIsRUFHNUIsc0JBSDRCLEVBSTVCLE1BSjRCLENBSXJCLFNBQVMsZ0JBSlksQ0FBOUI7O0FBTUEsV0FBVyxXQUFYLEdBQXlCLFNBQXpCO0FBQ0EsV0FBVyxVQUFYLEdBQXdCLFdBQXhCOztBQUVBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsVUFBckIsRUFBaUMsQ0FBQyxVQUFELEVBQWEsWUFBYixDQUFqQztBQUNBLFNBQVMsVUFBVCxDQUFvQixJQUFwQixDQUF5QixVQUF6Qjs7QUFFQSxPQUFPLE9BQVAsR0FBaUIsVUFBakIiLCJmaWxlIjoibWVtYmVyc2hpcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIE1lbWJlcnNoaXAgY2xhc3MgcmVwcmVzZW50cyBhbiBNZW1iZXJzaGlwIG9mIGEgdXNlciB3aXRoaW4gYSBjaGFubmVsLlxuICpcbiAqIElkZW50aXRpZXMgYXJlIGNyZWF0ZWQgYnkgdGhlIFN5c3RlbSwgbmV2ZXIgZGlyZWN0bHkgYnkgYXBwcy5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuTWVtYmVyc2hpcFxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGZlYXR1cmUgaXMgaW5jb21wbGV0ZSwgYW5kIGF2YWlsYWJsZSBhcyBQcmV2aWV3IG9ubHkuXG4gKiBAZXh0ZW5kcyBsYXllci5TeW5jYWJsZVxuICovXG5cbmNvbnN0IFN5bmNhYmxlID0gcmVxdWlyZSgnLi9zeW5jYWJsZScpO1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4uL3Jvb3QnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcblxuY2xhc3MgTWVtYmVyc2hpcCBleHRlbmRzIFN5bmNhYmxlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBJRCBmcm9tIGhhbmRsZSBmcm9tU2VydmVyIHBhcmFtZXRlciBpcyB1c2VkIGJ5IHRoZSBSb290LmNvbnN0cnVjdG9yXG4gICAgaWYgKG9wdGlvbnMuZnJvbVNlcnZlcikge1xuICAgICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuZnJvbVNlcnZlci5pZDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaWQgJiYgIW9wdGlvbnMudXNlcklkKSB7XG4gICAgICBvcHRpb25zLnVzZXJJZCA9IG9wdGlvbnMuaWQucmVwbGFjZSgvXi4qXFwvLywgJycpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGNsaWVudElkIHByb3BlcnR5XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50KSBvcHRpb25zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnQuYXBwSWQ7XG4gICAgaWYgKCFvcHRpb25zLmNsaWVudElkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmNsaWVudE1pc3NpbmcpO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgIC8vIElmIHRoZSBvcHRpb25zIGNvbnRhaW5zIGEgZnVsbCBzZXJ2ZXIgZGVmaW5pdGlvbiBvZiB0aGUgb2JqZWN0LFxuICAgIC8vIGNvcHkgaXQgaW4gd2l0aCBfcG9wdWxhdGVGcm9tU2VydmVyOyB0aGlzIHdpbGwgYWRkIHRoZSBNZW1iZXJzaGlwXG4gICAgLy8gdG8gdGhlIENsaWVudCBhcyB3ZWxsLlxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZnJvbVNlcnZlcikge1xuICAgICAgdGhpcy5fcG9wdWxhdGVGcm9tU2VydmVyKG9wdGlvbnMuZnJvbVNlcnZlcik7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVybCAmJiB0aGlzLmlkKSB7XG4gICAgICB0aGlzLnVybCA9IGAke3RoaXMuZ2V0Q2xpZW50KCkudXJsfS8ke3RoaXMuaWQuc3Vic3RyaW5nKDkpfWA7XG4gICAgfSBlbHNlIGlmICghdGhpcy51cmwpIHtcbiAgICAgIHRoaXMudXJsID0gJyc7XG4gICAgfVxuICAgIHRoaXMuZ2V0Q2xpZW50KCkuX2FkZE1lbWJlcnNoaXAodGhpcyk7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgaWYgKGNsaWVudCkgY2xpZW50Ll9yZW1vdmVNZW1iZXJzaGlwKHRoaXMpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIF90cmlnZ2VyQXN5bmMoZXZ0TmFtZSwgYXJncykge1xuICAgIHRoaXMuX2NsZWFyT2JqZWN0KCk7XG4gICAgc3VwZXIuX3RyaWdnZXJBc3luYyhldnROYW1lLCBhcmdzKTtcbiAgfVxuXG4gIHRyaWdnZXIoZXZ0TmFtZSwgYXJncykge1xuICAgIHRoaXMuX2NsZWFyT2JqZWN0KCk7XG4gICAgc3VwZXIudHJpZ2dlcihldnROYW1lLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgdGhpcyBpbnN0YW5jZSB1c2luZyBzZXJ2ZXItZGF0YS5cbiAgICpcbiAgICogU2lkZSBlZmZlY3RzIGFkZCB0aGlzIHRvIHRoZSBDbGllbnQuXG4gICAqXG4gICAqIEBtZXRob2QgX3BvcHVsYXRlRnJvbVNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1lbWJlcnNoaXAgLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lbWJlcnNoaXBcbiAgICovXG4gIF9wb3B1bGF0ZUZyb21TZXJ2ZXIobWVtYmVyc2hpcCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG5cbiAgICAvLyBEaXNhYmxlIGV2ZW50cyBpZiBjcmVhdGluZyBhIG5ldyBNZW1iZXJzaGlwXG4gICAgLy8gV2Ugc3RpbGwgd2FudCBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnRzIGZvciBhbnl0aGluZyB0aGF0IERPRVMgY2hhbmdlXG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9ICh0aGlzLnN5bmNTdGF0ZSA9PT0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXKTtcblxuICAgIHRoaXMuX3NldFN5bmNlZCgpO1xuXG4gICAgdGhpcy51c2VySWQgPSBtZW1iZXJzaGlwLmlkZW50aXR5ID8gbWVtYmVyc2hpcC5pZGVudGl0eS51c2VyX2lkIHx8ICcnIDogY2xpZW50LnVzZXIudXNlcklkO1xuICAgIHRoaXMuY2hhbm5lbElkID0gbWVtYmVyc2hpcC5jaGFubmVsLmlkO1xuXG4gICAgLy8gdGhpcy5yb2xlID0gY2xpZW50Ll9jcmVhdGVPYmplY3QobWVtYmVyc2hpcC5yb2xlKTtcblxuICAgIHRoaXMuaWRlbnRpdHkgPSBtZW1iZXJzaGlwLmlkZW50aXR5ID8gY2xpZW50Ll9jcmVhdGVPYmplY3QobWVtYmVyc2hpcC5pZGVudGl0eSkgOiBjbGllbnQudXNlcjtcbiAgICB0aGlzLmlkZW50aXR5Lm9uKCdpZGVudGl0aWVzOmNoYW5nZScsIChldnQpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcignbWVtYmVyczpjaGFuZ2UnLCB7XG4gICAgICAgIHByb3BlcnR5OiAnaWRlbnRpdHknLFxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoIXRoaXMudXJsICYmIHRoaXMuaWQpIHtcbiAgICAgIHRoaXMudXJsID0gdGhpcy5nZXRDbGllbnQoKS51cmwgKyB0aGlzLmlkLnN1YnN0cmluZyg4KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXNhYmxlRXZlbnRzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwcm9wZXJ0eTsgdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgSUYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAbWV0aG9kIF91cGRhdGVWYWx1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBfdXBkYXRlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9ICcnO1xuICAgIGlmICh0aGlzW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZW1iZXJzOmNoYW5nZScsIHtcbiAgICAgICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgICAgIG9sZFZhbHVlOiB0aGlzW2tleV0sXG4gICAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIF9fZ2V0VXNlcklkKCkge1xuICAgIHJldHVybiB0aGlzLmlkZW50aXR5ID8gdGhpcy5pZGVudGl0eS51c2VySWQgOiAnJztcbiAgfVxuXG4gIF9fdXBkYXRlSWRlbnRpdHkobmV3SWRlbnRpdHksIG9sZElkZW50aXR5KSB7XG4gICAgaWYgKG9sZElkZW50aXR5KSBvbGRJZGVudGl0eS5vZmYobnVsbCwgbnVsbCwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IE1lbWJlcnNoaXAgYmFzZWQgb24gYSBTZXJ2ZXIgZGVzY3JpcHRpb24gb2YgdGhlIHVzZXIuXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZUZyb21TZXJ2ZXJcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWVtYmVyc2hpcCAtIFNlcnZlciBNZW1iZXJzaGlwIE9iamVjdFxuICAgKiBAcGFyYW0ge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqIEByZXR1cm5zIHtsYXllci5NZW1iZXJzaGlwfVxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVGcm9tU2VydmVyKG1lbWJlcnNoaXAsIGNsaWVudCkge1xuICAgIHJldHVybiBuZXcgTWVtYmVyc2hpcCh7XG4gICAgICBjbGllbnQsXG4gICAgICBmcm9tU2VydmVyOiBtZW1iZXJzaGlwLFxuICAgICAgX2Zyb21EQjogbWVtYmVyc2hpcC5fZnJvbURCLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVXNlciBJRCB0aGF0IHRoZSBNZW1iZXJzaGlwIGRlc2NyaWJlcy5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZW1iZXJzaGlwLnByb3RvdHlwZS51c2VySWQgPSAnJztcblxuLyoqXG4gKiBDaGFubmVsIElEIHRoYXQgdGhlIG1lbWJlcnNoaXAgZGVzY3JpYmVzLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk1lbWJlcnNoaXAucHJvdG90eXBlLmNoYW5uZWxJZCA9ICcnO1xuXG4vKipcbiAqIFRoZSB1c2VyJ3Mgcm9sZSB3aXRoaW4gdGhlIGNoYW5uZWxcbiAqXG4gKiBAaWdub3JlXG4gKiBAdHlwZSB7bGF5ZXIuUm9sZX1cbiAqL1xuTWVtYmVyc2hpcC5wcm90b3R5cGUucm9sZSA9IG51bGw7XG5cbi8qKlxuICogSWRlbnRpdHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZW1iZXJzaGlwXG4gKlxuICogQHR5cGUge2xheWVyLklkZW50aXR5fVxuICovXG5NZW1iZXJzaGlwLnByb3RvdHlwZS5pZGVudGl0eSA9ICcnO1xuXG5NZW1iZXJzaGlwLmluT2JqZWN0SWdub3JlID0gUm9vdC5pbk9iamVjdElnbm9yZTtcblxuTWVtYmVyc2hpcC5idWJibGVFdmVudFBhcmVudCA9ICdnZXRDbGllbnQnO1xuXG5NZW1iZXJzaGlwLl9zdXBwb3J0ZWRFdmVudHMgPSBbXG4gICdtZW1iZXJzOmNoYW5nZScsXG4gICdtZW1iZXJzOmxvYWRlZCcsXG4gICdtZW1iZXJzOmxvYWRlZC1lcnJvcicsXG5dLmNvbmNhdChTeW5jYWJsZS5fc3VwcG9ydGVkRXZlbnRzKTtcblxuTWVtYmVyc2hpcC5ldmVudFByZWZpeCA9ICdtZW1iZXJzJztcbk1lbWJlcnNoaXAucHJlZml4VVVJRCA9ICcvbWVtYmVycy8nO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShNZW1iZXJzaGlwLCBbTWVtYmVyc2hpcCwgJ01lbWJlcnNoaXAnXSk7XG5TeW5jYWJsZS5zdWJjbGFzc2VzLnB1c2goTWVtYmVyc2hpcCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyc2hpcDtcbiJdfQ==
