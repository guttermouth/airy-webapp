'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Message Class represents Messages sent amongst participants
 * of of a Conversation.
 *
 * The simplest way to create and send a message is:
 *
 *      var m = conversation.createMessage('Hello there').send();
 *      var m = channel.createMessage('Hello there').send();
 *
 * For conversations that involve notifications (primarily for Android and IOS), the more common pattern is:
 *
 *      var m = conversation.createMessage('Hello there').send({text: "Message from Fred: Hello there"});
 *
 * Channels do not at this time support notifications.
 *
 * Typically, rendering would be done as follows:
 *
 *      // Create a layer.Query that loads Messages for the
 *      // specified Conversation.
 *      var query = client.createQuery({
 *        model: Query.Message,
 *        predicate: 'conversation = "' + conversation.id + '"'
 *      });
 *
 *      // Any time the Query's data changes the 'change'
 *      // event will fire.
 *      query.on('change', function(layerEvt) {
 *        renderNewMessages(query.data);
 *      });
 *
 *      // This will call will cause the above event handler to receive
 *      // a change event, and will update query.data.
 *      conversation.createMessage('Hello there').send();
 *
 * The above code will trigger the following events:
 *
 *  * Message Instance fires
 *    * messages:sending: An event that lets you modify the message prior to sending
 *    * messages:sent: The message was received by the server
 *  * Query Instance fires
 *    * change: The query has received a new Message
 *    * change:add: Same as the change event but does not receive other types of change events
 *
 * When creating a Message there are a number of ways to structure it.
 * All of these are valid and create the same exact Message:
 *
 *      // Full API style:
 *      var m = conversation.createMessage({
 *          parts: [new layer.MessagePart({
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          })]
 *      });
 *
 *      // Option 1: Pass in an Object instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: {
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }
 *      });
 *
 *      // Option 2: Pass in an array of Objects instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: [{
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }]
 *      });
 *
 *      // Option 3: Pass in a string (automatically assumes mimeType is text/plain)
 *      // instead of an array of objects.
 *      var m = conversation.createMessage({
 *          parts: 'Hello'
 *      });
 *
 *      // Option 4: Pass in an array of strings (automatically assumes mimeType is text/plain)
 *      var m = conversation.createMessage({
 *          parts: ['Hello']
 *      });
 *
 *      // Option 5: Pass in just a string and nothing else
 *      var m = conversation.createMessage('Hello');
 *
 *      // Option 6: Use addPart.
 *      var m = converseation.createMessage();
 *      m.addPart({body: "hello", mimeType: "text/plain"});
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Message.id: this property is worth being familiar with; it identifies the
 *   Message and can be used in `client.getMessage(id)` to retrieve it
 *   at any time.
 * * layer.Message.internalId: This property makes for a handy unique ID for use in dom nodes.
 *   It is gaurenteed not to change during this session.
 * * layer.Message.isRead: Indicates if the Message has been read yet; set `m.isRead = true`
 *   to tell the client and server that the message has been read.
 * * layer.Message.parts: An array of layer.MessagePart classes representing the contents of the Message.
 * * layer.Message.sentAt: Date the message was sent
 * * layer.Message.sender `userId`: Conversation participant who sent the Message. You may
 *   need to do a lookup on this id in your own servers to find a
 *   displayable name for it.
 *
 * Methods:
 *
 * * layer.Message.send(): Sends the message to the server and the other participants.
 * * layer.Message.on() and layer.Message.off(); event listeners built on top of the `backbone-events-standalone` npm project
 *
 * Events:
 *
 * * `messages:sent`: The message has been received by the server. Can also subscribe to
 *   this event from the layer.Client which is usually simpler.
 *
 * @class  layer.Message
 * @extends layer.Syncable
 */

var Root = require('../root');
var Syncable = require('./syncable');
var MessagePart = require('./message-part');
var LayerError = require('../layer-error');
var Constants = require('../const');
var Util = require('../client-utils');
var Identity = require('./identity');

var Message = function (_Syncable) {
  _inherits(Message, _Syncable);

  /**
   * See layer.Conversation.createMessage()
   *
   * @method constructor
   * @return {layer.Message}
   */
  function Message() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Message);

    // Unless this is a server representation, this is a developer's shorthand;
    // fill in the missing properties around isRead/isUnread before initializing.
    if (!options.fromServer) {
      if ('isUnread' in options) {
        options.isRead = !options.isUnread && !options.is_unread;
        delete options.isUnread;
      } else {
        options.isRead = true;
      }
    } else {
      options.id = options.fromServer.id;
    }

    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error(LayerError.dictionary.clientMissing);

    // Insure __adjustParts is set AFTER clientId is set.
    var parts = options.parts;
    options.parts = null;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Message).call(this, options));

    _this.parts = parts;

    var client = _this.getClient();
    _this.isInitializing = true;
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    } else {
      if (client) _this.sender = client.user;
      _this.sentAt = new Date();
    }

    if (!_this.parts) _this.parts = [];
    return _this;
  }

  /**
   * Turn input into valid layer.MessageParts.
   *
   * This method is automatically called any time the parts
   * property is set (including during intialization).  This
   * is where we convert strings into MessageParts, and instances
   * into arrays.
   *
   * @method __adjustParts
   * @private
   * @param  {Mixed} parts -- Could be a string, array, object or MessagePart instance
   * @return {layer.MessagePart[]}
   */


  _createClass(Message, [{
    key: '__adjustParts',
    value: function __adjustParts(parts) {
      var _this2 = this;

      var adjustedParts = void 0;
      if (typeof parts === 'string') {
        adjustedParts = [new MessagePart({
          body: parts,
          mimeType: 'text/plain',
          clientId: this.clientId
        })];
      } else if (Array.isArray(parts)) {
        adjustedParts = parts.map(function (part) {
          var result = void 0;
          if (part instanceof MessagePart) {
            result = part;
          } else {
            result = new MessagePart(part);
          }
          result.clientId = _this2.clientId;
          return result;
        });
      } else if (parts && (typeof parts === 'undefined' ? 'undefined' : _typeof(parts)) === 'object') {
        parts.clientId = this.clientId;
        adjustedParts = [new MessagePart(parts)];
      }
      this._setupPartIds(adjustedParts);
      if (adjustedParts) {
        adjustedParts.forEach(function (part) {
          part.off('messageparts:change', _this2._onMessagePartChange, _this2); // if we already subscribed, don't create a redundant subscription
          part.on('messageparts:change', _this2._onMessagePartChange, _this2);
        });
      }
      return adjustedParts;
    }

    /**
     * Add a layer.MessagePart to this Message.
     *
     * Should only be called on an unsent Message.
     *
     * ```
     * message.addPart({mimeType: 'text/plain', body: 'Frodo really is a Dodo'});
     *
     * // OR
     * message.addPart(new layer.MessagePart({mimeType: 'text/plain', body: 'Frodo really is a Dodo'}));
     * ```
     *
     * @method addPart
     * @param  {layer.MessagePart/Object} part - A layer.MessagePart instance or a `{mimeType: 'text/plain', body: 'Hello'}` formatted Object.
     * @returns {layer.Message} this
     */

  }, {
    key: 'addPart',
    value: function addPart(part) {
      if (part) {
        part.clientId = this.clientId;
        if (part instanceof MessagePart) {
          this.parts.push(part);
        } else if ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object') {
          this.parts.push(new MessagePart(part));
        }
        var index = this.parts.length - 1;
        var thePart = this.parts[index];

        thePart.off('messageparts:change', this._onMessagePartChange, this); // if we already subscribed, don't create a redundant subscription
        thePart.on('messageparts:change', this._onMessagePartChange, this);
        if (!part.id) part.id = this.id + '/parts/' + index;
      }
      return this;
    }

    /**
     * Any time a Part changes, the Message has changed; trigger the `messages:change` event.
     *
     * Currently, this only looks at changes to body or mimeType, and does not handle changes to url/rich content.
     *
     * @method _onMessagePartChange
     * @private
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_onMessagePartChange',
    value: function _onMessagePartChange(evt) {
      var _this3 = this;

      evt.changes.forEach(function (change) {
        _this3._triggerAsync('messages:change', {
          property: 'parts.' + change.property,
          oldValue: change.oldValue,
          newValue: change.newValue,
          part: evt.target
        });
      });
    }

    /**
     * Your unsent Message will show up in Query results and be rendered in Message Lists.
     *
     * This method is only needed for Messages that should show up in a Message List Widget that
     * is driven by Query data, but where the layer.Message.send method has not yet been called.
     *
     * Once you have called `presend` your message should show up in your Message List.  However,
     * typically you want to be able to edit and rerender that Message. After making changes to the Message,
     * you can trigger change events:
     *
     * ```
     * var message = conversation.createMessage({parts: [{mimeType: 'custom/card', body: null}]});
     * message.presend();
     *
     * message.parts[0].body = 'Frodo is a Dodo';
     * message.trigger('messages:change');
     * ```
     *
     * Note that if using Layer UI for Web, the `messages:change` event will trigger an `onRerender` call,
     * not an `onRender` call, so the capacity to handle editing of messages will require the ability to render
     * all possible edits within `onRerender`.
     *
     * It is assumed that at some point either `send()` or `destroy()` will be called on this message
     * to complete or cancel this process.
     *
     * @method presend
     */

  }, {
    key: 'presend',
    value: function presend() {
      var _this4 = this;

      var client = this.getClient();
      if (!client) {
        throw new Error(LayerError.dictionary.clientMissing);
      }

      var conversation = this.getConversation(false);

      if (!conversation) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      if (this.syncState !== Constants.SYNC_STATE.NEW) {
        throw new Error(LayerError.dictionary.alreadySent);
      }
      conversation._setupMessage(this);

      // Make sure all data is in the right format for being rendered
      this._readAllBlobs(function () {
        client._addMessage(_this4);
      });
    }

    /**
     * Send the message to all participants of the Conversation.
     *
     * Message must have parts and a valid conversation to send successfully.
     *
     * The send method takes a `notification` object. In normal use, it provides the same notification to ALL
     * recipients, but you can customize notifications on a per recipient basis, as well as embed actions into the notification.
     * For the Full API, see https://developer.layer.com/docs/platform/messages#notification-customization.
     *
     * For the Full API, see [Server Docs](https://developer.layer.com/docs/platform/messages#notification-customization).
     *
     * ```
     * message.send({
     *    title: "New Hobbit Message",
     *    text: "Frodo-the-Dodo: Hello Sam, what say we waltz into Mordor like we own the place?",
     *    sound: "whinyhobbit.aiff"
     * });
     * ```
     *
     * @method send
     * @param {Object} [notification] - Parameters for controling how the phones manage notifications of the new Message.
     *                          See IOS and Android docs for details.
     * @param {string} [notification.title] - Title to show on lock screen and notification bar
     * @param {string} [notification.text] - Text of your notification
     * @param {string} [notification.sound] - Name of an audio file or other sound-related hint
     * @return {layer.Message} this
     */

  }, {
    key: 'send',
    value: function send(notification) {
      var _this5 = this;

      var client = this.getClient();
      if (!client) {
        throw new Error(LayerError.dictionary.clientMissing);
      }

      var conversation = this.getConversation(true);

      if (!conversation) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      if (this.syncState !== Constants.SYNC_STATE.NEW) {
        throw new Error(LayerError.dictionary.alreadySent);
      }

      if (conversation.isLoading) {
        conversation.once(conversation.constructor.eventPrefix + ':loaded', function () {
          return _this5.send(notification);
        });
        conversation._setupMessage(this);
        return this;
      }

      if (!this.parts || !this.parts.length) {
        throw new Error(LayerError.dictionary.partsMissing);
      }

      this._setSyncing();

      // Make sure that the Conversation has been created on the server
      // and update the lastMessage property
      conversation.send(this);

      // If we are sending any File/Blob objects, and their Mime Types match our test,
      // wait until the body is updated to be a string rather than File before calling _addMessage
      // which will add it to the Query Results and pass this on to a renderer that expects "text/plain" to be a string
      // rather than a blob.
      this._readAllBlobs(function () {
        // Calling this will add this to any listening Queries... so position needs to have been set first;
        // handled in conversation.send(this)
        client._addMessage(_this5);

        // allow for modification of message before sending
        _this5.trigger('messages:sending');

        var data = {
          parts: new Array(_this5.parts.length),
          id: _this5.id
        };
        if (notification && _this5.conversationId) data.notification = notification;

        _this5._preparePartsForSending(data);
      });
      return this;
    }

    /**
     * Any MessagePart that contains a textual blob should contain a string before we send.
     *
     * If a MessagePart with a Blob or File as its body were to be added to the Client,
     * The Query would receive this, deliver it to apps and the app would crash.
     * Most rendering code expecting text/plain would expect a string not a File.
     *
     * When this user is sending a file, and that file is textual, make sure
     * its actual text delivered to the UI.
     *
     * @method _readAllBlobs
     * @private
     */

  }, {
    key: '_readAllBlobs',
    value: function _readAllBlobs(callback) {
      var count = 0;
      var parts = this.parts.filter(function (part) {
        return Util.isBlob(part.body) && part.isTextualMimeType();
      });
      parts.forEach(function (part) {
        Util.fetchTextFromFile(part.body, function (text) {
          part.body = text;
          count++;
          if (count === parts.length) callback();
        });
      });
      if (!parts.length) callback();
    }

    /**
     * Insures that each part is ready to send before actually sending the Message.
     *
     * @method _preparePartsForSending
     * @private
     * @param  {Object} structure to be sent to the server
     */

  }, {
    key: '_preparePartsForSending',
    value: function _preparePartsForSending(data) {
      var _this6 = this;

      var client = this.getClient();
      var count = 0;
      this.parts.forEach(function (part, index) {
        part.once('parts:send', function (evt) {
          data.parts[index] = {
            mime_type: evt.mime_type
          };
          if (evt.content) data.parts[index].content = evt.content;
          if (evt.body) data.parts[index].body = evt.body;
          if (evt.encoding) data.parts[index].encoding = evt.encoding;

          count++;
          if (count === _this6.parts.length) {
            _this6._send(data);
          }
        }, _this6);
        part._send(client);
      });
    }

    /**
     * Handle the actual sending.
     *
     * layer.Message.send has some potentially asynchronous
     * preprocessing to do before sending (Rich Content); actual sending
     * is done here.
     *
     * @method _send
     * @private
     */

  }, {
    key: '_send',
    value: function _send(data) {
      var _this7 = this;

      var client = this.getClient();
      var conversation = this.getConversation(false);

      this.getClient()._triggerAsync('state-change', {
        started: true,
        type: 'send_' + Util.typeFromID(this.id),
        telemetryId: 'send_' + Util.typeFromID(this.id) + '_time',
        id: this.id
      });
      this.sentAt = new Date();
      client.sendSocketRequest({
        method: 'POST',
        body: {
          method: 'Message.create',
          object_id: conversation.id,
          data: data
        },
        sync: {
          depends: [this.conversationId, this.id],
          target: this.id
        }
      }, function (success, socketData) {
        return _this7._sendResult(success, socketData);
      });
    }
  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      data.object_id = this.conversationId;
      return data;
    }

    /**
      * layer.Message.send() Success Callback.
      *
      * If successfully sending the message; triggers a 'sent' event,
      * and updates the message.id/url
      *
      * @method _sendResult
      * @private
      * @param {Object} messageData - Server description of the message
      */

  }, {
    key: '_sendResult',
    value: function _sendResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      this.getClient()._triggerAsync('state-change', {
        ended: true,
        type: 'send_' + Util.typeFromID(this.id),
        telemetryId: 'send_' + Util.typeFromID(this.id) + '_time',
        result: success,
        id: this.id
      });
      if (this.isDestroyed) return;

      if (success) {
        this._populateFromServer(data);
        this._triggerAsync('messages:sent');
        this._triggerAsync('messages:change', {
          property: 'syncState',
          oldValue: Constants.SYNC_STATE.SAVING,
          newValue: Constants.SYNC_STATE.SYNCED
        });
      } else {
        this.trigger('messages:sent-error', { error: data });
        this.destroy();
      }
      this._setSynced();
    }

    /* NOT FOR JSDUCK
     * Standard `on()` provided by layer.Root.
     *
     * Adds some special handling of 'messages:loaded' so that calls such as
     *
     *      var m = client.getMessage('layer:///messages/123', true)
     *      .on('messages:loaded', function() {
     *          myrerender(m);
     *      });
     *      myrender(m); // render a placeholder for m until the details of m have loaded
     *
     * can fire their callback regardless of whether the client loads or has
     * already loaded the Message.
     *
     * @method on
     * @param  {string} eventName
     * @param  {Function} eventHandler
     * @param  {Object} context
     * @return {layer.Message} this
     */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var hasLoadedEvt = name === 'messages:loaded' || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name['messages:loaded'];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === 'messages:loaded' ? callback : name['messages:loaded'];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Message.prototype), 'on', this).call(this, name, callback, context);
      return this;
    }

    /**
     * Remove this Message from the system.
     *
     * This will deregister the Message, remove all events
     * and allow garbage collection.
     *
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeMessage(this);
      this.parts.forEach(function (part) {
        return part.destroy();
      });
      this.__parts = null;

      _get(Object.getPrototypeOf(Message.prototype), 'destroy', this).call(this);
    }

    /**
     * Setup message-part ids for parts that lack that id; for locally created parts.
     *
     * @private
     * @method
     * @param {layer.MessagePart[]} parts
     */

  }, {
    key: '_setupPartIds',
    value: function _setupPartIds(parts) {
      var _this8 = this;

      // Assign IDs to preexisting Parts so that we can call getPartById()
      if (parts) {
        parts.forEach(function (part, index) {
          if (!part.id) part.id = _this8.id + '/parts/' + index;
        });
      }
    }

    /**
     * Populates this instance with the description from the server.
     *
     * Can be used for creating or for updating the instance.
     *
     * @method _populateFromServer
     * @protected
     * @param  {Object} m - Server description of the message
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(message) {
      var _this9 = this;

      this._inPopulateFromServer = true;
      var client = this.getClient();

      this.id = message.id;
      this.url = message.url;
      var oldPosition = this.position;
      this.position = message.position;
      this._setupPartIds(message.parts);
      this.parts = message.parts.map(function (part) {
        var existingPart = _this9.getPartById(part.id);
        if (existingPart) {
          existingPart._populateFromServer(part);
          return existingPart;
        } else {
          return MessagePart._createFromServer(part);
        }
      });

      this.recipientStatus = message.recipient_status || {};

      this.isRead = 'is_unread' in message ? !message.is_unread : true;

      this.sentAt = new Date(message.sent_at);
      this.receivedAt = message.received_at ? new Date(message.received_at) : undefined;

      var sender = void 0;
      if (message.sender.id) {
        sender = client.getIdentity(message.sender.id);
      }

      // Because there may be no ID, we have to bypass client._createObject and its switch statement.
      if (!sender) {
        sender = Identity._createFromServer(message.sender, client);
      }
      this.sender = sender;

      this._setSynced();

      if (oldPosition && oldPosition !== this.position) {
        this._triggerAsync('messages:change', {
          oldValue: oldPosition,
          newValue: this.position,
          property: 'position'
        });
      }
      this._inPopulateFromServer = false;
    }

    /**
     * Returns the Message's layer.MessagePart with the specified the part ID.
     *
     * ```
     * var part = client.getMessagePart('layer:///messages/6f08acfa-3268-4ae5-83d9-6ca00000000/parts/0');
     * ```
     *
     * @method getPartById
     * @param {string} partId
     * @return {layer.MessagePart}
     */

  }, {
    key: 'getPartById',
    value: function getPartById(partId) {
      var part = this.parts ? this.parts.filter(function (aPart) {
        return aPart.id === partId;
      })[0] : null;
      return part || null;
    }

    /**
     * Accepts json-patch operations for modifying recipientStatus.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      this._inLayerParser = false;
      if (paths[0].indexOf('recipient_status') === 0) {
        this.__updateRecipientStatus(this.recipientStatus, oldValue);
      }
      this._inLayerParser = true;
    }

    /**
     * Returns absolute URL for this resource.
     * Used by sync manager because the url may not be known
     * at the time the sync request is enqueued.
     *
     * @method _getUrl
     * @param {String} url - relative url and query string parameters
     * @return {String} full url
     * @private
     */

  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_setupSyncObject',
    value: function _setupSyncObject(sync) {
      if (sync !== false) {
        sync = _get(Object.getPrototypeOf(Message.prototype), '_setupSyncObject', this).call(this, sync);
        if (!sync.depends) {
          sync.depends = [this.conversationId];
        } else if (sync.depends.indexOf(this.id) === -1) {
          sync.depends.push(this.conversationId);
        }
      }
      return sync;
    }

    /**
     * Get all text parts of the Message.
     *
     * Utility method for extracting all of the text/plain parts
     * and concatenating all of their bodys together into a single string.
     *
     * @method getText
     * @param {string} [joinStr='.  '] If multiple message parts of type text/plain, how do you want them joined together?
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      var joinStr = arguments.length <= 0 || arguments[0] === undefined ? '. ' : arguments[0];

      var textArray = this.parts.filter(function (part) {
        return part.mimeType === 'text/plain';
      }).map(function (part) {
        return part.body;
      });
      textArray = textArray.filter(function (data) {
        return data;
      });
      return textArray.join(joinStr);
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Message instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this object.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Message.prototype), 'toObject', this).call(this);
      }
      return this._toObject;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Identifies whether a Message receiving the specified patch data should be loaded from the server.
     *
     * Applies only to Messages that aren't already loaded; used to indicate if a change event is
     * significant enough to load the Message and trigger change events on that Message.
     *
     * At this time there are no properties that are patched on Messages via websockets
     * that would justify loading the Message from the server so as to notify the app.
     *
     * Only recipient status changes and maybe is_unread changes are sent;
     * neither of which are relevant to an app that isn't rendering that message.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }], [{
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return false;
    }
  }]);

  return Message;
}(Syncable);

/**
 * Client that the Message belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 * @readonly
 */


Message.prototype.clientId = '';

/**
 * Conversation ID or Channel ID that this Message belongs to.
 *
 * @type {string}
 * @readonly
 */
Message.prototype.conversationId = '';

/**
 * Array of layer.MessagePart objects.
 *
 * Use layer.Message.addPart to modify this array.
 *
 * @type {layer.MessagePart[]}
 * @readonly
 */
Message.prototype.parts = null;

/**
 * Time that the message was sent.
 *
 *  Note that a locally created layer.Message will have a `sentAt` value even
 * though its not yet sent; this is so that any rendering code doesn't need
 * to account for `null` values.  Sending the Message may cause a slight change
 * in the `sentAt` value.
 *
 * @type {Date}
 * @readonly
 */
Message.prototype.sentAt = null;

/**
 * Time that the first delivery receipt was sent by your
 * user acknowledging receipt of the message.
 * @type {Date}
 * @readonly
 */
Message.prototype.receivedAt = null;

/**
 * Identity object representing the sender of the Message.
 *
 * Most commonly used properties of Identity are:
 * * displayName: A name for your UI
 * * userId: Name for the user as represented on your system
 * * name: Represents the name of a service if the sender was an automated system.
 *
 *      <span class='sent-by'>
 *        {message.sender.displayName || message.sender.name}
 *      </span>
 *
 * @type {layer.Identity}
 * @readonly
 */
Message.prototype.sender = null;

/**
 * Position of this message within the conversation.
 *
 * NOTES:
 *
 * 1. Deleting a message does not affect position of other Messages.
 * 2. A position is not gaurenteed to be unique (multiple messages sent at the same time could
 * all claim the same position)
 * 3. Each successive message within a conversation should expect a higher position.
 *
 * @type {Number}
 * @readonly
 */
Message.prototype.position = 0;

/**
 * Hint used by layer.Client on whether to trigger a messages:notify event.
 *
 * @type {boolean}
 * @private
 */
Message.prototype._notify = false;

/**
 * This property is here for convenience only; it will always be the opposite of isRead.
 * @type {Boolean}
 * @readonly
 */
Object.defineProperty(Message.prototype, 'isUnread', {
  enumerable: true,
  get: function get() {
    return !this.isRead;
  }
});

Message.prototype._toObject = null;

Message.prototype._inPopulateFromServer = false;

Message.eventPrefix = 'messages';

Message.eventPrefix = 'messages';

Message.prefixUUID = 'layer:///messages/';

Message.inObjectIgnore = Syncable.inObjectIgnore;

Message.bubbleEventParent = 'getClient';

Message.imageTypes = ['image/gif', 'image/png', 'image/jpeg', 'image/jpg'];

Message._supportedEvents = [

/**
 * Message has been loaded from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 *
 * ```
 * var m = client.getMessage('layer:///messages/123', true)
 *    .on('messages:loaded', function() {
 *        myrerender(m);
 *    });
 * myrender(m); // render a placeholder for m until the details of m have loaded
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded',

/**
 * The load method failed to load the message from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded-error',

/**
 * Message deleted from the server.
 *
 * Caused by a call to layer.Message.delete() or a websocket event.
 * @param {layer.LayerEvent} evt
 * @event
 */
'messages:delete',

/**
 * Message is about to be sent.
 *
 * Last chance to modify or validate the message prior to sending.
 *
 *     message.on('messages:sending', function(evt) {
 *        message.addPart({mimeType: 'application/location', body: JSON.stringify(getGPSLocation())});
 *     });
 *
 * Typically, you would listen to this event more broadly using `client.on('messages:sending')`
 * which would trigger before sending ANY Messages.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sending',

/**
 * Message has been received by the server.
 *
 * It does NOT indicate delivery to other users.
 *
 * It does NOT indicate messages sent by other users.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sent',

/**
 * Server failed to receive the Message.
 *
 * Message will be deleted immediately after firing this event.
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.LayerError} evt.error
 */
'messages:sent-error',

/**
 * The recipientStatus property has changed.
 *
 * This happens in response to an update
 * from the server... but is also caused by marking the current user as having read
 * or received the message.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Message, [Message, 'Message']);
Syncable.subclasses.push(Message);
module.exports = Message;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlbHMvbWVzc2FnZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVIQSxJQUFNLE9BQU8sUUFBUSxTQUFSLENBQWI7QUFDQSxJQUFNLFdBQVcsUUFBUSxZQUFSLENBQWpCO0FBQ0EsSUFBTSxjQUFjLFFBQVEsZ0JBQVIsQ0FBcEI7QUFDQSxJQUFNLGFBQWEsUUFBUSxnQkFBUixDQUFuQjtBQUNBLElBQU0sWUFBWSxRQUFRLFVBQVIsQ0FBbEI7QUFDQSxJQUFNLE9BQU8sUUFBUSxpQkFBUixDQUFiO0FBQ0EsSUFBTSxXQUFXLFFBQVEsWUFBUixDQUFqQjs7SUFFTSxPOzs7QUFDSjs7Ozs7O0FBTUEscUJBQTBCO0FBQUEsUUFBZCxPQUFjLHlEQUFKLEVBQUk7O0FBQUE7O0FBQ3hCO0FBQ0E7QUFDQSxRQUFJLENBQUMsUUFBUSxVQUFiLEVBQXlCO0FBQ3ZCLFVBQUksY0FBYyxPQUFsQixFQUEyQjtBQUN6QixnQkFBUSxNQUFSLEdBQWlCLENBQUMsUUFBUSxRQUFULElBQXFCLENBQUMsUUFBUSxTQUEvQztBQUNBLGVBQU8sUUFBUSxRQUFmO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsZ0JBQVEsTUFBUixHQUFpQixJQUFqQjtBQUNEO0FBQ0YsS0FQRCxNQU9PO0FBQ0wsY0FBUSxFQUFSLEdBQWEsUUFBUSxVQUFSLENBQW1CLEVBQWhDO0FBQ0Q7O0FBRUQsUUFBSSxRQUFRLE1BQVosRUFBb0IsUUFBUSxRQUFSLEdBQW1CLFFBQVEsTUFBUixDQUFlLEtBQWxDO0FBQ3BCLFFBQUksQ0FBQyxRQUFRLFFBQWIsRUFBdUIsTUFBTSxJQUFJLEtBQUosQ0FBVSxXQUFXLFVBQVgsQ0FBc0IsYUFBaEMsQ0FB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QUFSLENBQWtCLFNBQWxCLEdBQThCLElBQTlCOztBQUVBLFFBQVEsU0FBUixDQUFrQixxQkFBbEIsR0FBMEMsS0FBMUM7O0FBRUEsUUFBUSxXQUFSLEdBQXNCLFVBQXRCOztBQUVBLFFBQVEsV0FBUixHQUFzQixVQUF0Qjs7QUFFQSxRQUFRLFVBQVIsR0FBcUIsb0JBQXJCOztBQUVBLFFBQVEsY0FBUixHQUF5QixTQUFTLGNBQWxDOztBQUVBLFFBQVEsaUJBQVIsR0FBNEIsV0FBNUI7O0FBRUEsUUFBUSxVQUFSLEdBQXFCLENBQ25CLFdBRG1CLEVBRW5CLFdBRm1CLEVBR25CLFlBSG1CLEVBSW5CLFdBSm1CLENBQXJCOztBQU9BLFFBQVEsZ0JBQVIsR0FBMkI7O0FBRXpCOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLGlCQWxCeUI7O0FBb0J6Qjs7Ozs7OztBQU9BLHVCQTNCeUI7O0FBNkJ6Qjs7Ozs7OztBQU9BLGlCQXBDeUI7O0FBc0N6Qjs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsa0JBckR5Qjs7QUF1RHpCOzs7Ozs7Ozs7O0FBVUEsZUFqRXlCOztBQW1FekI7Ozs7Ozs7OztBQVNBLHFCQTVFeUI7O0FBOEV6Qjs7Ozs7Ozs7O0FBU0EsaUJBdkZ5QixFQTBGekIsTUExRnlCLENBMEZsQixTQUFTLGdCQTFGUyxDQUEzQjs7QUE0RkEsS0FBSyxTQUFMLENBQWUsS0FBZixDQUFxQixPQUFyQixFQUE4QixDQUFDLE9BQUQsRUFBVSxTQUFWLENBQTlCO0FBQ0EsU0FBUyxVQUFULENBQW9CLElBQXBCLENBQXlCLE9BQXpCO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLE9BQWpCIiwiZmlsZSI6Im1lc3NhZ2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBNZXNzYWdlIENsYXNzIHJlcHJlc2VudHMgTWVzc2FnZXMgc2VudCBhbW9uZ3N0IHBhcnRpY2lwYW50c1xuICogb2Ygb2YgYSBDb252ZXJzYXRpb24uXG4gKlxuICogVGhlIHNpbXBsZXN0IHdheSB0byBjcmVhdGUgYW5kIHNlbmQgYSBtZXNzYWdlIGlzOlxuICpcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSgnSGVsbG8gdGhlcmUnKS5zZW5kKCk7XG4gKiAgICAgIHZhciBtID0gY2hhbm5lbC5jcmVhdGVNZXNzYWdlKCdIZWxsbyB0aGVyZScpLnNlbmQoKTtcbiAqXG4gKiBGb3IgY29udmVyc2F0aW9ucyB0aGF0IGludm9sdmUgbm90aWZpY2F0aW9ucyAocHJpbWFyaWx5IGZvciBBbmRyb2lkIGFuZCBJT1MpLCB0aGUgbW9yZSBjb21tb24gcGF0dGVybiBpczpcbiAqXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2UoJ0hlbGxvIHRoZXJlJykuc2VuZCh7dGV4dDogXCJNZXNzYWdlIGZyb20gRnJlZDogSGVsbG8gdGhlcmVcIn0pO1xuICpcbiAqIENoYW5uZWxzIGRvIG5vdCBhdCB0aGlzIHRpbWUgc3VwcG9ydCBub3RpZmljYXRpb25zLlxuICpcbiAqIFR5cGljYWxseSwgcmVuZGVyaW5nIHdvdWxkIGJlIGRvbmUgYXMgZm9sbG93czpcbiAqXG4gKiAgICAgIC8vIENyZWF0ZSBhIGxheWVyLlF1ZXJ5IHRoYXQgbG9hZHMgTWVzc2FnZXMgZm9yIHRoZVxuICogICAgICAvLyBzcGVjaWZpZWQgQ29udmVyc2F0aW9uLlxuICogICAgICB2YXIgcXVlcnkgPSBjbGllbnQuY3JlYXRlUXVlcnkoe1xuICogICAgICAgIG1vZGVsOiBRdWVyeS5NZXNzYWdlLFxuICogICAgICAgIHByZWRpY2F0ZTogJ2NvbnZlcnNhdGlvbiA9IFwiJyArIGNvbnZlcnNhdGlvbi5pZCArICdcIidcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBBbnkgdGltZSB0aGUgUXVlcnkncyBkYXRhIGNoYW5nZXMgdGhlICdjaGFuZ2UnXG4gKiAgICAgIC8vIGV2ZW50IHdpbGwgZmlyZS5cbiAqICAgICAgcXVlcnkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGxheWVyRXZ0KSB7XG4gKiAgICAgICAgcmVuZGVyTmV3TWVzc2FnZXMocXVlcnkuZGF0YSk7XG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgd2lsbCBjYXVzZSB0aGUgYWJvdmUgZXZlbnQgaGFuZGxlciB0byByZWNlaXZlXG4gKiAgICAgIC8vIGEgY2hhbmdlIGV2ZW50LCBhbmQgd2lsbCB1cGRhdGUgcXVlcnkuZGF0YS5cbiAqICAgICAgY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2UoJ0hlbGxvIHRoZXJlJykuc2VuZCgpO1xuICpcbiAqIFRoZSBhYm92ZSBjb2RlIHdpbGwgdHJpZ2dlciB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiAgKiBNZXNzYWdlIEluc3RhbmNlIGZpcmVzXG4gKiAgICAqIG1lc3NhZ2VzOnNlbmRpbmc6IEFuIGV2ZW50IHRoYXQgbGV0cyB5b3UgbW9kaWZ5IHRoZSBtZXNzYWdlIHByaW9yIHRvIHNlbmRpbmdcbiAqICAgICogbWVzc2FnZXM6c2VudDogVGhlIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXJcbiAqICAqIFF1ZXJ5IEluc3RhbmNlIGZpcmVzXG4gKiAgICAqIGNoYW5nZTogVGhlIHF1ZXJ5IGhhcyByZWNlaXZlZCBhIG5ldyBNZXNzYWdlXG4gKiAgICAqIGNoYW5nZTphZGQ6IFNhbWUgYXMgdGhlIGNoYW5nZSBldmVudCBidXQgZG9lcyBub3QgcmVjZWl2ZSBvdGhlciB0eXBlcyBvZiBjaGFuZ2UgZXZlbnRzXG4gKlxuICogV2hlbiBjcmVhdGluZyBhIE1lc3NhZ2UgdGhlcmUgYXJlIGEgbnVtYmVyIG9mIHdheXMgdG8gc3RydWN0dXJlIGl0LlxuICogQWxsIG9mIHRoZXNlIGFyZSB2YWxpZCBhbmQgY3JlYXRlIHRoZSBzYW1lIGV4YWN0IE1lc3NhZ2U6XG4gKlxuICogICAgICAvLyBGdWxsIEFQSSBzdHlsZTpcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogW25ldyBsYXllci5NZXNzYWdlUGFydCh7XG4gKiAgICAgICAgICAgICAgYm9keTogJ0hlbGxvIHRoZXJlJyxcbiAqICAgICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nXG4gKiAgICAgICAgICB9KV1cbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBPcHRpb24gMTogUGFzcyBpbiBhbiBPYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydHNcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czoge1xuICogICAgICAgICAgICAgIGJvZHk6ICdIZWxsbyB0aGVyZScsXG4gKiAgICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJ1xuICogICAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIE9wdGlvbiAyOiBQYXNzIGluIGFuIGFycmF5IG9mIE9iamVjdHMgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydHNcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogW3tcbiAqICAgICAgICAgICAgICBib2R5OiAnSGVsbG8gdGhlcmUnLFxuICogICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbidcbiAqICAgICAgICAgIH1dXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gT3B0aW9uIDM6IFBhc3MgaW4gYSBzdHJpbmcgKGF1dG9tYXRpY2FsbHkgYXNzdW1lcyBtaW1lVHlwZSBpcyB0ZXh0L3BsYWluKVxuICogICAgICAvLyBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2Uoe1xuICogICAgICAgICAgcGFydHM6ICdIZWxsbydcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBPcHRpb24gNDogUGFzcyBpbiBhbiBhcnJheSBvZiBzdHJpbmdzIChhdXRvbWF0aWNhbGx5IGFzc3VtZXMgbWltZVR5cGUgaXMgdGV4dC9wbGFpbilcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogWydIZWxsbyddXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gT3B0aW9uIDU6IFBhc3MgaW4ganVzdCBhIHN0cmluZyBhbmQgbm90aGluZyBlbHNlXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2UoJ0hlbGxvJyk7XG4gKlxuICogICAgICAvLyBPcHRpb24gNjogVXNlIGFkZFBhcnQuXG4gKiAgICAgIHZhciBtID0gY29udmVyc2VhdGlvbi5jcmVhdGVNZXNzYWdlKCk7XG4gKiAgICAgIG0uYWRkUGFydCh7Ym9keTogXCJoZWxsb1wiLCBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCJ9KTtcbiAqXG4gKiBLZXkgbWV0aG9kcywgZXZlbnRzIGFuZCBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIHN0YXJ0ZWQ6XG4gKlxuICogUHJvcGVydGllczpcbiAqXG4gKiAqIGxheWVyLk1lc3NhZ2UuaWQ6IHRoaXMgcHJvcGVydHkgaXMgd29ydGggYmVpbmcgZmFtaWxpYXIgd2l0aDsgaXQgaWRlbnRpZmllcyB0aGVcbiAqICAgTWVzc2FnZSBhbmQgY2FuIGJlIHVzZWQgaW4gYGNsaWVudC5nZXRNZXNzYWdlKGlkKWAgdG8gcmV0cmlldmUgaXRcbiAqICAgYXQgYW55IHRpbWUuXG4gKiAqIGxheWVyLk1lc3NhZ2UuaW50ZXJuYWxJZDogVGhpcyBwcm9wZXJ0eSBtYWtlcyBmb3IgYSBoYW5keSB1bmlxdWUgSUQgZm9yIHVzZSBpbiBkb20gbm9kZXMuXG4gKiAgIEl0IGlzIGdhdXJlbnRlZWQgbm90IHRvIGNoYW5nZSBkdXJpbmcgdGhpcyBzZXNzaW9uLlxuICogKiBsYXllci5NZXNzYWdlLmlzUmVhZDogSW5kaWNhdGVzIGlmIHRoZSBNZXNzYWdlIGhhcyBiZWVuIHJlYWQgeWV0OyBzZXQgYG0uaXNSZWFkID0gdHJ1ZWBcbiAqICAgdG8gdGVsbCB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgdGhhdCB0aGUgbWVzc2FnZSBoYXMgYmVlbiByZWFkLlxuICogKiBsYXllci5NZXNzYWdlLnBhcnRzOiBBbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydCBjbGFzc2VzIHJlcHJlc2VudGluZyB0aGUgY29udGVudHMgb2YgdGhlIE1lc3NhZ2UuXG4gKiAqIGxheWVyLk1lc3NhZ2Uuc2VudEF0OiBEYXRlIHRoZSBtZXNzYWdlIHdhcyBzZW50XG4gKiAqIGxheWVyLk1lc3NhZ2Uuc2VuZGVyIGB1c2VySWRgOiBDb252ZXJzYXRpb24gcGFydGljaXBhbnQgd2hvIHNlbnQgdGhlIE1lc3NhZ2UuIFlvdSBtYXlcbiAqICAgbmVlZCB0byBkbyBhIGxvb2t1cCBvbiB0aGlzIGlkIGluIHlvdXIgb3duIHNlcnZlcnMgdG8gZmluZCBhXG4gKiAgIGRpc3BsYXlhYmxlIG5hbWUgZm9yIGl0LlxuICpcbiAqIE1ldGhvZHM6XG4gKlxuICogKiBsYXllci5NZXNzYWdlLnNlbmQoKTogU2VuZHMgdGhlIG1lc3NhZ2UgdG8gdGhlIHNlcnZlciBhbmQgdGhlIG90aGVyIHBhcnRpY2lwYW50cy5cbiAqICogbGF5ZXIuTWVzc2FnZS5vbigpIGFuZCBsYXllci5NZXNzYWdlLm9mZigpOyBldmVudCBsaXN0ZW5lcnMgYnVpbHQgb24gdG9wIG9mIHRoZSBgYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmVgIG5wbSBwcm9qZWN0XG4gKlxuICogRXZlbnRzOlxuICpcbiAqICogYG1lc3NhZ2VzOnNlbnRgOiBUaGUgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBDYW4gYWxzbyBzdWJzY3JpYmUgdG9cbiAqICAgdGhpcyBldmVudCBmcm9tIHRoZSBsYXllci5DbGllbnQgd2hpY2ggaXMgdXN1YWxseSBzaW1wbGVyLlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuTWVzc2FnZVxuICogQGV4dGVuZHMgbGF5ZXIuU3luY2FibGVcbiAqL1xuXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi4vcm9vdCcpO1xuY29uc3QgU3luY2FibGUgPSByZXF1aXJlKCcuL3N5bmNhYmxlJyk7XG5jb25zdCBNZXNzYWdlUGFydCA9IHJlcXVpcmUoJy4vbWVzc2FnZS1wYXJ0Jyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vY2xpZW50LXV0aWxzJyk7XG5jb25zdCBJZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuY2xhc3MgTWVzc2FnZSBleHRlbmRzIFN5bmNhYmxlIHtcbiAgLyoqXG4gICAqIFNlZSBsYXllci5Db252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSgpXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFVubGVzcyB0aGlzIGlzIGEgc2VydmVyIHJlcHJlc2VudGF0aW9uLCB0aGlzIGlzIGEgZGV2ZWxvcGVyJ3Mgc2hvcnRoYW5kO1xuICAgIC8vIGZpbGwgaW4gdGhlIG1pc3NpbmcgcHJvcGVydGllcyBhcm91bmQgaXNSZWFkL2lzVW5yZWFkIGJlZm9yZSBpbml0aWFsaXppbmcuXG4gICAgaWYgKCFvcHRpb25zLmZyb21TZXJ2ZXIpIHtcbiAgICAgIGlmICgnaXNVbnJlYWQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5pc1JlYWQgPSAhb3B0aW9ucy5pc1VucmVhZCAmJiAhb3B0aW9ucy5pc191bnJlYWQ7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmlzVW5yZWFkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5pc1JlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmlkID0gb3B0aW9ucy5mcm9tU2VydmVyLmlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNsaWVudCkgb3B0aW9ucy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50LmFwcElkO1xuICAgIGlmICghb3B0aW9ucy5jbGllbnRJZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jbGllbnRNaXNzaW5nKTtcblxuICAgIC8vIEluc3VyZSBfX2FkanVzdFBhcnRzIGlzIHNldCBBRlRFUiBjbGllbnRJZCBpcyBzZXQuXG4gICAgY29uc3QgcGFydHMgPSBvcHRpb25zLnBhcnRzO1xuICAgIG9wdGlvbnMucGFydHMgPSBudWxsO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuXG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZyb21TZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihvcHRpb25zLmZyb21TZXJ2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2xpZW50KSB0aGlzLnNlbmRlciA9IGNsaWVudC51c2VyO1xuICAgICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXJ0cykgdGhpcy5wYXJ0cyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gaW5wdXQgaW50byB2YWxpZCBsYXllci5NZXNzYWdlUGFydHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGFueSB0aW1lIHRoZSBwYXJ0c1xuICAgKiBwcm9wZXJ0eSBpcyBzZXQgKGluY2x1ZGluZyBkdXJpbmcgaW50aWFsaXphdGlvbikuICBUaGlzXG4gICAqIGlzIHdoZXJlIHdlIGNvbnZlcnQgc3RyaW5ncyBpbnRvIE1lc3NhZ2VQYXJ0cywgYW5kIGluc3RhbmNlc1xuICAgKiBpbnRvIGFycmF5cy5cbiAgICpcbiAgICogQG1ldGhvZCBfX2FkanVzdFBhcnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge01peGVkfSBwYXJ0cyAtLSBDb3VsZCBiZSBhIHN0cmluZywgYXJyYXksIG9iamVjdCBvciBNZXNzYWdlUGFydCBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlUGFydFtdfVxuICAgKi9cbiAgX19hZGp1c3RQYXJ0cyhwYXJ0cykge1xuICAgIGxldCBhZGp1c3RlZFBhcnRzO1xuICAgIGlmICh0eXBlb2YgcGFydHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhZGp1c3RlZFBhcnRzID0gW25ldyBNZXNzYWdlUGFydCh7XG4gICAgICAgIGJvZHk6IHBhcnRzLFxuICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIH0pXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFydHMpKSB7XG4gICAgICBhZGp1c3RlZFBhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgTWVzc2FnZVBhcnQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBNZXNzYWdlUGFydChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2xpZW50SWQgPSB0aGlzLmNsaWVudElkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0cyAmJiB0eXBlb2YgcGFydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBwYXJ0cy5jbGllbnRJZCA9IHRoaXMuY2xpZW50SWQ7XG4gICAgICBhZGp1c3RlZFBhcnRzID0gW25ldyBNZXNzYWdlUGFydChwYXJ0cyldO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cFBhcnRJZHMoYWRqdXN0ZWRQYXJ0cyk7XG4gICAgaWYgKGFkanVzdGVkUGFydHMpIHtcbiAgICAgIGFkanVzdGVkUGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBwYXJ0Lm9mZignbWVzc2FnZXBhcnRzOmNoYW5nZScsIHRoaXMuX29uTWVzc2FnZVBhcnRDaGFuZ2UsIHRoaXMpOyAvLyBpZiB3ZSBhbHJlYWR5IHN1YnNjcmliZWQsIGRvbid0IGNyZWF0ZSBhIHJlZHVuZGFudCBzdWJzY3JpcHRpb25cbiAgICAgICAgcGFydC5vbignbWVzc2FnZXBhcnRzOmNoYW5nZScsIHRoaXMuX29uTWVzc2FnZVBhcnRDaGFuZ2UsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhZGp1c3RlZFBhcnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGxheWVyLk1lc3NhZ2VQYXJ0IHRvIHRoaXMgTWVzc2FnZS5cbiAgICpcbiAgICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGFuIHVuc2VudCBNZXNzYWdlLlxuICAgKlxuICAgKiBgYGBcbiAgICogbWVzc2FnZS5hZGRQYXJ0KHttaW1lVHlwZTogJ3RleHQvcGxhaW4nLCBib2R5OiAnRnJvZG8gcmVhbGx5IGlzIGEgRG9kbyd9KTtcbiAgICpcbiAgICogLy8gT1JcbiAgICogbWVzc2FnZS5hZGRQYXJ0KG5ldyBsYXllci5NZXNzYWdlUGFydCh7bWltZVR5cGU6ICd0ZXh0L3BsYWluJywgYm9keTogJ0Zyb2RvIHJlYWxseSBpcyBhIERvZG8nfSkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQG1ldGhvZCBhZGRQYXJ0XG4gICAqIEBwYXJhbSAge2xheWVyLk1lc3NhZ2VQYXJ0L09iamVjdH0gcGFydCAtIEEgbGF5ZXIuTWVzc2FnZVBhcnQgaW5zdGFuY2Ugb3IgYSBge21pbWVUeXBlOiAndGV4dC9wbGFpbicsIGJvZHk6ICdIZWxsbyd9YCBmb3JtYXR0ZWQgT2JqZWN0LlxuICAgKiBAcmV0dXJucyB7bGF5ZXIuTWVzc2FnZX0gdGhpc1xuICAgKi9cbiAgYWRkUGFydChwYXJ0KSB7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuY2xpZW50SWQgPSB0aGlzLmNsaWVudElkO1xuICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBNZXNzYWdlUGFydCkge1xuICAgICAgICB0aGlzLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLnBhcnRzLnB1c2gobmV3IE1lc3NhZ2VQYXJ0KHBhcnQpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYXJ0cy5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgdGhlUGFydCA9IHRoaXMucGFydHNbaW5kZXhdO1xuXG4gICAgICB0aGVQYXJ0Lm9mZignbWVzc2FnZXBhcnRzOmNoYW5nZScsIHRoaXMuX29uTWVzc2FnZVBhcnRDaGFuZ2UsIHRoaXMpOyAvLyBpZiB3ZSBhbHJlYWR5IHN1YnNjcmliZWQsIGRvbid0IGNyZWF0ZSBhIHJlZHVuZGFudCBzdWJzY3JpcHRpb25cbiAgICAgIHRoZVBhcnQub24oJ21lc3NhZ2VwYXJ0czpjaGFuZ2UnLCB0aGlzLl9vbk1lc3NhZ2VQYXJ0Q2hhbmdlLCB0aGlzKTtcbiAgICAgIGlmICghcGFydC5pZCkgcGFydC5pZCA9IGAke3RoaXMuaWR9L3BhcnRzLyR7aW5kZXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQW55IHRpbWUgYSBQYXJ0IGNoYW5nZXMsIHRoZSBNZXNzYWdlIGhhcyBjaGFuZ2VkOyB0cmlnZ2VyIHRoZSBgbWVzc2FnZXM6Y2hhbmdlYCBldmVudC5cbiAgICpcbiAgICogQ3VycmVudGx5LCB0aGlzIG9ubHkgbG9va3MgYXQgY2hhbmdlcyB0byBib2R5IG9yIG1pbWVUeXBlLCBhbmQgZG9lcyBub3QgaGFuZGxlIGNoYW5nZXMgdG8gdXJsL3JpY2ggY29udGVudC5cbiAgICpcbiAgICogQG1ldGhvZCBfb25NZXNzYWdlUGFydENoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgX29uTWVzc2FnZVBhcnRDaGFuZ2UoZXZ0KSB7XG4gICAgZXZ0LmNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgICAgcHJvcGVydHk6ICdwYXJ0cy4nICsgY2hhbmdlLnByb3BlcnR5LFxuICAgICAgICBvbGRWYWx1ZTogY2hhbmdlLm9sZFZhbHVlLFxuICAgICAgICBuZXdWYWx1ZTogY2hhbmdlLm5ld1ZhbHVlLFxuICAgICAgICBwYXJ0OiBldnQudGFyZ2V0LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogWW91ciB1bnNlbnQgTWVzc2FnZSB3aWxsIHNob3cgdXAgaW4gUXVlcnkgcmVzdWx0cyBhbmQgYmUgcmVuZGVyZWQgaW4gTWVzc2FnZSBMaXN0cy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgb25seSBuZWVkZWQgZm9yIE1lc3NhZ2VzIHRoYXQgc2hvdWxkIHNob3cgdXAgaW4gYSBNZXNzYWdlIExpc3QgV2lkZ2V0IHRoYXRcbiAgICogaXMgZHJpdmVuIGJ5IFF1ZXJ5IGRhdGEsIGJ1dCB3aGVyZSB0aGUgbGF5ZXIuTWVzc2FnZS5zZW5kIG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIGNhbGxlZC5cbiAgICpcbiAgICogT25jZSB5b3UgaGF2ZSBjYWxsZWQgYHByZXNlbmRgIHlvdXIgbWVzc2FnZSBzaG91bGQgc2hvdyB1cCBpbiB5b3VyIE1lc3NhZ2UgTGlzdC4gIEhvd2V2ZXIsXG4gICAqIHR5cGljYWxseSB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIGVkaXQgYW5kIHJlcmVuZGVyIHRoYXQgTWVzc2FnZS4gQWZ0ZXIgbWFraW5nIGNoYW5nZXMgdG8gdGhlIE1lc3NhZ2UsXG4gICAqIHlvdSBjYW4gdHJpZ2dlciBjaGFuZ2UgZXZlbnRzOlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIG1lc3NhZ2UgPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7cGFydHM6IFt7bWltZVR5cGU6ICdjdXN0b20vY2FyZCcsIGJvZHk6IG51bGx9XX0pO1xuICAgKiBtZXNzYWdlLnByZXNlbmQoKTtcbiAgICpcbiAgICogbWVzc2FnZS5wYXJ0c1swXS5ib2R5ID0gJ0Zyb2RvIGlzIGEgRG9kbyc7XG4gICAqIG1lc3NhZ2UudHJpZ2dlcignbWVzc2FnZXM6Y2hhbmdlJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgdXNpbmcgTGF5ZXIgVUkgZm9yIFdlYiwgdGhlIGBtZXNzYWdlczpjaGFuZ2VgIGV2ZW50IHdpbGwgdHJpZ2dlciBhbiBgb25SZXJlbmRlcmAgY2FsbCxcbiAgICogbm90IGFuIGBvblJlbmRlcmAgY2FsbCwgc28gdGhlIGNhcGFjaXR5IHRvIGhhbmRsZSBlZGl0aW5nIG9mIG1lc3NhZ2VzIHdpbGwgcmVxdWlyZSB0aGUgYWJpbGl0eSB0byByZW5kZXJcbiAgICogYWxsIHBvc3NpYmxlIGVkaXRzIHdpdGhpbiBgb25SZXJlbmRlcmAuXG4gICAqXG4gICAqIEl0IGlzIGFzc3VtZWQgdGhhdCBhdCBzb21lIHBvaW50IGVpdGhlciBgc2VuZCgpYCBvciBgZGVzdHJveSgpYCB3aWxsIGJlIGNhbGxlZCBvbiB0aGlzIG1lc3NhZ2VcbiAgICogdG8gY29tcGxldGUgb3IgY2FuY2VsIHRoaXMgcHJvY2Vzcy5cbiAgICpcbiAgICogQG1ldGhvZCBwcmVzZW5kXG4gICAqL1xuICBwcmVzZW5kKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5nZXRDb252ZXJzYXRpb24oZmFsc2UpO1xuXG4gICAgaWYgKCFjb252ZXJzYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY29udmVyc2F0aW9uTWlzc2luZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3luY1N0YXRlICE9PSBDb25zdGFudHMuU1lOQ19TVEFURS5ORVcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuYWxyZWFkeVNlbnQpO1xuICAgIH1cbiAgICBjb252ZXJzYXRpb24uX3NldHVwTWVzc2FnZSh0aGlzKTtcblxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgZGF0YSBpcyBpbiB0aGUgcmlnaHQgZm9ybWF0IGZvciBiZWluZyByZW5kZXJlZFxuICAgIHRoaXMuX3JlYWRBbGxCbG9icygoKSA9PiB7XG4gICAgICBjbGllbnQuX2FkZE1lc3NhZ2UodGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgbWVzc2FnZSB0byBhbGwgcGFydGljaXBhbnRzIG9mIHRoZSBDb252ZXJzYXRpb24uXG4gICAqXG4gICAqIE1lc3NhZ2UgbXVzdCBoYXZlIHBhcnRzIGFuZCBhIHZhbGlkIGNvbnZlcnNhdGlvbiB0byBzZW5kIHN1Y2Nlc3NmdWxseS5cbiAgICpcbiAgICogVGhlIHNlbmQgbWV0aG9kIHRha2VzIGEgYG5vdGlmaWNhdGlvbmAgb2JqZWN0LiBJbiBub3JtYWwgdXNlLCBpdCBwcm92aWRlcyB0aGUgc2FtZSBub3RpZmljYXRpb24gdG8gQUxMXG4gICAqIHJlY2lwaWVudHMsIGJ1dCB5b3UgY2FuIGN1c3RvbWl6ZSBub3RpZmljYXRpb25zIG9uIGEgcGVyIHJlY2lwaWVudCBiYXNpcywgYXMgd2VsbCBhcyBlbWJlZCBhY3Rpb25zIGludG8gdGhlIG5vdGlmaWNhdGlvbi5cbiAgICogRm9yIHRoZSBGdWxsIEFQSSwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3BsYXRmb3JtL21lc3NhZ2VzI25vdGlmaWNhdGlvbi1jdXN0b21pemF0aW9uLlxuICAgKlxuICAgKiBGb3IgdGhlIEZ1bGwgQVBJLCBzZWUgW1NlcnZlciBEb2NzXShodHRwczovL2RldmVsb3Blci5sYXllci5jb20vZG9jcy9wbGF0Zm9ybS9tZXNzYWdlcyNub3RpZmljYXRpb24tY3VzdG9taXphdGlvbikuXG4gICAqXG4gICAqIGBgYFxuICAgKiBtZXNzYWdlLnNlbmQoe1xuICAgKiAgICB0aXRsZTogXCJOZXcgSG9iYml0IE1lc3NhZ2VcIixcbiAgICogICAgdGV4dDogXCJGcm9kby10aGUtRG9kbzogSGVsbG8gU2FtLCB3aGF0IHNheSB3ZSB3YWx0eiBpbnRvIE1vcmRvciBsaWtlIHdlIG93biB0aGUgcGxhY2U/XCIsXG4gICAqICAgIHNvdW5kOiBcIndoaW55aG9iYml0LmFpZmZcIlxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBtZXRob2Qgc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW25vdGlmaWNhdGlvbl0gLSBQYXJhbWV0ZXJzIGZvciBjb250cm9saW5nIGhvdyB0aGUgcGhvbmVzIG1hbmFnZSBub3RpZmljYXRpb25zIG9mIHRoZSBuZXcgTWVzc2FnZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBJT1MgYW5kIEFuZHJvaWQgZG9jcyBmb3IgZGV0YWlscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub3RpZmljYXRpb24udGl0bGVdIC0gVGl0bGUgdG8gc2hvdyBvbiBsb2NrIHNjcmVlbiBhbmQgbm90aWZpY2F0aW9uIGJhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vdGlmaWNhdGlvbi50ZXh0XSAtIFRleHQgb2YgeW91ciBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtub3RpZmljYXRpb24uc291bmRdIC0gTmFtZSBvZiBhbiBhdWRpbyBmaWxlIG9yIG90aGVyIHNvdW5kLXJlbGF0ZWQgaGludFxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlfSB0aGlzXG4gICAqL1xuICBzZW5kKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgaWYgKCFjbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5nZXRDb252ZXJzYXRpb24odHJ1ZSk7XG5cbiAgICBpZiAoIWNvbnZlcnNhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jb252ZXJzYXRpb25NaXNzaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zeW5jU3RhdGUgIT09IENvbnN0YW50cy5TWU5DX1NUQVRFLk5FVykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5hbHJlYWR5U2VudCk7XG4gICAgfVxuXG5cbiAgICBpZiAoY29udmVyc2F0aW9uLmlzTG9hZGluZykge1xuICAgICAgY29udmVyc2F0aW9uLm9uY2UoY29udmVyc2F0aW9uLmNvbnN0cnVjdG9yLmV2ZW50UHJlZml4ICsgJzpsb2FkZWQnLCAoKSA9PiB0aGlzLnNlbmQobm90aWZpY2F0aW9uKSk7XG4gICAgICBjb252ZXJzYXRpb24uX3NldHVwTWVzc2FnZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXJ0cyB8fCAhdGhpcy5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkucGFydHNNaXNzaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRTeW5jaW5nKCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgQ29udmVyc2F0aW9uIGhhcyBiZWVuIGNyZWF0ZWQgb24gdGhlIHNlcnZlclxuICAgIC8vIGFuZCB1cGRhdGUgdGhlIGxhc3RNZXNzYWdlIHByb3BlcnR5XG4gICAgY29udmVyc2F0aW9uLnNlbmQodGhpcyk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgc2VuZGluZyBhbnkgRmlsZS9CbG9iIG9iamVjdHMsIGFuZCB0aGVpciBNaW1lIFR5cGVzIG1hdGNoIG91ciB0ZXN0LFxuICAgIC8vIHdhaXQgdW50aWwgdGhlIGJvZHkgaXMgdXBkYXRlZCB0byBiZSBhIHN0cmluZyByYXRoZXIgdGhhbiBGaWxlIGJlZm9yZSBjYWxsaW5nIF9hZGRNZXNzYWdlXG4gICAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgdG8gdGhlIFF1ZXJ5IFJlc3VsdHMgYW5kIHBhc3MgdGhpcyBvbiB0byBhIHJlbmRlcmVyIHRoYXQgZXhwZWN0cyBcInRleHQvcGxhaW5cIiB0byBiZSBhIHN0cmluZ1xuICAgIC8vIHJhdGhlciB0aGFuIGEgYmxvYi5cbiAgICB0aGlzLl9yZWFkQWxsQmxvYnMoKCkgPT4ge1xuICAgICAgLy8gQ2FsbGluZyB0aGlzIHdpbGwgYWRkIHRoaXMgdG8gYW55IGxpc3RlbmluZyBRdWVyaWVzLi4uIHNvIHBvc2l0aW9uIG5lZWRzIHRvIGhhdmUgYmVlbiBzZXQgZmlyc3Q7XG4gICAgICAvLyBoYW5kbGVkIGluIGNvbnZlcnNhdGlvbi5zZW5kKHRoaXMpXG4gICAgICBjbGllbnQuX2FkZE1lc3NhZ2UodGhpcyk7XG5cbiAgICAgIC8vIGFsbG93IGZvciBtb2RpZmljYXRpb24gb2YgbWVzc2FnZSBiZWZvcmUgc2VuZGluZ1xuICAgICAgdGhpcy50cmlnZ2VyKCdtZXNzYWdlczpzZW5kaW5nJyk7XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHBhcnRzOiBuZXcgQXJyYXkodGhpcy5wYXJ0cy5sZW5ndGgpLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgIH07XG4gICAgICBpZiAobm90aWZpY2F0aW9uICYmIHRoaXMuY29udmVyc2F0aW9uSWQpIGRhdGEubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuXG4gICAgICB0aGlzLl9wcmVwYXJlUGFydHNGb3JTZW5kaW5nKGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFueSBNZXNzYWdlUGFydCB0aGF0IGNvbnRhaW5zIGEgdGV4dHVhbCBibG9iIHNob3VsZCBjb250YWluIGEgc3RyaW5nIGJlZm9yZSB3ZSBzZW5kLlxuICAgKlxuICAgKiBJZiBhIE1lc3NhZ2VQYXJ0IHdpdGggYSBCbG9iIG9yIEZpbGUgYXMgaXRzIGJvZHkgd2VyZSB0byBiZSBhZGRlZCB0byB0aGUgQ2xpZW50LFxuICAgKiBUaGUgUXVlcnkgd291bGQgcmVjZWl2ZSB0aGlzLCBkZWxpdmVyIGl0IHRvIGFwcHMgYW5kIHRoZSBhcHAgd291bGQgY3Jhc2guXG4gICAqIE1vc3QgcmVuZGVyaW5nIGNvZGUgZXhwZWN0aW5nIHRleHQvcGxhaW4gd291bGQgZXhwZWN0IGEgc3RyaW5nIG5vdCBhIEZpbGUuXG4gICAqXG4gICAqIFdoZW4gdGhpcyB1c2VyIGlzIHNlbmRpbmcgYSBmaWxlLCBhbmQgdGhhdCBmaWxlIGlzIHRleHR1YWwsIG1ha2Ugc3VyZVxuICAgKiBpdHMgYWN0dWFsIHRleHQgZGVsaXZlcmVkIHRvIHRoZSBVSS5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVhZEFsbEJsb2JzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVhZEFsbEJsb2JzKGNhbGxiYWNrKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFydHMuZmlsdGVyKHBhcnQgPT4gVXRpbC5pc0Jsb2IocGFydC5ib2R5KSAmJiBwYXJ0LmlzVGV4dHVhbE1pbWVUeXBlKCkpO1xuICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgIFV0aWwuZmV0Y2hUZXh0RnJvbUZpbGUocGFydC5ib2R5LCAodGV4dCkgPT4ge1xuICAgICAgICBwYXJ0LmJvZHkgPSB0ZXh0O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoY291bnQgPT09IHBhcnRzLmxlbmd0aCkgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghcGFydHMubGVuZ3RoKSBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3VyZXMgdGhhdCBlYWNoIHBhcnQgaXMgcmVhZHkgdG8gc2VuZCBiZWZvcmUgYWN0dWFsbHkgc2VuZGluZyB0aGUgTWVzc2FnZS5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJlcGFyZVBhcnRzRm9yU2VuZGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0cnVjdHVyZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICovXG4gIF9wcmVwYXJlUGFydHNGb3JTZW5kaW5nKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgcGFydC5vbmNlKCdwYXJ0czpzZW5kJywgKGV2dCkgPT4ge1xuICAgICAgICBkYXRhLnBhcnRzW2luZGV4XSA9IHtcbiAgICAgICAgICBtaW1lX3R5cGU6IGV2dC5taW1lX3R5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldnQuY29udGVudCkgZGF0YS5wYXJ0c1tpbmRleF0uY29udGVudCA9IGV2dC5jb250ZW50O1xuICAgICAgICBpZiAoZXZ0LmJvZHkpIGRhdGEucGFydHNbaW5kZXhdLmJvZHkgPSBldnQuYm9keTtcbiAgICAgICAgaWYgKGV2dC5lbmNvZGluZykgZGF0YS5wYXJ0c1tpbmRleF0uZW5jb2RpbmcgPSBldnQuZW5jb2Rpbmc7XG5cbiAgICAgICAgY291bnQrKztcbiAgICAgICAgaWYgKGNvdW50ID09PSB0aGlzLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcGFydC5fc2VuZChjbGllbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgYWN0dWFsIHNlbmRpbmcuXG4gICAqXG4gICAqIGxheWVyLk1lc3NhZ2Uuc2VuZCBoYXMgc29tZSBwb3RlbnRpYWxseSBhc3luY2hyb25vdXNcbiAgICogcHJlcHJvY2Vzc2luZyB0byBkbyBiZWZvcmUgc2VuZGluZyAoUmljaCBDb250ZW50KTsgYWN0dWFsIHNlbmRpbmdcbiAgICogaXMgZG9uZSBoZXJlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zZW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2VuZChkYXRhKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG5cbiAgICB0aGlzLmdldENsaWVudCgpLl90cmlnZ2VyQXN5bmMoJ3N0YXRlLWNoYW5nZScsIHtcbiAgICAgIHN0YXJ0ZWQ6IHRydWUsXG4gICAgICB0eXBlOiAnc2VuZF8nICsgVXRpbC50eXBlRnJvbUlEKHRoaXMuaWQpLFxuICAgICAgdGVsZW1ldHJ5SWQ6ICdzZW5kXycgKyBVdGlsLnR5cGVGcm9tSUQodGhpcy5pZCkgKyAnX3RpbWUnLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgfSk7XG4gICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZSgpO1xuICAgIGNsaWVudC5zZW5kU29ja2V0UmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbWV0aG9kOiAnTWVzc2FnZS5jcmVhdGUnLFxuICAgICAgICBvYmplY3RfaWQ6IGNvbnZlcnNhdGlvbi5pZCxcbiAgICAgICAgZGF0YSxcbiAgICAgIH0sXG4gICAgICBzeW5jOiB7XG4gICAgICAgIGRlcGVuZHM6IFt0aGlzLmNvbnZlcnNhdGlvbklkLCB0aGlzLmlkXSxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmlkLFxuICAgICAgfSxcbiAgICB9LCAoc3VjY2Vzcywgc29ja2V0RGF0YSkgPT4gdGhpcy5fc2VuZFJlc3VsdChzdWNjZXNzLCBzb2NrZXREYXRhKSk7XG4gIH1cblxuICBfZ2V0U2VuZERhdGEoZGF0YSkge1xuICAgIGRhdGEub2JqZWN0X2lkID0gdGhpcy5jb252ZXJzYXRpb25JZDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgICogbGF5ZXIuTWVzc2FnZS5zZW5kKCkgU3VjY2VzcyBDYWxsYmFjay5cbiAgICAqXG4gICAgKiBJZiBzdWNjZXNzZnVsbHkgc2VuZGluZyB0aGUgbWVzc2FnZTsgdHJpZ2dlcnMgYSAnc2VudCcgZXZlbnQsXG4gICAgKiBhbmQgdXBkYXRlcyB0aGUgbWVzc2FnZS5pZC91cmxcbiAgICAqXG4gICAgKiBAbWV0aG9kIF9zZW5kUmVzdWx0XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VEYXRhIC0gU2VydmVyIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAgKi9cbiAgX3NlbmRSZXN1bHQoeyBzdWNjZXNzLCBkYXRhIH0pIHtcbiAgICB0aGlzLmdldENsaWVudCgpLl90cmlnZ2VyQXN5bmMoJ3N0YXRlLWNoYW5nZScsIHtcbiAgICAgIGVuZGVkOiB0cnVlLFxuICAgICAgdHlwZTogJ3NlbmRfJyArIFV0aWwudHlwZUZyb21JRCh0aGlzLmlkKSxcbiAgICAgIHRlbGVtZXRyeUlkOiAnc2VuZF8nICsgVXRpbC50eXBlRnJvbUlEKHRoaXMuaWQpICsgJ190aW1lJyxcbiAgICAgIHJlc3VsdDogc3VjY2VzcyxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgIH0pO1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgdGhpcy5fcG9wdWxhdGVGcm9tU2VydmVyKGRhdGEpO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlczpzZW50Jyk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgICAgcHJvcGVydHk6ICdzeW5jU3RhdGUnLFxuICAgICAgICBvbGRWYWx1ZTogQ29uc3RhbnRzLlNZTkNfU1RBVEUuU0FWSU5HLFxuICAgICAgICBuZXdWYWx1ZTogQ29uc3RhbnRzLlNZTkNfU1RBVEUuU1lOQ0VELFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcignbWVzc2FnZXM6c2VudC1lcnJvcicsIHsgZXJyb3I6IGRhdGEgfSk7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0U3luY2VkKCk7XG4gIH1cblxuICAvKiBOT1QgRk9SIEpTRFVDS1xuICAgKiBTdGFuZGFyZCBgb24oKWAgcHJvdmlkZWQgYnkgbGF5ZXIuUm9vdC5cbiAgICpcbiAgICogQWRkcyBzb21lIHNwZWNpYWwgaGFuZGxpbmcgb2YgJ21lc3NhZ2VzOmxvYWRlZCcgc28gdGhhdCBjYWxscyBzdWNoIGFzXG4gICAqXG4gICAqICAgICAgdmFyIG0gPSBjbGllbnQuZ2V0TWVzc2FnZSgnbGF5ZXI6Ly8vbWVzc2FnZXMvMTIzJywgdHJ1ZSlcbiAgICogICAgICAub24oJ21lc3NhZ2VzOmxvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgICBteXJlcmVuZGVyKG0pO1xuICAgKiAgICAgIH0pO1xuICAgKiAgICAgIG15cmVuZGVyKG0pOyAvLyByZW5kZXIgYSBwbGFjZWhvbGRlciBmb3IgbSB1bnRpbCB0aGUgZGV0YWlscyBvZiBtIGhhdmUgbG9hZGVkXG4gICAqXG4gICAqIGNhbiBmaXJlIHRoZWlyIGNhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY2xpZW50IGxvYWRzIG9yIGhhc1xuICAgKiBhbHJlYWR5IGxvYWRlZCB0aGUgTWVzc2FnZS5cbiAgICpcbiAgICogQG1ldGhvZCBvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlfSB0aGlzXG4gICAqL1xuICBvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGNvbnN0IGhhc0xvYWRlZEV2dCA9IG5hbWUgPT09ICdtZXNzYWdlczpsb2FkZWQnIHx8XG4gICAgICAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgJiYgbmFtZVsnbWVzc2FnZXM6bG9hZGVkJ10pO1xuXG4gICAgaWYgKGhhc0xvYWRlZEV2dCAmJiAhdGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBuYW1lID09PSAnbWVzc2FnZXM6bG9hZGVkJyA/IGNhbGxiYWNrIDogbmFtZVsnbWVzc2FnZXM6bG9hZGVkJ107XG4gICAgICBVdGlsLmRlZmVyKCgpID0+IGNhbGxOb3cuYXBwbHkoY29udGV4dCkpO1xuICAgIH1cbiAgICBzdXBlci5vbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoaXMgTWVzc2FnZSBmcm9tIHRoZSBzeXN0ZW0uXG4gICAqXG4gICAqIFRoaXMgd2lsbCBkZXJlZ2lzdGVyIHRoZSBNZXNzYWdlLCByZW1vdmUgYWxsIGV2ZW50c1xuICAgKiBhbmQgYWxsb3cgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoY2xpZW50KSBjbGllbnQuX3JlbW92ZU1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKHBhcnQgPT4gcGFydC5kZXN0cm95KCkpO1xuICAgIHRoaXMuX19wYXJ0cyA9IG51bGw7XG5cbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgbWVzc2FnZS1wYXJ0IGlkcyBmb3IgcGFydHMgdGhhdCBsYWNrIHRoYXQgaWQ7IGZvciBsb2NhbGx5IGNyZWF0ZWQgcGFydHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlUGFydFtdfSBwYXJ0c1xuICAgKi9cbiAgX3NldHVwUGFydElkcyhwYXJ0cykge1xuICAgIC8vIEFzc2lnbiBJRHMgdG8gcHJlZXhpc3RpbmcgUGFydHMgc28gdGhhdCB3ZSBjYW4gY2FsbCBnZXRQYXJ0QnlJZCgpXG4gICAgaWYgKHBhcnRzKSB7XG4gICAgICBwYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoIXBhcnQuaWQpIHBhcnQuaWQgPSBgJHt0aGlzLmlkfS9wYXJ0cy8ke2luZGV4fWA7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGVzIHRoaXMgaW5zdGFuY2Ugd2l0aCB0aGUgZGVzY3JpcHRpb24gZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgb3IgZm9yIHVwZGF0aW5nIHRoZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQG1ldGhvZCBfcG9wdWxhdGVGcm9tU2VydmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtIC0gU2VydmVyIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAqL1xuICBfcG9wdWxhdGVGcm9tU2VydmVyKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9pblBvcHVsYXRlRnJvbVNlcnZlciA9IHRydWU7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcblxuICAgIHRoaXMuaWQgPSBtZXNzYWdlLmlkO1xuICAgIHRoaXMudXJsID0gbWVzc2FnZS51cmw7XG4gICAgY29uc3Qgb2xkUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHRoaXMucG9zaXRpb24gPSBtZXNzYWdlLnBvc2l0aW9uO1xuICAgIHRoaXMuX3NldHVwUGFydElkcyhtZXNzYWdlLnBhcnRzKTtcbiAgICB0aGlzLnBhcnRzID0gbWVzc2FnZS5wYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFydCA9IHRoaXMuZ2V0UGFydEJ5SWQocGFydC5pZCk7XG4gICAgICBpZiAoZXhpc3RpbmdQYXJ0KSB7XG4gICAgICAgIGV4aXN0aW5nUGFydC5fcG9wdWxhdGVGcm9tU2VydmVyKHBhcnQpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VQYXJ0Ll9jcmVhdGVGcm9tU2VydmVyKHBhcnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWNpcGllbnRTdGF0dXMgPSBtZXNzYWdlLnJlY2lwaWVudF9zdGF0dXMgfHwge307XG5cbiAgICB0aGlzLmlzUmVhZCA9ICdpc191bnJlYWQnIGluIG1lc3NhZ2UgPyAhbWVzc2FnZS5pc191bnJlYWQgOiB0cnVlO1xuXG4gICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZShtZXNzYWdlLnNlbnRfYXQpO1xuICAgIHRoaXMucmVjZWl2ZWRBdCA9IG1lc3NhZ2UucmVjZWl2ZWRfYXQgPyBuZXcgRGF0ZShtZXNzYWdlLnJlY2VpdmVkX2F0KSA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBzZW5kZXI7XG4gICAgaWYgKG1lc3NhZ2Uuc2VuZGVyLmlkKSB7XG4gICAgICBzZW5kZXIgPSBjbGllbnQuZ2V0SWRlbnRpdHkobWVzc2FnZS5zZW5kZXIuaWQpO1xuICAgIH1cblxuICAgIC8vIEJlY2F1c2UgdGhlcmUgbWF5IGJlIG5vIElELCB3ZSBoYXZlIHRvIGJ5cGFzcyBjbGllbnQuX2NyZWF0ZU9iamVjdCBhbmQgaXRzIHN3aXRjaCBzdGF0ZW1lbnQuXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHNlbmRlciA9IElkZW50aXR5Ll9jcmVhdGVGcm9tU2VydmVyKG1lc3NhZ2Uuc2VuZGVyLCBjbGllbnQpO1xuICAgIH1cbiAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcblxuICAgIHRoaXMuX3NldFN5bmNlZCgpO1xuXG4gICAgaWYgKG9sZFBvc2l0aW9uICYmIG9sZFBvc2l0aW9uICE9PSB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgICAgb2xkVmFsdWU6IG9sZFBvc2l0aW9uLFxuICAgICAgICBuZXdWYWx1ZTogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgcHJvcGVydHk6ICdwb3NpdGlvbicsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5faW5Qb3B1bGF0ZUZyb21TZXJ2ZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlJ3MgbGF5ZXIuTWVzc2FnZVBhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRoZSBwYXJ0IElELlxuICAgKlxuICAgKiBgYGBcbiAgICogdmFyIHBhcnQgPSBjbGllbnQuZ2V0TWVzc2FnZVBhcnQoJ2xheWVyOi8vL21lc3NhZ2VzLzZmMDhhY2ZhLTMyNjgtNGFlNS04M2Q5LTZjYTAwMDAwMDAwL3BhcnRzLzAnKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0UGFydEJ5SWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcnRJZFxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlUGFydH1cbiAgICovXG4gIGdldFBhcnRCeUlkKHBhcnRJZCkge1xuICAgIGNvbnN0IHBhcnQgPSB0aGlzLnBhcnRzID8gdGhpcy5wYXJ0cy5maWx0ZXIoYVBhcnQgPT4gYVBhcnQuaWQgPT09IHBhcnRJZClbMF0gOiBudWxsO1xuICAgIHJldHVybiBwYXJ0IHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBqc29uLXBhdGNoIG9wZXJhdGlvbnMgZm9yIG1vZGlmeWluZyByZWNpcGllbnRTdGF0dXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZVBhdGNoRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0W119IGRhdGEgLSBBcnJheSBvZiBvcGVyYXRpb25zXG4gICAqL1xuICBfaGFuZGxlUGF0Y2hFdmVudChuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGhzKSB7XG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IGZhbHNlO1xuICAgIGlmIChwYXRoc1swXS5pbmRleE9mKCdyZWNpcGllbnRfc3RhdHVzJykgPT09IDApIHtcbiAgICAgIHRoaXMuX191cGRhdGVSZWNpcGllbnRTdGF0dXModGhpcy5yZWNpcGllbnRTdGF0dXMsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhYnNvbHV0ZSBVUkwgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAqIFVzZWQgYnkgc3luYyBtYW5hZ2VyIGJlY2F1c2UgdGhlIHVybCBtYXkgbm90IGJlIGtub3duXG4gICAqIGF0IHRoZSB0aW1lIHRoZSBzeW5jIHJlcXVlc3QgaXMgZW5xdWV1ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldFVybFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gcmVsYXRpdmUgdXJsIGFuZCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZ1bGwgdXJsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLnVybCArICh1cmwgfHwgJycpO1xuICB9XG5cbiAgX3NldHVwU3luY09iamVjdChzeW5jKSB7XG4gICAgaWYgKHN5bmMgIT09IGZhbHNlKSB7XG4gICAgICBzeW5jID0gc3VwZXIuX3NldHVwU3luY09iamVjdChzeW5jKTtcbiAgICAgIGlmICghc3luYy5kZXBlbmRzKSB7XG4gICAgICAgIHN5bmMuZGVwZW5kcyA9IFt0aGlzLmNvbnZlcnNhdGlvbklkXTtcbiAgICAgIH0gZWxzZSBpZiAoc3luYy5kZXBlbmRzLmluZGV4T2YodGhpcy5pZCkgPT09IC0xKSB7XG4gICAgICAgIHN5bmMuZGVwZW5kcy5wdXNoKHRoaXMuY29udmVyc2F0aW9uSWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3luYztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdGV4dCBwYXJ0cyBvZiB0aGUgTWVzc2FnZS5cbiAgICpcbiAgICogVXRpbGl0eSBtZXRob2QgZm9yIGV4dHJhY3RpbmcgYWxsIG9mIHRoZSB0ZXh0L3BsYWluIHBhcnRzXG4gICAqIGFuZCBjb25jYXRlbmF0aW5nIGFsbCBvZiB0aGVpciBib2R5cyB0b2dldGhlciBpbnRvIGEgc2luZ2xlIHN0cmluZy5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbam9pblN0cj0nLiAgJ10gSWYgbXVsdGlwbGUgbWVzc2FnZSBwYXJ0cyBvZiB0eXBlIHRleHQvcGxhaW4sIGhvdyBkbyB5b3Ugd2FudCB0aGVtIGpvaW5lZCB0b2dldGhlcj9cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dChqb2luU3RyID0gJy4gJykge1xuICAgIGxldCB0ZXh0QXJyYXkgPSB0aGlzLnBhcnRzXG4gICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nKVxuICAgICAgLm1hcChwYXJ0ID0+IHBhcnQuYm9keSk7XG4gICAgdGV4dEFycmF5ID0gdGV4dEFycmF5LmZpbHRlcihkYXRhID0+IGRhdGEpO1xuICAgIHJldHVybiB0ZXh0QXJyYXkuam9pbihqb2luU3RyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0LlxuICAgKlxuICAgKiBPYmplY3Qgd2lsbCBoYXZlIGFsbCB0aGUgc2FtZSBwdWJsaWMgcHJvcGVydGllcyBhcyB0aGlzXG4gICAqIE1lc3NhZ2UgaW5zdGFuY2UuICBOZXcgb2JqZWN0IGlzIHJldHVybmVkIGFueSB0aW1lXG4gICAqIGFueSBvZiB0aGlzIG9iamVjdCdzIHByb3BlcnRpZXMgY2hhbmdlLlxuICAgKlxuICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gUE9KTyB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLl90b09iamVjdCkge1xuICAgICAgdGhpcy5fdG9PYmplY3QgPSBzdXBlci50b09iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3Q7XG4gIH1cblxuICBfdHJpZ2dlckFzeW5jKGV2dE5hbWUsIGFyZ3MpIHtcbiAgICB0aGlzLl9jbGVhck9iamVjdCgpO1xuICAgIHN1cGVyLl90cmlnZ2VyQXN5bmMoZXZ0TmFtZSwgYXJncyk7XG4gIH1cblxuICB0cmlnZ2VyKGV2dE5hbWUsIGFyZ3MpIHtcbiAgICB0aGlzLl9jbGVhck9iamVjdCgpO1xuICAgIHN1cGVyLnRyaWdnZXIoZXZ0TmFtZSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllcyB3aGV0aGVyIGEgTWVzc2FnZSByZWNlaXZpbmcgdGhlIHNwZWNpZmllZCBwYXRjaCBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBBcHBsaWVzIG9ubHkgdG8gTWVzc2FnZXMgdGhhdCBhcmVuJ3QgYWxyZWFkeSBsb2FkZWQ7IHVzZWQgdG8gaW5kaWNhdGUgaWYgYSBjaGFuZ2UgZXZlbnQgaXNcbiAgICogc2lnbmlmaWNhbnQgZW5vdWdoIHRvIGxvYWQgdGhlIE1lc3NhZ2UgYW5kIHRyaWdnZXIgY2hhbmdlIGV2ZW50cyBvbiB0aGF0IE1lc3NhZ2UuXG4gICAqXG4gICAqIEF0IHRoaXMgdGltZSB0aGVyZSBhcmUgbm8gcHJvcGVydGllcyB0aGF0IGFyZSBwYXRjaGVkIG9uIE1lc3NhZ2VzIHZpYSB3ZWJzb2NrZXRzXG4gICAqIHRoYXQgd291bGQganVzdGlmeSBsb2FkaW5nIHRoZSBNZXNzYWdlIGZyb20gdGhlIHNlcnZlciBzbyBhcyB0byBub3RpZnkgdGhlIGFwcC5cbiAgICpcbiAgICogT25seSByZWNpcGllbnQgc3RhdHVzIGNoYW5nZXMgYW5kIG1heWJlIGlzX3VucmVhZCBjaGFuZ2VzIGFyZSBzZW50O1xuICAgKiBuZWl0aGVyIG9mIHdoaWNoIGFyZSByZWxldmFudCB0byBhbiBhcHAgdGhhdCBpc24ndCByZW5kZXJpbmcgdGhhdCBtZXNzYWdlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkUmVzb3VyY2VGb3JQYXRjaFxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX2xvYWRSZXNvdXJjZUZvclBhdGNoKHBhdGNoRGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENsaWVudCB0aGF0IHRoZSBNZXNzYWdlIGJlbG9uZ3MgdG8uXG4gKlxuICogQWN0dWFsIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG1hdGNoZXMgdGhlIGFwcElkLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEByZWFkb25seVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5jbGllbnRJZCA9ICcnO1xuXG4vKipcbiAqIENvbnZlcnNhdGlvbiBJRCBvciBDaGFubmVsIElEIHRoYXQgdGhpcyBNZXNzYWdlIGJlbG9uZ3MgdG8uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEByZWFkb25seVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5jb252ZXJzYXRpb25JZCA9ICcnO1xuXG4vKipcbiAqIEFycmF5IG9mIGxheWVyLk1lc3NhZ2VQYXJ0IG9iamVjdHMuXG4gKlxuICogVXNlIGxheWVyLk1lc3NhZ2UuYWRkUGFydCB0byBtb2RpZnkgdGhpcyBhcnJheS5cbiAqXG4gKiBAdHlwZSB7bGF5ZXIuTWVzc2FnZVBhcnRbXX1cbiAqIEByZWFkb25seVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5wYXJ0cyA9IG51bGw7XG5cbi8qKlxuICogVGltZSB0aGF0IHRoZSBtZXNzYWdlIHdhcyBzZW50LlxuICpcbiAqICBOb3RlIHRoYXQgYSBsb2NhbGx5IGNyZWF0ZWQgbGF5ZXIuTWVzc2FnZSB3aWxsIGhhdmUgYSBgc2VudEF0YCB2YWx1ZSBldmVuXG4gKiB0aG91Z2ggaXRzIG5vdCB5ZXQgc2VudDsgdGhpcyBpcyBzbyB0aGF0IGFueSByZW5kZXJpbmcgY29kZSBkb2Vzbid0IG5lZWRcbiAqIHRvIGFjY291bnQgZm9yIGBudWxsYCB2YWx1ZXMuICBTZW5kaW5nIHRoZSBNZXNzYWdlIG1heSBjYXVzZSBhIHNsaWdodCBjaGFuZ2VcbiAqIGluIHRoZSBgc2VudEF0YCB2YWx1ZS5cbiAqXG4gKiBAdHlwZSB7RGF0ZX1cbiAqIEByZWFkb25seVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5zZW50QXQgPSBudWxsO1xuXG4vKipcbiAqIFRpbWUgdGhhdCB0aGUgZmlyc3QgZGVsaXZlcnkgcmVjZWlwdCB3YXMgc2VudCBieSB5b3VyXG4gKiB1c2VyIGFja25vd2xlZGdpbmcgcmVjZWlwdCBvZiB0aGUgbWVzc2FnZS5cbiAqIEB0eXBlIHtEYXRlfVxuICogQHJlYWRvbmx5XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnJlY2VpdmVkQXQgPSBudWxsO1xuXG4vKipcbiAqIElkZW50aXR5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlbmRlciBvZiB0aGUgTWVzc2FnZS5cbiAqXG4gKiBNb3N0IGNvbW1vbmx5IHVzZWQgcHJvcGVydGllcyBvZiBJZGVudGl0eSBhcmU6XG4gKiAqIGRpc3BsYXlOYW1lOiBBIG5hbWUgZm9yIHlvdXIgVUlcbiAqICogdXNlcklkOiBOYW1lIGZvciB0aGUgdXNlciBhcyByZXByZXNlbnRlZCBvbiB5b3VyIHN5c3RlbVxuICogKiBuYW1lOiBSZXByZXNlbnRzIHRoZSBuYW1lIG9mIGEgc2VydmljZSBpZiB0aGUgc2VuZGVyIHdhcyBhbiBhdXRvbWF0ZWQgc3lzdGVtLlxuICpcbiAqICAgICAgPHNwYW4gY2xhc3M9J3NlbnQtYnknPlxuICogICAgICAgIHttZXNzYWdlLnNlbmRlci5kaXNwbGF5TmFtZSB8fCBtZXNzYWdlLnNlbmRlci5uYW1lfVxuICogICAgICA8L3NwYW4+XG4gKlxuICogQHR5cGUge2xheWVyLklkZW50aXR5fVxuICogQHJlYWRvbmx5XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnNlbmRlciA9IG51bGw7XG5cbi8qKlxuICogUG9zaXRpb24gb2YgdGhpcyBtZXNzYWdlIHdpdGhpbiB0aGUgY29udmVyc2F0aW9uLlxuICpcbiAqIE5PVEVTOlxuICpcbiAqIDEuIERlbGV0aW5nIGEgbWVzc2FnZSBkb2VzIG5vdCBhZmZlY3QgcG9zaXRpb24gb2Ygb3RoZXIgTWVzc2FnZXMuXG4gKiAyLiBBIHBvc2l0aW9uIGlzIG5vdCBnYXVyZW50ZWVkIHRvIGJlIHVuaXF1ZSAobXVsdGlwbGUgbWVzc2FnZXMgc2VudCBhdCB0aGUgc2FtZSB0aW1lIGNvdWxkXG4gKiBhbGwgY2xhaW0gdGhlIHNhbWUgcG9zaXRpb24pXG4gKiAzLiBFYWNoIHN1Y2Nlc3NpdmUgbWVzc2FnZSB3aXRoaW4gYSBjb252ZXJzYXRpb24gc2hvdWxkIGV4cGVjdCBhIGhpZ2hlciBwb3NpdGlvbi5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHJlYWRvbmx5XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnBvc2l0aW9uID0gMDtcblxuLyoqXG4gKiBIaW50IHVzZWQgYnkgbGF5ZXIuQ2xpZW50IG9uIHdoZXRoZXIgdG8gdHJpZ2dlciBhIG1lc3NhZ2VzOm5vdGlmeSBldmVudC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLl9ub3RpZnkgPSBmYWxzZTtcblxuLyoqXG4gKiBUaGlzIHByb3BlcnR5IGlzIGhlcmUgZm9yIGNvbnZlbmllbmNlIG9ubHk7IGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBvcHBvc2l0ZSBvZiBpc1JlYWQuXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZS5wcm90b3R5cGUsICdpc1VucmVhZCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzUmVhZDtcbiAgfSxcbn0pO1xuXG5cbk1lc3NhZ2UucHJvdG90eXBlLl90b09iamVjdCA9IG51bGw7XG5cbk1lc3NhZ2UucHJvdG90eXBlLl9pblBvcHVsYXRlRnJvbVNlcnZlciA9IGZhbHNlO1xuXG5NZXNzYWdlLmV2ZW50UHJlZml4ID0gJ21lc3NhZ2VzJztcblxuTWVzc2FnZS5ldmVudFByZWZpeCA9ICdtZXNzYWdlcyc7XG5cbk1lc3NhZ2UucHJlZml4VVVJRCA9ICdsYXllcjovLy9tZXNzYWdlcy8nO1xuXG5NZXNzYWdlLmluT2JqZWN0SWdub3JlID0gU3luY2FibGUuaW5PYmplY3RJZ25vcmU7XG5cbk1lc3NhZ2UuYnViYmxlRXZlbnRQYXJlbnQgPSAnZ2V0Q2xpZW50JztcblxuTWVzc2FnZS5pbWFnZVR5cGVzID0gW1xuICAnaW1hZ2UvZ2lmJyxcbiAgJ2ltYWdlL3BuZycsXG4gICdpbWFnZS9qcGVnJyxcbiAgJ2ltYWdlL2pwZycsXG5dO1xuXG5NZXNzYWdlLl9zdXBwb3J0ZWRFdmVudHMgPSBbXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgaGFzIGJlZW4gbG9hZGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgb25seSB1c2VkIGluIHJlc3BvbnNlIHRvIHRoZSBsYXllci5NZXNzYWdlLmxvYWQoKSBtZXRob2QuXG4gICAqXG4gICAqIGBgYFxuICAgKiB2YXIgbSA9IGNsaWVudC5nZXRNZXNzYWdlKCdsYXllcjovLy9tZXNzYWdlcy8xMjMnLCB0cnVlKVxuICAgKiAgICAub24oJ21lc3NhZ2VzOmxvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICAgbXlyZXJlbmRlcihtKTtcbiAgICogICAgfSk7XG4gICAqIG15cmVuZGVyKG0pOyAvLyByZW5kZXIgYSBwbGFjZWhvbGRlciBmb3IgbSB1bnRpbCB0aGUgZGV0YWlscyBvZiBtIGhhdmUgbG9hZGVkXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICovXG4gICdtZXNzYWdlczpsb2FkZWQnLFxuXG4gIC8qKlxuICAgKiBUaGUgbG9hZCBtZXRob2QgZmFpbGVkIHRvIGxvYWQgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHVzZWQgaW4gcmVzcG9uc2UgdG8gdGhlIGxheWVyLk1lc3NhZ2UubG9hZCgpIG1ldGhvZC5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICAnbWVzc2FnZXM6bG9hZGVkLWVycm9yJyxcblxuICAvKipcbiAgICogTWVzc2FnZSBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2F1c2VkIGJ5IGEgY2FsbCB0byBsYXllci5NZXNzYWdlLmRlbGV0ZSgpIG9yIGEgd2Vic29ja2V0IGV2ZW50LlxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAZXZlbnRcbiAgICovXG4gICdtZXNzYWdlczpkZWxldGUnLFxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIGlzIGFib3V0IHRvIGJlIHNlbnQuXG4gICAqXG4gICAqIExhc3QgY2hhbmNlIHRvIG1vZGlmeSBvciB2YWxpZGF0ZSB0aGUgbWVzc2FnZSBwcmlvciB0byBzZW5kaW5nLlxuICAgKlxuICAgKiAgICAgbWVzc2FnZS5vbignbWVzc2FnZXM6c2VuZGluZycsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgbWVzc2FnZS5hZGRQYXJ0KHttaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2xvY2F0aW9uJywgYm9keTogSlNPTi5zdHJpbmdpZnkoZ2V0R1BTTG9jYXRpb24oKSl9KTtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBUeXBpY2FsbHksIHlvdSB3b3VsZCBsaXN0ZW4gdG8gdGhpcyBldmVudCBtb3JlIGJyb2FkbHkgdXNpbmcgYGNsaWVudC5vbignbWVzc2FnZXM6c2VuZGluZycpYFxuICAgKiB3aGljaCB3b3VsZCB0cmlnZ2VyIGJlZm9yZSBzZW5kaW5nIEFOWSBNZXNzYWdlcy5cbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICAnbWVzc2FnZXM6c2VuZGluZycsXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci5cbiAgICpcbiAgICogSXQgZG9lcyBOT1QgaW5kaWNhdGUgZGVsaXZlcnkgdG8gb3RoZXIgdXNlcnMuXG4gICAqXG4gICAqIEl0IGRvZXMgTk9UIGluZGljYXRlIG1lc3NhZ2VzIHNlbnQgYnkgb3RoZXIgdXNlcnMuXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgJ21lc3NhZ2VzOnNlbnQnLFxuXG4gIC8qKlxuICAgKiBTZXJ2ZXIgZmFpbGVkIHRvIHJlY2VpdmUgdGhlIE1lc3NhZ2UuXG4gICAqXG4gICAqIE1lc3NhZ2Ugd2lsbCBiZSBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGZpcmluZyB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldnQuZXJyb3JcbiAgICovXG4gICdtZXNzYWdlczpzZW50LWVycm9yJyxcblxuICAvKipcbiAgICogVGhlIHJlY2lwaWVudFN0YXR1cyBwcm9wZXJ0eSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogVGhpcyBoYXBwZW5zIGluIHJlc3BvbnNlIHRvIGFuIHVwZGF0ZVxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIuLi4gYnV0IGlzIGFsc28gY2F1c2VkIGJ5IG1hcmtpbmcgdGhlIGN1cnJlbnQgdXNlciBhcyBoYXZpbmcgcmVhZFxuICAgKiBvciByZWNlaXZlZCB0aGUgbWVzc2FnZS5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICAnbWVzc2FnZXM6Y2hhbmdlJyxcblxuXG5dLmNvbmNhdChTeW5jYWJsZS5fc3VwcG9ydGVkRXZlbnRzKTtcblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoTWVzc2FnZSwgW01lc3NhZ2UsICdNZXNzYWdlJ10pO1xuU3luY2FibGUuc3ViY2xhc3Nlcy5wdXNoKE1lc3NhZ2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuIl19
