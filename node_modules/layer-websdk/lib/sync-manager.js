'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  layer.SyncManager
 * @extends layer.Root
 * @protected
 *
 * This class manages
 *
 * 1. a queue of requests that need to be made
 * 2. when a request should be fired, based on authentication state, online state, websocket connection state, and position in the queue
 * 3. when a request should be aborted
 * 4. triggering any request callbacks
 *
 * TODO: In the event of a DNS error, we may have a valid websocket receiving events and telling us we are online,
 * and be unable to create a REST call.  This will be handled wrong because evidence will suggest that we are online.
 * This issue goes away when we use bidirectional websockets for all requests.
 *
 * Applications do not typically interact with this class, but may subscribe to its events
 * to get richer detailed information than is available from the layer.Client instance.
 */
var Root = require('./root');

var _require = require('./sync-event');

var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var xhr = require('./xhr');
var logger = require('./logger');
var Utils = require('./client-utils');

var MAX_RECEIPT_CONNECTIONS = 4;

var SyncManager = function (_Root) {
  _inherits(SyncManager, _Root);

  /**
   * Creates a new SyncManager.
   *
   * An Application is expected to only have one SyncManager.
   *
   *      var socketManager = new layer.Websockets.SocketManager({client: client});
   *      var requestManager = new layer.Websockets.RequestManager({client: client, socketManager: socketManager});
   *
   *      var onlineManager = new layer.OnlineManager({
   *          socketManager: socketManager
   *      });
   *
   *      // Now we can instantiate this thing...
   *      var SyncManager = new layer.SyncManager({
   *          client: client,
   *          onlineManager: onlineManager,
   *          socketManager: socketManager,
   *          requestManager: requestManager
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param {layer.OnlineStateManager} options.onlineManager
   * @param {layer.Websockets.RequestManager} options.requestManager
   * @param {layer.Client} options.client
   */
  function SyncManager(options) {
    _classCallCheck(this, SyncManager);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SyncManager).call(this, options));

    _this.client = options.client;

    // Note we do not store a pointer to client... it is not needed.
    if (_this.client) {
      _this.client.on('ready', function () {
        _this._processNextRequest();
        _this._loadPersistedQueue();
      }, _this);
    }
    _this.queue = [];
    _this.receiptQueue = [];

    // Rather than listen for onlineManager 'connected', let the socketManager listen for that, connect, and the syncManager
    // waits until its actually connected
    _this.onlineManager.on('disconnected', _this._onlineStateChange, _this);
    _this.socketManager.on('connected disconnected', _this._onlineStateChange, _this);
    return _this;
  }

  /**
   * Returns whether the Client is online/offline.
   *
   * For internal use; applications should use layer.Client.isOnline.
   *
   * @method isOnline
   * @returns {Boolean}
   */


  _createClass(SyncManager, [{
    key: 'isOnline',
    value: function isOnline() {
      return this.onlineManager.isOnline;
    }

    /**
     * Process sync request when connection is restored.
     *
     * Any time we go back online (as signaled by the onlineStateManager),
     * Process the next Sync Event (will do nothing if one is already firing)
     *
     * @method _onlineStateChange
     * @private
     * @param  {string} evtName - 'connected' or 'disconnected'
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_onlineStateChange',
    value: function _onlineStateChange(evt) {
      var _this2 = this;

      if (evt.eventName === 'connected') {
        if (this.queue.length) this.queue[0].returnToOnlineCount++;
        setTimeout(function () {
          return _this2._processNextRequest();
        }, 100);
      } else if (evt.eventName === 'disconnected') {
        if (this.queue.length) {
          this.queue[0].isFiring = false;
        }
        if (this.receiptQueue.length) {
          this.receiptQueue.forEach(function (syncEvt) {
            return syncEvt.isFiring = false;
          });
        }
      }
    }

    /**
     * Adds a new xhr request to the queue.
     *
     * If the queue is empty, this will be fired immediately; else it will be added to the queue and wait its turn.
     *
     * If its a read/delivery receipt request, it will typically be fired immediately unless there are many receipt
     * requests already in-flight.
     *
     * @method request
     * @param  {layer.SyncEvent} requestEvt - A SyncEvent specifying the request to be made
     */

  }, {
    key: 'request',
    value: function request(requestEvt) {
      // If its a PATCH request on an object that isn't yet created,
      // do not add it to the queue.
      if (requestEvt.operation !== 'PATCH' || !this._findUnfiredCreate(requestEvt)) {
        logger.info('Sync Manager Request ' + requestEvt.operation + ' on target ' + requestEvt.target, requestEvt.toObject());
        if (requestEvt.operation === 'RECEIPT') {
          this.receiptQueue.push(requestEvt);
        } else {
          this.queue.push(requestEvt);
        }
        this.trigger('sync:add', {
          request: requestEvt,
          target: requestEvt.target
        });
      } else {
        logger.info('Sync Manager Request PATCH ' + requestEvt.target + ' request ignored; create request still enqueued', requestEvt.toObject());
      }

      // If its a DELETE request, purge all other requests on that target.
      if (requestEvt.operation === 'DELETE') {
        this._purgeOnDelete(requestEvt);
      }

      this._processNextRequest(requestEvt);
    }
  }, {
    key: '_processNextRequest',
    value: function _processNextRequest(requestEvt) {
      var _this3 = this;

      // Fire the request if there aren't any existing requests already firing
      if (this.queue.length && !this.queue[0].isFiring) {
        if (requestEvt) {
          this.client.dbManager.writeSyncEvents([requestEvt], function () {
            return _this3._processNextStandardRequest();
          });
        } else {
          this._processNextStandardRequest();
        }
      }

      // If we have anything in the receipts queue, fire it
      if (this.receiptQueue.length) {
        this._processNextReceiptRequest();
      }
    }

    /**
     * Find create request for this resource.
     *
     * Determine if the given target has a POST request waiting to create
     * the resource, and return any matching requests. Used
     * for folding PATCH requests into an unfired CREATE/POST request.
     *
     * @method _findUnfiredCreate
     * @private
     * @param  {layer.SyncEvent} requestEvt
     * @return {Boolean}
     */

  }, {
    key: '_findUnfiredCreate',
    value: function _findUnfiredCreate(requestEvt) {
      return Boolean(this.queue.filter(function (evt) {
        return evt.target === requestEvt.target && evt.operation === 'POST' && !evt.isFiring;
      }).length);
    }

    /**
     * Process the next request in the queue.
     *
     * Request is dequeued on completing the process.
     * If the first request in the queue is firing, do nothing.
     *
     * @method _processNextRequest
     * @private
     */

  }, {
    key: '_processNextStandardRequest',
    value: function _processNextStandardRequest() {
      var _this4 = this;

      if (this.isDestroyed || !this.client.isAuthenticated) return;
      var requestEvt = this.queue[0];
      if (this.isOnline() && requestEvt && !requestEvt.isFiring && !requestEvt._isValidating) {
        requestEvt._isValidating = true;
        this._validateRequest(requestEvt, function (isValid) {
          requestEvt._isValidating = false;
          if (!isValid) {
            _this4._removeRequest(requestEvt, false);
            return _this4._processNextStandardRequest();
          } else {
            _this4._fireRequest(requestEvt);
          }
        });
      }
    }

    /**
     * Process up to MAX_RECEIPT_CONNECTIONS worth of receipts.
     *
     * These requests have no interdependencies. Just fire them all
     * as fast as we can, in parallel.
     *
     * @method _processNextReceiptRequest
     * @private
     */

  }, {
    key: '_processNextReceiptRequest',
    value: function _processNextReceiptRequest() {
      var _this5 = this;

      var firingReceipts = 0;
      this.receiptQueue.forEach(function (receiptEvt) {
        if (_this5.isOnline() && receiptEvt) {
          if (receiptEvt.isFiring || receiptEvt._isValidating) {
            firingReceipts++;
          } else if (firingReceipts < MAX_RECEIPT_CONNECTIONS) {
            firingReceipts++;
            _this5._fireRequest(receiptEvt);
          }
        }
      });
    }

    /**
     * Directly fire this sync request.
     *
     * This is intended to be called only after careful analysis of our state to make sure its safe to send the request.
     * See `_processNextRequest()`
     *
     * @method _fireRequest
     * @private
     * @param {layer.SyncEvent} requestEvt
     */

  }, {
    key: '_fireRequest',
    value: function _fireRequest(requestEvt) {
      if (requestEvt instanceof WebsocketSyncEvent) {
        this._fireRequestWebsocket(requestEvt);
      } else {
        this._fireRequestXHR(requestEvt);
      }
    }

    /**
     * Directly fire this XHR Sync request.
     *
     * @method _fireRequestXHR
     * @private
     * @param {layer.SyncEvent.XHRSyncEvent} requestEvt
     */

  }, {
    key: '_fireRequestXHR',
    value: function _fireRequestXHR(requestEvt) {
      var _this6 = this;

      requestEvt.isFiring = true;
      if (!requestEvt.headers) requestEvt.headers = {};
      requestEvt.headers.authorization = 'Layer session-token="' + this.client.sessionToken + '"';
      logger.info('Sync Manager XHR Request Firing ' + requestEvt.operation + ' ' + requestEvt.target + ' at ' + new Date().toISOString(), requestEvt.toObject());
      xhr(requestEvt._getRequestData(this.client), function (result) {
        return _this6._xhrResult(result, requestEvt);
      });
    }

    /**
     * Directly fire this Websocket Sync request.
     *
     * @method _fireRequestWebsocket
     * @private
     * @param {layer.SyncEvent.WebsocketSyncEvent} requestEvt
     */

  }, {
    key: '_fireRequestWebsocket',
    value: function _fireRequestWebsocket(requestEvt) {
      var _this7 = this;

      if (this.socketManager && this.socketManager._isOpen()) {
        logger.debug('Sync Manager Websocket Request Firing ' + requestEvt.operation + ' on target ' + requestEvt.target, requestEvt.toObject());
        requestEvt.isFiring = true;
        this.requestManager.sendRequest({
          data: requestEvt._getRequestData(this.client),
          callback: function callback(result) {
            return _this7._xhrResult(result, requestEvt);
          },
          isChangesArray: requestEvt.returnChangesArray
        });
      } else {
        logger.debug('Sync Manager Websocket Request skipped; socket closed');
      }
    }

    /**
     * Is the syncEvent still valid?
     *
     * This method specifically tests to see if some other tab has already sent this request.
     * If persistence of the syncQueue is not enabled, then the callback is immediately called with true.
     * If another tab has already sent the request, then the entry will no longer be in indexedDB and the callback
     * will call false.
     *
     * @method _validateRequest
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Function} callback.isValid - The request is still valid
     * @private
     */

  }, {
    key: '_validateRequest',
    value: function _validateRequest(syncEvent, callback) {
      this.client.dbManager.claimSyncEvent(syncEvent, function (isFound) {
        return callback(isFound);
      });
    }

    /**
     * Turn deduplication errors into success messages.
     *
     * If this request has already been made but we failed to get a response the first time and we retried the request,
     * we will reissue the request.  If the prior request was successful we'll get back a deduplication error
     * with the created object. As far as the WebSDK is concerned, this is a success.
     *
     * @method _handleDeduplicationErrors
     * @private
     */

  }, {
    key: '_handleDeduplicationErrors',
    value: function _handleDeduplicationErrors(result) {
      if (result.data && result.data.id === 'id_in_use' && result.data.data && result.data.data.id === result.request._getCreateId()) {
        result.success = true;
        result.data = result.data.data;
      }
    }

    /**
     * Process the result of an xhr call, routing it to the appropriate handler.
     *
     * @method _xhrResult
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrResult',
    value: function _xhrResult(result, requestEvt) {
      if (this.isDestroyed) return;
      result.request = requestEvt;
      requestEvt.isFiring = false;
      this._handleDeduplicationErrors(result);
      if (!result.success) {
        this._xhrError(result);
      } else {
        this._xhrSuccess(result);
      }
    }

    /**
     * Categorize the error for handling.
     *
     * @method _getErrorState
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     * @param  {boolean} isOnline - Is our app state set to online
     * @returns {String}
     */

  }, {
    key: '_getErrorState',
    value: function _getErrorState(result, requestEvt, isOnline) {
      var errId = result.data ? result.data.id : '';
      if (!isOnline) {
        // CORS errors look identical to offline; but if our online state has transitioned from false to true repeatedly while processing this request,
        // thats a hint that that its a CORS error
        if (requestEvt.returnToOnlineCount >= SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR) {
          return 'CORS';
        } else {
          return 'offline';
        }
      } else if (errId === 'not_found') {
        return 'notFound';
      } else if (errId === 'id_in_use') {
        return 'invalidId'; // This only fires if we get `id_in_use` but no Resource, which means the UUID was used by another user/app.
      } else if (result.status === 408 || errId === 'request_timeout') {
        if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
          return 'tooManyFailuresWhileOnline';
        } else {
          return 'validateOnlineAndRetry';
        }
      } else if ([502, 503, 504].indexOf(result.status) !== -1) {
        if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
          return 'tooManyFailuresWhileOnline';
        } else {
          return 'serverUnavailable';
        }
      } else if (errId === 'authentication_required' && result.data.data && result.data.data.nonce) {
        return 'reauthorize';
      } else {
        return 'serverRejectedRequest';
      }
    }

    /**
     * Handle failed requests.
     *
     * 1. If there was an error from the server, then the request has problems
     * 2. If we determine we are not in fact online, call the connectionError handler
     * 3. If we think we are online, verify we are online and then determine how to handle it.
     *
     * @method _xhrError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrError',
    value: function _xhrError(result) {
      var requestEvt = result.request;

      logger.warn('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Failed'), requestEvt.toObject());

      var errState = this._getErrorState(result, requestEvt, this.isOnline());
      logger.warn('Sync Manager Error State: ' + errState);
      switch (errState) {
        case 'tooManyFailuresWhileOnline':
          this._xhrHandleServerError(result, 'Sync Manager Server Unavailable Too Long; removing request', false);
          break;
        case 'notFound':
          this._xhrHandleServerError(result, 'Resource not found; presumably deleted', false);
          break;
        case 'invalidId':
          this._xhrHandleServerError(result, 'ID was not unique; request failed', false);
          break;
        case 'validateOnlineAndRetry':
          // Server appears to be hung but will eventually recover.
          // Retry a few times and then error out.
          // this._xhrValidateIsOnline(requestEvt);
          this._xhrHandleServerUnavailableError(result);
          break;
        case 'serverUnavailable':
          // Server is in a bad state but will eventually recover;
          // keep retrying.
          this._xhrHandleServerUnavailableError(result);
          break;
        case 'reauthorize':
          // sessionToken appears to no longer be valid; forward response
          // on to client-authenticator to process.
          // Do not retry nor advance to next request.
          if (requestEvt.callback) requestEvt.callback(result);

          break;
        case 'serverRejectedRequest':
          // Server presumably did not like the arguments to this call
          // or the url was invalid.  Do not retry; trigger the callback
          // and let the caller handle it.
          this._xhrHandleServerError(result, 'Sync Manager Server Rejects Request; removing request', true);
          break;
        case 'CORS':
          // A pattern of offline-like failures that suggests its actually a CORs error
          this._xhrHandleServerError(result, 'Sync Manager Server detects CORS-like errors; removing request', false);
          break;
        case 'offline':
          this._xhrHandleConnectionError();
          break;
      }

      // Write the sync event back to the database if we haven't completed processing it
      if (this.queue.indexOf(requestEvt) !== -1 || this.receiptQueue.indexOf(requestEvt) !== -1) {
        this.client.dbManager.writeSyncEvents([requestEvt]);
      }
    }

    /**
     * Handle a server unavailable error.
     *
     * In the event of a 502 (Bad Gateway), 503 (service unavailable)
     * or 504 (gateway timeout) error from the server
     * assume we have an error that is self correcting on the server.
     * Use exponential backoff to retry the request.
     *
     * Note that each call will increment retryCount; there is a maximum
     * of MAX_RETRIES before it is treated as an error
     *
     * @method  _xhrHandleServerUnavailableError
     * @private
     * @param  {Object} result             Response object returned by xhr call
     */

  }, {
    key: '_xhrHandleServerUnavailableError',
    value: function _xhrHandleServerUnavailableError(result) {
      var request = result.request;
      this.trigger('sync:error-will-retry', {
        target: request.target,
        request: request,
        error: result.data,
        retryCount: request.retryCount
      });
      var maxDelay = SyncManager.MAX_UNAVAILABLE_RETRY_WAIT;
      var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, request.retryCount++));
      logger.warn('Sync Manager Server Unavailable; retry count ' + request.retryCount + '; retrying in ' + delay + ' seconds');
      setTimeout(this._processNextRequest.bind(this), delay * 1000);
    }

    /**
     * Handle a server error in response to firing sync event.
     *
     * If there is a server error, its presumably non-recoverable/non-retryable error, so
     * we're going to abort this request.
     *
     * 1. If a callback was provided, call it to handle the error
     * 2. If a rollback call is provided, call it to undo any patch/delete/etc... changes
     * 3. If the request was to create a resource, remove from the queue all requests
     *    that depended upon that resource.
     * 4. Advance to next request
     *
     * @method _xhrHandleServerError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {string} logMsg - Message to display in console
     * @param  {boolean} stringify - log object for quick debugging
     *
     */

  }, {
    key: '_xhrHandleServerError',
    value: function _xhrHandleServerError(result, logMsg, stringify) {
      // Execute all callbacks provided by the request
      if (result.request.callback) result.request.callback(result);
      if (stringify) {
        logger.error(logMsg + '\nREQUEST: ' + JSON.stringify(result.request.toObject(), null, 4) + '\nRESPONSE: ' + JSON.stringify(result.data, null, 4));
      } else {
        logger.error(logMsg, result);
      }
      this.trigger('sync:error', {
        target: result.request.target,
        request: result.request,
        error: result.data
      });

      result.request.success = false;

      // If a POST request fails, all requests that depend upon this object
      // must be purged
      if (result.request.operation === 'POST') {
        this._purgeDependentRequests(result.request);
      }

      // Remove this request as well (side-effect: rolls back the operation)
      this._removeRequest(result.request, true);

      // And finally, we are ready to try the next request
      this._processNextRequest();
    }

    /**
     * If there is a connection error, wait for retry.
     *
     * In the event of what appears to be a connection error,
     * Wait until a 'connected' event before processing the next request (actually reprocessing the current event)
     *
     * @method _xhrHandleConnectionError
     * @private
     */

  }, {
    key: '_xhrHandleConnectionError',
    value: function _xhrHandleConnectionError() {}
    // Nothing to be done; we already have the below event handler setup
    // this.onlineManager.once('connected', () => this._processNextRequest());


    /**
     * Verify that we are online and retry request.
     *
     * This method is called when we think we're online, but
     * have determined we need to validate that assumption.
     *
     * Test that we have a connection; if we do,
     * retry the request once, and if it fails again,
     * _xhrError() will determine it to have failed and remove it from the queue.
     *
     * If we are offline, then let _xhrHandleConnectionError handle it.
     *
     * @method _xhrValidateIsOnline
     * @private
     */

  }, {
    key: '_xhrValidateIsOnline',
    value: function _xhrValidateIsOnline(requestEvt) {
      var _this8 = this;

      logger.debug('Sync Manager verifying online state');
      this.onlineManager.checkOnlineStatus(function (isOnline) {
        return _this8._xhrValidateIsOnlineCallback(isOnline, requestEvt);
      });
    }

    /**
     * If we have verified we are online, retry request.
     *
     * We should have received a response to our /nonces call
     * which assuming the server is actually alive,
     * will tell us if the connection is working.
     *
     * If we are offline, flag us as offline and let the ConnectionError handler handle this
     * If we are online, give the request a single retry (there is never more than one retry)
     *
     * @method _xhrValidateIsOnlineCallback
     * @private
     * @param  {boolean} isOnline  - Response object returned by xhr call
     * @param {layer.SyncEvent} requestEvt - The request that failed triggering this call
     */

  }, {
    key: '_xhrValidateIsOnlineCallback',
    value: function _xhrValidateIsOnlineCallback(isOnline, requestEvt) {
      logger.debug('Sync Manager online check result is ' + isOnline);
      if (!isOnline) {
        // Treat this as a Connection Error
        this._xhrHandleConnectionError();
      } else {
        // Retry the request in case we were offline, but are now online.
        // Of course, if this fails, give it up entirely.
        requestEvt.retryCount++;
        this._processNextRequest();
      }
    }

    /**
     * The XHR request was successful.
     *
     * Any xhr request that actually succedes:
     *
     * 1. Remove it from the queue
     * 2. Call any callbacks
     * 3. Advance to next request
     *
     * @method _xhrSuccess
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrSuccess',
    value: function _xhrSuccess(result) {
      var requestEvt = result.request;
      logger.debug('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Succeeded'), requestEvt.toObject());
      if (result.data) logger.debug(result.data);
      requestEvt.success = true;
      this._removeRequest(requestEvt, true);
      if (requestEvt.callback) requestEvt.callback(result);
      this._processNextRequest();

      this.trigger('sync:success', {
        target: requestEvt.target,
        request: requestEvt,
        response: result.data
      });
    }

    /**
     * Remove the SyncEvent request from the queue.
     *
     * @method _removeRequest
     * @private
     * @param  {layer.SyncEvent} requestEvt - SyncEvent Request to remove
     * @param {Boolean} deleteDB - Delete from indexedDB
     */

  }, {
    key: '_removeRequest',
    value: function _removeRequest(requestEvt, deleteDB) {
      var queue = requestEvt.operation === 'RECEIPT' ? this.receiptQueue : this.queue;
      var index = queue.indexOf(requestEvt);
      if (index !== -1) queue.splice(index, 1);
      if (deleteDB) this.client.dbManager.deleteObjects('syncQueue', [requestEvt]);
    }

    /**
     * Remove requests from queue that depend on specified resource.
     *
     * If there is a POST request to create a new resource, and there are PATCH, DELETE, etc...
     * requests on that resource, if the POST request fails, then all PATCH, DELETE, etc
     * requests must be removed from the queue.
     *
     * Note that we do not call the rollback on these dependent requests because the expected
     * rollback is to destroy the thing that was created, which means any other rollback has no effect.
     *
     * @method _purgeDependentRequests
     * @private
     * @param  {layer.SyncEvent} request - Request whose target is no longer valid
     */

  }, {
    key: '_purgeDependentRequests',
    value: function _purgeDependentRequests(request) {
      this.queue = this.queue.filter(function (evt) {
        return evt.depends.indexOf(request.target) === -1 || evt === request;
      });
      this.receiptQueue = this.receiptQueue.filter(function (evt) {
        return evt.depends.indexOf(request.target) === -1 || evt === request;
      });
    }

    /**
     * Remove from queue all events that operate upon the deleted object.
     *
     * @method _purgeOnDelete
     * @private
     * @param  {layer.SyncEvent} evt - Delete event that requires removal of other events
     */

  }, {
    key: '_purgeOnDelete',
    value: function _purgeOnDelete(evt) {
      var _this9 = this;

      this.queue.filter(function (request) {
        return request.depends.indexOf(evt.target) !== -1 && evt !== request;
      }).forEach(function (requestEvt) {
        _this9.trigger('sync:abort', {
          target: requestEvt.target,
          request: requestEvt
        });
        _this9._removeRequest(requestEvt, true);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.queue.forEach(function (evt) {
        return evt.destroy();
      });
      this.queue = null;
      this.receiptQueue.forEach(function (evt) {
        return evt.destroy();
      });
      this.receiptQueue = null;
      _get(Object.getPrototypeOf(SyncManager.prototype), 'destroy', this).call(this);
    }

    /**
     * Load any unsent requests from indexedDB.
     *
     * If persistence is disabled, nothing will happen;
     * else all requests found in the database will be added to the queue.
     * @method _loadPersistedQueue
     * @private
     */

  }, {
    key: '_loadPersistedQueue',
    value: function _loadPersistedQueue() {
      var _this10 = this;

      this.client.dbManager.loadSyncQueue(function (data) {
        if (data.length) {
          _this10.queue = _this10.queue.concat(data);
          _this10._processNextRequest();
        }
      });
    }
  }]);

  return SyncManager;
}(Root);

/**
 * Websocket Manager for getting socket state.
 * @type {layer.Websockets.SocketManager}
 */


SyncManager.prototype.socketManager = null;

/**
 * Websocket Request Manager for sending requests.
 * @type {layer.Websockets.RequestManager}
 */
SyncManager.prototype.requestManager = null;

/**
 * Reference to the Online State Manager.
 *
 * Sync Manager uses online status to determine if it can fire sync-requests.
 * @private
 * @type {layer.OnlineStateManager}
 */
SyncManager.prototype.onlineManager = null;

/**
 * The array of layer.SyncEvent instances awaiting to be fired.
 * @type {layer.SyncEvent[]}
 */
SyncManager.prototype.queue = null;

/**
 * The array of layer.SyncEvent instances awaiting to be fired.
 *
 * Receipts can generally just be fired off all at once without much fretting about ordering or dependencies.
 * @type {layer.SyncEvent[]}
 */
SyncManager.prototype.receiptQueue = null;

/**
 * Reference to the Client so that we can pass it to SyncEvents  which may need to lookup their targets
 */
SyncManager.prototype.client = null;

/**
 * Maximum exponential backoff wait.
 *
 * If the server is returning 502, 503 or 504 errors, exponential backoff
 * should never wait longer than this number of seconds (60 seconds)
 * @type {Number}
 * @static
 */
SyncManager.MAX_UNAVAILABLE_RETRY_WAIT = 60;

/**
 * Retries before suspect CORS error.
 *
 * How many times can we transition from offline to online state
 * with this request at the front of the queue before we conclude
 * that the reason we keep thinking we're going offline is
 * a CORS error returning a status of 0.  If that pattern
 * shows 3 times in a row, there is likely a CORS error.
 * Note that CORS errors appear to javascript as a status=0 error,
 * which is the same as if the client were offline.
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR = 3;

/**
 * Abort request after this number of retries.
 *
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES = 20;

SyncManager._supportedEvents = [
/**
 * A sync request has failed.
 *
 * ```
 * client.syncManager.on('sync:error', function(evt) {
 *    console.error(evt.target + ' failed to send changes to server: ', evt.error.message);
 *    console.log('Request Event:', evt.request);
 * });
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt          Standard Layer Event object generated by all calls to `trigger`
 * @param {layer.LayerError} evt.error    An error object representing the server's response
 * @param {String} evt.target             ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt.request  The original request object
 */
'sync:error',

/**
 * A sync request has but will be retried soon.
 *
 * ```
 * client.syncManager.on('sync:error-will-retry', function(evt) {
 *    console.error(evt.target + ' failed to send changes to server: ', evt.error.message);
 *    console.log('Request Event:', evt.request);
 *    console.log('Number of retries:', evt.retryCount);
 * });
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt          Standard Layer Event object generated by all calls to `trigger`
 * @param {layer.LayerError} evt.error    An error object representing the server's response
 * @param {String} evt.target             ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt.request   The original request object
 * @param {Number} evt.retryCount         Number of retries performed on this request; for the first event this will be 0
 */
'sync:error-will-retry',

/**
 * A sync layer request has completed successfully.
 *
 * ```
 * client.syncManager.on('sync:success', function(evt) {
 *    console.log(evt.target + ' changes sent to server successfully');
 *    console.log('Request Event:', evt.request);
 *    console.log('Server Response:', evt.response);
 * });
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt          Standard Layer Event object generated by all calls to `trigger`
 * @param {String} evt.target             ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt.request   The original request
 * @param {Object} evt.response           null or any data returned by the call
 */
'sync:success',

/**
 * A new sync request has been added.
 *
 * ```
 * client.syncManager.on('sync:add', function(evt) {
 *    console.log(evt.target + ' has changes queued for the server');
 *    console.log('Request Event:', evt.request);
 * });
 * ```
 *
 * @event
 * @param {layer.LayerEvent} evt          Standard Layer Event object generated by all calls to `trigger`
 * @param {String} evt.target             ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt.request   The original request
 */
'sync:add',

/**
 * A sync request has been canceled.
 *
 * Typically caused by a new SyncEvent that deletes the target of this SyncEvent
 *
 * @event
 * @param {layer.LayerEvent} evt          Standard Layer Event object generated by all calls to `trigger`
 * @param {String} evt.target             ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} evt.request   The original request
 */
'sync:abort'].concat(Root._supportedEvents);

Root.initClass(SyncManager);
module.exports = SyncManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zeW5jLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsSUFBTSxPQUFPLFFBQVEsUUFBUixDQUFiOztlQUMrQixRQUFRLGNBQVIsQzs7SUFBdkIsa0IsWUFBQSxrQjs7QUFDUixJQUFNLE1BQU0sUUFBUSxPQUFSLENBQVo7QUFDQSxJQUFNLFNBQVMsUUFBUSxVQUFSLENBQWY7QUFDQSxJQUFNLFFBQVEsUUFBUSxnQkFBUixDQUFkOztBQUVBLElBQU0sMEJBQTBCLENBQWhDOztJQUVNLFc7OztBQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQSx1QkFBWSxPQUFaLEVBQXFCO0FBQUE7O0FBQUEsK0ZBQ2IsT0FEYTs7QUFFbkIsVUFBSyxNQUFMLEdBQWMsUUFBUSxNQUF0Qjs7QUFFQTtBQUNBLFFBQUksTUFBSyxNQUFULEVBQWlCO0FBQ2YsWUFBSyxNQUFMLENBQVksRUFBWixDQUFlLE9BQWYsRUFBd0IsWUFBTTtBQUM1QixjQUFLLG1CQUFMO0FBQ0EsY0FBSyxtQkFBTDtBQUNELE9BSEQ7QUFJRDtBQUNELFVBQUssS0FBTCxHQUFhLEVBQWI7QUFDQSxVQUFLLFlBQUwsR0FBb0IsRUFBcEI7O0FBRUE7QUFDQTtBQUNBLFVBQUssYUFBTCxDQUFtQixFQUFuQixDQUFzQixjQUF0QixFQUFzQyxNQUFLLGtCQUEzQztBQUNBLFVBQUssYUFBTCxDQUFtQixFQUFuQixDQUFzQix3QkFBdEIsRUFBZ0QsTUFBSyxrQkFBckQ7QUFqQm1CO0FBa0JwQjs7QUFFRDs7Ozs7Ozs7Ozs7OytCQVFXO0FBQ1QsYUFBTyxLQUFLLGFBQUwsQ0FBbUIsUUFBMUI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7dUNBV21CLEcsRUFBSztBQUFBOztBQUN0QixVQUFJLElBQUksU0FBSixLQUFrQixXQUF0QixFQUFtQztBQUNqQyxZQUFJLEtBQUssS0FBTCxDQUFXLE1BQWYsRUFBdUIsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLG1CQUFkO0FBQ3ZCLG1CQUFXO0FBQUEsaUJBQU0sT0FBSyxtQkFBTCxFQUFOO0FBQUEsU0FBWCxFQUE2QyxHQUE3QztBQUNELE9BSEQsTUFHTyxJQUFJLElBQUksU0FBSixLQUFrQixjQUF0QixFQUFzQztBQUMzQyxZQUFJLEtBQUssS0FBTCxDQUFXLE1BQWYsRUFBdUI7QUFDckIsZUFBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLFFBQWQsR0FBeUIsS0FBekI7QUFDRDtBQUNELFlBQUksS0FBSyxZQUFMLENBQWtCLE1BQXRCLEVBQThCO0FBQzVCLGVBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQjtBQUFBLG1CQUFZLFFBQVEsUUFBUixHQUFtQixLQUEvQjtBQUFBLFdBQTFCO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs0QkFXUSxVLEVBQVk7QUFDbEI7QUFDQTtBQUNBLFVBQUksV0FBVyxTQUFYLEtBQXlCLE9BQXpCLElBQW9DLENBQUMsS0FBSyxrQkFBTCxDQUF3QixVQUF4QixDQUF6QyxFQUE4RTtBQUM1RSxlQUFPLElBQVAsMkJBQW9DLFdBQVcsU0FBL0MsbUJBQXNFLFdBQVcsTUFBakYsRUFBMkYsV0FBVyxRQUFYLEVBQTNGO0FBQ0EsWUFBSSxXQUFXLFNBQVgsS0FBeUIsU0FBN0IsRUFBd0M7QUFDdEMsZUFBSyxZQUFMLENBQWtCLElBQWxCLENBQXVCLFVBQXZCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsZUFBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixVQUFoQjtBQUNEO0FBQ0QsYUFBSyxPQUFMLENBQWEsVUFBYixFQUF5QjtBQUN2QixtQkFBUyxVQURjO0FBRXZCLGtCQUFRLFdBQVc7QUFGSSxTQUF6QjtBQUlELE9BWEQsTUFXTztBQUNMLGVBQU8sSUFBUCxpQ0FBMEMsV0FBVyxNQUFyRCxzREFBOEcsV0FBVyxRQUFYLEVBQTlHO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLFdBQVcsU0FBWCxLQUF5QixRQUE3QixFQUF1QztBQUNyQyxhQUFLLGNBQUwsQ0FBb0IsVUFBcEI7QUFDRDs7QUFFRCxXQUFLLG1CQUFMLENBQXlCLFVBQXpCO0FBQ0Q7Ozt3Q0FFbUIsVSxFQUFZO0FBQUE7O0FBQzlCO0FBQ0EsVUFBSSxLQUFLLEtBQUwsQ0FBVyxNQUFYLElBQXFCLENBQUMsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLFFBQXhDLEVBQWtEO0FBQ2hELFlBQUksVUFBSixFQUFnQjtBQUNkLGVBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsZUFBdEIsQ0FBc0MsQ0FBQyxVQUFELENBQXRDLEVBQW9EO0FBQUEsbUJBQU0sT0FBSywyQkFBTCxFQUFOO0FBQUEsV0FBcEQ7QUFDRCxTQUZELE1BRU87QUFDTCxlQUFLLDJCQUFMO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLFVBQUksS0FBSyxZQUFMLENBQWtCLE1BQXRCLEVBQThCO0FBQzVCLGFBQUssMEJBQUw7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7dUNBWW1CLFUsRUFBWTtBQUM3QixhQUFPLFFBQVEsS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQjtBQUFBLGVBQy9CLElBQUksTUFBSixLQUFlLFdBQVcsTUFBMUIsSUFBb0MsSUFBSSxTQUFKLEtBQWtCLE1BQXRELElBQWdFLENBQUMsSUFBSSxRQUR0QztBQUFBLE9BQWxCLEVBQ2tFLE1BRDFFLENBQVA7QUFHRDs7QUFFRDs7Ozs7Ozs7Ozs7O2tEQVM4QjtBQUFBOztBQUM1QixVQUFJLEtBQUssV0FBTCxJQUFvQixDQUFDLEtBQUssTUFBTCxDQUFZLGVBQXJDLEVBQXNEO0FBQ3RELFVBQU0sYUFBYSxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQW5CO0FBQ0EsVUFBSSxLQUFLLFFBQUwsTUFBbUIsVUFBbkIsSUFBaUMsQ0FBQyxXQUFXLFFBQTdDLElBQXlELENBQUMsV0FBVyxhQUF6RSxFQUF3RjtBQUN0RixtQkFBVyxhQUFYLEdBQTJCLElBQTNCO0FBQ0EsYUFBSyxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxVQUFDLE9BQUQsRUFBYTtBQUM3QyxxQkFBVyxhQUFYLEdBQTJCLEtBQTNCO0FBQ0EsY0FBSSxDQUFDLE9BQUwsRUFBYztBQUNaLG1CQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsS0FBaEM7QUFDQSxtQkFBTyxPQUFLLDJCQUFMLEVBQVA7QUFDRCxXQUhELE1BR087QUFDTCxtQkFBSyxZQUFMLENBQWtCLFVBQWxCO0FBQ0Q7QUFDRixTQVJEO0FBU0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7O2lEQVM2QjtBQUFBOztBQUMzQixVQUFJLGlCQUFpQixDQUFyQjtBQUNBLFdBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixVQUFDLFVBQUQsRUFBZ0I7QUFDeEMsWUFBSSxPQUFLLFFBQUwsTUFBbUIsVUFBdkIsRUFBbUM7QUFDakMsY0FBSSxXQUFXLFFBQVgsSUFBdUIsV0FBVyxhQUF0QyxFQUFxRDtBQUNuRDtBQUNELFdBRkQsTUFFTyxJQUFJLGlCQUFpQix1QkFBckIsRUFBOEM7QUFDbkQ7QUFDQSxtQkFBSyxZQUFMLENBQWtCLFVBQWxCO0FBQ0Q7QUFDRjtBQUNGLE9BVEQ7QUFVRDs7QUFFRDs7Ozs7Ozs7Ozs7OztpQ0FVYSxVLEVBQVk7QUFDdkIsVUFBSSxzQkFBc0Isa0JBQTFCLEVBQThDO0FBQzVDLGFBQUsscUJBQUwsQ0FBMkIsVUFBM0I7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLLGVBQUwsQ0FBcUIsVUFBckI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7O29DQU9nQixVLEVBQVk7QUFBQTs7QUFDMUIsaUJBQVcsUUFBWCxHQUFzQixJQUF0QjtBQUNBLFVBQUksQ0FBQyxXQUFXLE9BQWhCLEVBQXlCLFdBQVcsT0FBWCxHQUFxQixFQUFyQjtBQUN6QixpQkFBVyxPQUFYLENBQW1CLGFBQW5CLEdBQW1DLDBCQUEwQixLQUFLLE1BQUwsQ0FBWSxZQUF0QyxHQUFxRCxHQUF4RjtBQUNBLGFBQU8sSUFBUCxzQ0FBK0MsV0FBVyxTQUExRCxTQUF1RSxXQUFXLE1BQWxGLFlBQStGLElBQUksSUFBSixHQUFXLFdBQVgsRUFBL0YsRUFDRSxXQUFXLFFBQVgsRUFERjtBQUVBLFVBQUksV0FBVyxlQUFYLENBQTJCLEtBQUssTUFBaEMsQ0FBSixFQUE2QztBQUFBLGVBQVUsT0FBSyxVQUFMLENBQWdCLE1BQWhCLEVBQXdCLFVBQXhCLENBQVY7QUFBQSxPQUE3QztBQUNEOztBQUVEOzs7Ozs7Ozs7OzBDQU9zQixVLEVBQVk7QUFBQTs7QUFDaEMsVUFBSSxLQUFLLGFBQUwsSUFBc0IsS0FBSyxhQUFMLENBQW1CLE9BQW5CLEVBQTFCLEVBQXdEO0FBQ3RELGVBQU8sS0FBUCw0Q0FBc0QsV0FBVyxTQUFqRSxtQkFBd0YsV0FBVyxNQUFuRyxFQUNFLFdBQVcsUUFBWCxFQURGO0FBRUEsbUJBQVcsUUFBWCxHQUFzQixJQUF0QjtBQUNBLGFBQUssY0FBTCxDQUFvQixXQUFwQixDQUFnQztBQUM5QixnQkFBTSxXQUFXLGVBQVgsQ0FBMkIsS0FBSyxNQUFoQyxDQUR3QjtBQUU5QixvQkFBVTtBQUFBLG1CQUFVLE9BQUssVUFBTCxDQUFnQixNQUFoQixFQUF3QixVQUF4QixDQUFWO0FBQUEsV0FGb0I7QUFHOUIsMEJBQWdCLFdBQVc7QUFIRyxTQUFoQztBQUtELE9BVEQsTUFTTztBQUNMLGVBQU8sS0FBUCxDQUFhLHVEQUFiO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBY2lCLFMsRUFBVyxRLEVBQVU7QUFDcEMsV0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixjQUF0QixDQUFxQyxTQUFyQyxFQUFnRDtBQUFBLGVBQVcsU0FBUyxPQUFULENBQVg7QUFBQSxPQUFoRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OytDQVUyQixNLEVBQVE7QUFDakMsVUFBSSxPQUFPLElBQVAsSUFBZSxPQUFPLElBQVAsQ0FBWSxFQUFaLEtBQW1CLFdBQWxDLElBQ0EsT0FBTyxJQUFQLENBQVksSUFEWixJQUNvQixPQUFPLElBQVAsQ0FBWSxJQUFaLENBQWlCLEVBQWpCLEtBQXdCLE9BQU8sT0FBUCxDQUFlLFlBQWYsRUFEaEQsRUFDK0U7QUFDN0UsZUFBTyxPQUFQLEdBQWlCLElBQWpCO0FBQ0EsZUFBTyxJQUFQLEdBQWMsT0FBTyxJQUFQLENBQVksSUFBMUI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7OzsrQkFRVyxNLEVBQVEsVSxFQUFZO0FBQzdCLFVBQUksS0FBSyxXQUFULEVBQXNCO0FBQ3RCLGFBQU8sT0FBUCxHQUFpQixVQUFqQjtBQUNBLGlCQUFXLFFBQVgsR0FBc0IsS0FBdEI7QUFDQSxXQUFLLDBCQUFMLENBQWdDLE1BQWhDO0FBQ0EsVUFBSSxDQUFDLE9BQU8sT0FBWixFQUFxQjtBQUNuQixhQUFLLFNBQUwsQ0FBZSxNQUFmO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSyxXQUFMLENBQWlCLE1BQWpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7OzttQ0FVZSxNLEVBQVEsVSxFQUFZLFEsRUFBVTtBQUMzQyxVQUFNLFFBQVEsT0FBTyxJQUFQLEdBQWMsT0FBTyxJQUFQLENBQVksRUFBMUIsR0FBK0IsRUFBN0M7QUFDQSxVQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2I7QUFDQTtBQUNBLFlBQUksV0FBVyxtQkFBWCxJQUFrQyxZQUFZLDZCQUFsRCxFQUFpRjtBQUMvRSxpQkFBTyxNQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8sU0FBUDtBQUNEO0FBQ0YsT0FSRCxNQVFPLElBQUksVUFBVSxXQUFkLEVBQTJCO0FBQ2hDLGVBQU8sVUFBUDtBQUNELE9BRk0sTUFFQSxJQUFJLFVBQVUsV0FBZCxFQUEyQjtBQUNoQyxlQUFPLFdBQVAsQ0FEZ0MsQ0FDWjtBQUNyQixPQUZNLE1BRUEsSUFBSSxPQUFPLE1BQVAsS0FBa0IsR0FBbEIsSUFBeUIsVUFBVSxpQkFBdkMsRUFBMEQ7QUFDL0QsWUFBSSxXQUFXLFVBQVgsSUFBeUIsWUFBWSxXQUF6QyxFQUFzRDtBQUNwRCxpQkFBTyw0QkFBUDtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPLHdCQUFQO0FBQ0Q7QUFDRixPQU5NLE1BTUEsSUFBSSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixPQUFoQixDQUF3QixPQUFPLE1BQS9CLE1BQTJDLENBQUMsQ0FBaEQsRUFBbUQ7QUFDeEQsWUFBSSxXQUFXLFVBQVgsSUFBeUIsWUFBWSxXQUF6QyxFQUFzRDtBQUNwRCxpQkFBTyw0QkFBUDtBQUNELFNBRkQsTUFFTztBQUNMLGlCQUFPLG1CQUFQO0FBQ0Q7QUFDRixPQU5NLE1BTUEsSUFBSSxVQUFVLHlCQUFWLElBQXVDLE9BQU8sSUFBUCxDQUFZLElBQW5ELElBQTJELE9BQU8sSUFBUCxDQUFZLElBQVosQ0FBaUIsS0FBaEYsRUFBdUY7QUFDNUYsZUFBTyxhQUFQO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsZUFBTyx1QkFBUDtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs4QkFZVSxNLEVBQVE7QUFDaEIsVUFBTSxhQUFhLE9BQU8sT0FBMUI7O0FBRUEsYUFBTyxJQUFQLENBQVksbUJBQWdCLHNCQUFzQixrQkFBdEIsR0FBMkMsV0FBM0MsR0FBeUQsS0FBekUsV0FDUCxXQUFXLFNBREosMkJBQ21DLFdBQVcsTUFEOUMsaUJBQVosRUFDK0UsV0FBVyxRQUFYLEVBRC9FOztBQUlBLFVBQU0sV0FBVyxLQUFLLGNBQUwsQ0FBb0IsTUFBcEIsRUFBNEIsVUFBNUIsRUFBd0MsS0FBSyxRQUFMLEVBQXhDLENBQWpCO0FBQ0EsYUFBTyxJQUFQLENBQVksK0JBQStCLFFBQTNDO0FBQ0EsY0FBUSxRQUFSO0FBQ0UsYUFBSyw0QkFBTDtBQUNFLGVBQUsscUJBQUwsQ0FBMkIsTUFBM0IsRUFBbUMsNERBQW5DLEVBQWlHLEtBQWpHO0FBQ0E7QUFDRixhQUFLLFVBQUw7QUFDRSxlQUFLLHFCQUFMLENBQTJCLE1BQTNCLEVBQW1DLHdDQUFuQyxFQUE2RSxLQUE3RTtBQUNBO0FBQ0YsYUFBSyxXQUFMO0FBQ0UsZUFBSyxxQkFBTCxDQUEyQixNQUEzQixFQUFtQyxtQ0FBbkMsRUFBd0UsS0FBeEU7QUFDQTtBQUNGLGFBQUssd0JBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQSxlQUFLLGdDQUFMLENBQXNDLE1BQXRDO0FBQ0E7QUFDRixhQUFLLG1CQUFMO0FBQ0U7QUFDQTtBQUNBLGVBQUssZ0NBQUwsQ0FBc0MsTUFBdEM7QUFDQTtBQUNGLGFBQUssYUFBTDtBQUNFO0FBQ0E7QUFDQTtBQUNBLGNBQUksV0FBVyxRQUFmLEVBQXlCLFdBQVcsUUFBWCxDQUFvQixNQUFwQjs7QUFFekI7QUFDRixhQUFLLHVCQUFMO0FBQ0U7QUFDQTtBQUNBO0FBQ0EsZUFBSyxxQkFBTCxDQUEyQixNQUEzQixFQUFtQyx1REFBbkMsRUFBNEYsSUFBNUY7QUFDQTtBQUNGLGFBQUssTUFBTDtBQUNFO0FBQ0EsZUFBSyxxQkFBTCxDQUEyQixNQUEzQixFQUFtQyxnRUFBbkMsRUFBcUcsS0FBckc7QUFDQTtBQUNGLGFBQUssU0FBTDtBQUNFLGVBQUsseUJBQUw7QUFDQTtBQXhDSjs7QUEyQ0E7QUFDQSxVQUFJLEtBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUIsVUFBbkIsTUFBbUMsQ0FBQyxDQUFwQyxJQUF5QyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEIsVUFBMUIsTUFBMEMsQ0FBQyxDQUF4RixFQUEyRjtBQUN6RixhQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLGVBQXRCLENBQXNDLENBQUMsVUFBRCxDQUF0QztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztxREFlaUMsTSxFQUFRO0FBQ3ZDLFVBQUksVUFBVSxPQUFPLE9BQXJCO0FBQ0EsV0FBSyxPQUFMLENBQWEsdUJBQWIsRUFBc0M7QUFDcEMsZ0JBQVEsUUFBUSxNQURvQjtBQUVwQyxpQkFBUyxPQUYyQjtBQUdwQyxlQUFPLE9BQU8sSUFIc0I7QUFJcEMsb0JBQVksUUFBUTtBQUpnQixPQUF0QztBQU1BLFVBQU0sV0FBVyxZQUFZLDBCQUE3QjtBQUNBLFVBQU0sUUFBUSxNQUFNLDRCQUFOLENBQW1DLFFBQW5DLEVBQTZDLEtBQUssR0FBTCxDQUFTLEVBQVQsRUFBYSxRQUFRLFVBQVIsRUFBYixDQUE3QyxDQUFkO0FBQ0EsYUFBTyxJQUFQLG1EQUE0RCxRQUFRLFVBQXBFLHNCQUErRixLQUEvRjtBQUNBLGlCQUFXLEtBQUssbUJBQUwsQ0FBeUIsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBWCxFQUFnRCxRQUFRLElBQXhEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBbUJzQixNLEVBQVEsTSxFQUFRLFMsRUFBVztBQUMvQztBQUNBLFVBQUksT0FBTyxPQUFQLENBQWUsUUFBbkIsRUFBNkIsT0FBTyxPQUFQLENBQWUsUUFBZixDQUF3QixNQUF4QjtBQUM3QixVQUFJLFNBQUosRUFBZTtBQUNiLGVBQU8sS0FBUCxDQUFhLFNBQ1gsYUFEVyxHQUNLLEtBQUssU0FBTCxDQUFlLE9BQU8sT0FBUCxDQUFlLFFBQWYsRUFBZixFQUEwQyxJQUExQyxFQUFnRCxDQUFoRCxDQURMLEdBRVgsY0FGVyxHQUVNLEtBQUssU0FBTCxDQUFlLE9BQU8sSUFBdEIsRUFBNEIsSUFBNUIsRUFBa0MsQ0FBbEMsQ0FGbkI7QUFHRCxPQUpELE1BSU87QUFDTCxlQUFPLEtBQVAsQ0FBYSxNQUFiLEVBQXFCLE1BQXJCO0FBQ0Q7QUFDRCxXQUFLLE9BQUwsQ0FBYSxZQUFiLEVBQTJCO0FBQ3pCLGdCQUFRLE9BQU8sT0FBUCxDQUFlLE1BREU7QUFFekIsaUJBQVMsT0FBTyxPQUZTO0FBR3pCLGVBQU8sT0FBTztBQUhXLE9BQTNCOztBQU1BLGFBQU8sT0FBUCxDQUFlLE9BQWYsR0FBeUIsS0FBekI7O0FBRUE7QUFDQTtBQUNBLFVBQUksT0FBTyxPQUFQLENBQWUsU0FBZixLQUE2QixNQUFqQyxFQUF5QztBQUN2QyxhQUFLLHVCQUFMLENBQTZCLE9BQU8sT0FBcEM7QUFDRDs7QUFFRDtBQUNBLFdBQUssY0FBTCxDQUFvQixPQUFPLE9BQTNCLEVBQW9DLElBQXBDOztBQUVBO0FBQ0EsV0FBSyxtQkFBTDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Z0RBUzRCLENBRzNCO0FBRkM7QUFDQTs7O0FBR0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FlcUIsVSxFQUFZO0FBQUE7O0FBQy9CLGFBQU8sS0FBUCxDQUFhLHFDQUFiO0FBQ0EsV0FBSyxhQUFMLENBQW1CLGlCQUFuQixDQUFxQztBQUFBLGVBQVksT0FBSyw0QkFBTCxDQUFrQyxRQUFsQyxFQUE0QyxVQUE1QyxDQUFaO0FBQUEsT0FBckM7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQWU2QixRLEVBQVUsVSxFQUFZO0FBQ2pELGFBQU8sS0FBUCxDQUFhLHlDQUF5QyxRQUF0RDtBQUNBLFVBQUksQ0FBQyxRQUFMLEVBQWU7QUFDYjtBQUNBLGFBQUsseUJBQUw7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBO0FBQ0EsbUJBQVcsVUFBWDtBQUNBLGFBQUssbUJBQUw7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztnQ0FjWSxNLEVBQVE7QUFDbEIsVUFBTSxhQUFhLE9BQU8sT0FBMUI7QUFDQSxhQUFPLEtBQVAsQ0FBYSxtQkFBZ0Isc0JBQXNCLGtCQUF0QixHQUEyQyxXQUEzQyxHQUF5RCxLQUF6RSxXQUNSLFdBQVcsU0FESCwyQkFDa0MsV0FBVyxNQUQ3QyxvQkFBYixFQUNrRixXQUFXLFFBQVgsRUFEbEY7QUFFQSxVQUFJLE9BQU8sSUFBWCxFQUFpQixPQUFPLEtBQVAsQ0FBYSxPQUFPLElBQXBCO0FBQ2pCLGlCQUFXLE9BQVgsR0FBcUIsSUFBckI7QUFDQSxXQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsSUFBaEM7QUFDQSxVQUFJLFdBQVcsUUFBZixFQUF5QixXQUFXLFFBQVgsQ0FBb0IsTUFBcEI7QUFDekIsV0FBSyxtQkFBTDs7QUFFQSxXQUFLLE9BQUwsQ0FBYSxjQUFiLEVBQTZCO0FBQzNCLGdCQUFRLFdBQVcsTUFEUTtBQUUzQixpQkFBUyxVQUZrQjtBQUczQixrQkFBVSxPQUFPO0FBSFUsT0FBN0I7QUFLRDs7QUFFRDs7Ozs7Ozs7Ozs7bUNBUWUsVSxFQUFZLFEsRUFBVTtBQUNuQyxVQUFNLFFBQVEsV0FBVyxTQUFYLEtBQXlCLFNBQXpCLEdBQXFDLEtBQUssWUFBMUMsR0FBeUQsS0FBSyxLQUE1RTtBQUNBLFVBQU0sUUFBUSxNQUFNLE9BQU4sQ0FBYyxVQUFkLENBQWQ7QUFDQSxVQUFJLFVBQVUsQ0FBQyxDQUFmLEVBQWtCLE1BQU0sTUFBTixDQUFhLEtBQWIsRUFBb0IsQ0FBcEI7QUFDbEIsVUFBSSxRQUFKLEVBQWMsS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixhQUF0QixDQUFvQyxXQUFwQyxFQUFpRCxDQUFDLFVBQUQsQ0FBakQ7QUFDZjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7NENBY3dCLE8sRUFBUztBQUMvQixXQUFLLEtBQUwsR0FBYSxLQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCO0FBQUEsZUFBTyxJQUFJLE9BQUosQ0FBWSxPQUFaLENBQW9CLFFBQVEsTUFBNUIsTUFBd0MsQ0FBQyxDQUF6QyxJQUE4QyxRQUFRLE9BQTdEO0FBQUEsT0FBbEIsQ0FBYjtBQUNBLFdBQUssWUFBTCxHQUFvQixLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBeUI7QUFBQSxlQUFPLElBQUksT0FBSixDQUFZLE9BQVosQ0FBb0IsUUFBUSxNQUE1QixNQUF3QyxDQUFDLENBQXpDLElBQThDLFFBQVEsT0FBN0Q7QUFBQSxPQUF6QixDQUFwQjtBQUNEOztBQUdEOzs7Ozs7Ozs7O21DQU9lLEcsRUFBSztBQUFBOztBQUNsQixXQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCO0FBQUEsZUFBVyxRQUFRLE9BQVIsQ0FBZ0IsT0FBaEIsQ0FBd0IsSUFBSSxNQUE1QixNQUF3QyxDQUFDLENBQXpDLElBQThDLFFBQVEsT0FBakU7QUFBQSxPQUFsQixFQUNHLE9BREgsQ0FDVyxVQUFDLFVBQUQsRUFBZ0I7QUFDdkIsZUFBSyxPQUFMLENBQWEsWUFBYixFQUEyQjtBQUN6QixrQkFBUSxXQUFXLE1BRE07QUFFekIsbUJBQVM7QUFGZ0IsU0FBM0I7QUFJQSxlQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsSUFBaEM7QUFDRCxPQVBIO0FBUUQ7Ozs4QkFHUztBQUNSLFdBQUssS0FBTCxDQUFXLE9BQVgsQ0FBbUI7QUFBQSxlQUFPLElBQUksT0FBSixFQUFQO0FBQUEsT0FBbkI7QUFDQSxXQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsV0FBSyxZQUFMLENBQWtCLE9BQWxCLENBQTBCO0FBQUEsZUFBTyxJQUFJLE9BQUosRUFBUDtBQUFBLE9BQTFCO0FBQ0EsV0FBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7MENBUXNCO0FBQUE7O0FBQ3BCLFdBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsYUFBdEIsQ0FBb0MsVUFBQyxJQUFELEVBQVU7QUFDNUMsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixrQkFBSyxLQUFMLEdBQWEsUUFBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixJQUFsQixDQUFiO0FBQ0Esa0JBQUssbUJBQUw7QUFDRDtBQUNGLE9BTEQ7QUFNRDs7OztFQXRxQnVCLEk7O0FBeXFCMUI7Ozs7OztBQUlBLFlBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxJQUF0Qzs7QUFFQTs7OztBQUlBLFlBQVksU0FBWixDQUFzQixjQUF0QixHQUF1QyxJQUF2Qzs7QUFFQTs7Ozs7OztBQU9BLFlBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxJQUF0Qzs7QUFFQTs7OztBQUlBLFlBQVksU0FBWixDQUFzQixLQUF0QixHQUE4QixJQUE5Qjs7QUFFQTs7Ozs7O0FBTUEsWUFBWSxTQUFaLENBQXNCLFlBQXRCLEdBQXFDLElBQXJDOztBQUVBOzs7QUFHQSxZQUFZLFNBQVosQ0FBc0IsTUFBdEIsR0FBK0IsSUFBL0I7O0FBRUE7Ozs7Ozs7O0FBUUEsWUFBWSwwQkFBWixHQUF5QyxFQUF6Qzs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLFlBQVksNkJBQVosR0FBNEMsQ0FBNUM7O0FBRUE7Ozs7OztBQU1BLFlBQVksV0FBWixHQUEwQixFQUExQjs7QUFHQSxZQUFZLGdCQUFaLEdBQStCO0FBQzdCOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFlBakI2Qjs7QUFtQjdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsdUJBckM2Qjs7QUF1QzdCOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxjQXhENkI7O0FBMEQ3Qjs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsVUF6RTZCOztBQTJFN0I7Ozs7Ozs7Ozs7QUFVQSxZQXJGNkIsRUFzRjdCLE1BdEY2QixDQXNGdEIsS0FBSyxnQkF0RmlCLENBQS9COztBQXdGQSxLQUFLLFNBQUwsQ0FBZSxXQUFmO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLFdBQWpCIiwiZmlsZSI6InN5bmMtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGNsYXNzICBsYXllci5TeW5jTWFuYWdlclxuICogQGV4dGVuZHMgbGF5ZXIuUm9vdFxuICogQHByb3RlY3RlZFxuICpcbiAqIFRoaXMgY2xhc3MgbWFuYWdlc1xuICpcbiAqIDEuIGEgcXVldWUgb2YgcmVxdWVzdHMgdGhhdCBuZWVkIHRvIGJlIG1hZGVcbiAqIDIuIHdoZW4gYSByZXF1ZXN0IHNob3VsZCBiZSBmaXJlZCwgYmFzZWQgb24gYXV0aGVudGljYXRpb24gc3RhdGUsIG9ubGluZSBzdGF0ZSwgd2Vic29ja2V0IGNvbm5lY3Rpb24gc3RhdGUsIGFuZCBwb3NpdGlvbiBpbiB0aGUgcXVldWVcbiAqIDMuIHdoZW4gYSByZXF1ZXN0IHNob3VsZCBiZSBhYm9ydGVkXG4gKiA0LiB0cmlnZ2VyaW5nIGFueSByZXF1ZXN0IGNhbGxiYWNrc1xuICpcbiAqIFRPRE86IEluIHRoZSBldmVudCBvZiBhIEROUyBlcnJvciwgd2UgbWF5IGhhdmUgYSB2YWxpZCB3ZWJzb2NrZXQgcmVjZWl2aW5nIGV2ZW50cyBhbmQgdGVsbGluZyB1cyB3ZSBhcmUgb25saW5lLFxuICogYW5kIGJlIHVuYWJsZSB0byBjcmVhdGUgYSBSRVNUIGNhbGwuICBUaGlzIHdpbGwgYmUgaGFuZGxlZCB3cm9uZyBiZWNhdXNlIGV2aWRlbmNlIHdpbGwgc3VnZ2VzdCB0aGF0IHdlIGFyZSBvbmxpbmUuXG4gKiBUaGlzIGlzc3VlIGdvZXMgYXdheSB3aGVuIHdlIHVzZSBiaWRpcmVjdGlvbmFsIHdlYnNvY2tldHMgZm9yIGFsbCByZXF1ZXN0cy5cbiAqXG4gKiBBcHBsaWNhdGlvbnMgZG8gbm90IHR5cGljYWxseSBpbnRlcmFjdCB3aXRoIHRoaXMgY2xhc3MsIGJ1dCBtYXkgc3Vic2NyaWJlIHRvIGl0cyBldmVudHNcbiAqIHRvIGdldCByaWNoZXIgZGV0YWlsZWQgaW5mb3JtYXRpb24gdGhhbiBpcyBhdmFpbGFibGUgZnJvbSB0aGUgbGF5ZXIuQ2xpZW50IGluc3RhbmNlLlxuICovXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCB7IFdlYnNvY2tldFN5bmNFdmVudCB9ID0gcmVxdWlyZSgnLi9zeW5jLWV2ZW50Jyk7XG5jb25zdCB4aHIgPSByZXF1aXJlKCcuL3hocicpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcblxuY29uc3QgTUFYX1JFQ0VJUFRfQ09OTkVDVElPTlMgPSA0O1xuXG5jbGFzcyBTeW5jTWFuYWdlciBleHRlbmRzIFJvb3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTeW5jTWFuYWdlci5cbiAgICpcbiAgICogQW4gQXBwbGljYXRpb24gaXMgZXhwZWN0ZWQgdG8gb25seSBoYXZlIG9uZSBTeW5jTWFuYWdlci5cbiAgICpcbiAgICogICAgICB2YXIgc29ja2V0TWFuYWdlciA9IG5ldyBsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXIoe2NsaWVudDogY2xpZW50fSk7XG4gICAqICAgICAgdmFyIHJlcXVlc3RNYW5hZ2VyID0gbmV3IGxheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXIoe2NsaWVudDogY2xpZW50LCBzb2NrZXRNYW5hZ2VyOiBzb2NrZXRNYW5hZ2VyfSk7XG4gICAqXG4gICAqICAgICAgdmFyIG9ubGluZU1hbmFnZXIgPSBuZXcgbGF5ZXIuT25saW5lTWFuYWdlcih7XG4gICAqICAgICAgICAgIHNvY2tldE1hbmFnZXI6IHNvY2tldE1hbmFnZXJcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogICAgICAvLyBOb3cgd2UgY2FuIGluc3RhbnRpYXRlIHRoaXMgdGhpbmcuLi5cbiAgICogICAgICB2YXIgU3luY01hbmFnZXIgPSBuZXcgbGF5ZXIuU3luY01hbmFnZXIoe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICAgICAgb25saW5lTWFuYWdlcjogb25saW5lTWFuYWdlcixcbiAgICogICAgICAgICAgc29ja2V0TWFuYWdlcjogc29ja2V0TWFuYWdlcixcbiAgICogICAgICAgICAgcmVxdWVzdE1hbmFnZXI6IHJlcXVlc3RNYW5hZ2VyXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bGF5ZXIuT25saW5lU3RhdGVNYW5hZ2VyfSBvcHRpb25zLm9ubGluZU1hbmFnZXJcbiAgICogQHBhcmFtIHtsYXllci5XZWJzb2NrZXRzLlJlcXVlc3RNYW5hZ2VyfSBvcHRpb25zLnJlcXVlc3RNYW5hZ2VyXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBvcHRpb25zLmNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG5cbiAgICAvLyBOb3RlIHdlIGRvIG5vdCBzdG9yZSBhIHBvaW50ZXIgdG8gY2xpZW50Li4uIGl0IGlzIG5vdCBuZWVkZWQuXG4gICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICB0aGlzLmNsaWVudC5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NOZXh0UmVxdWVzdCgpO1xuICAgICAgICB0aGlzLl9sb2FkUGVyc2lzdGVkUXVldWUoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5yZWNlaXB0UXVldWUgPSBbXTtcblxuICAgIC8vIFJhdGhlciB0aGFuIGxpc3RlbiBmb3Igb25saW5lTWFuYWdlciAnY29ubmVjdGVkJywgbGV0IHRoZSBzb2NrZXRNYW5hZ2VyIGxpc3RlbiBmb3IgdGhhdCwgY29ubmVjdCwgYW5kIHRoZSBzeW5jTWFuYWdlclxuICAgIC8vIHdhaXRzIHVudGlsIGl0cyBhY3R1YWxseSBjb25uZWN0ZWRcbiAgICB0aGlzLm9ubGluZU1hbmFnZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIHRoaXMuX29ubGluZVN0YXRlQ2hhbmdlLCB0aGlzKTtcbiAgICB0aGlzLnNvY2tldE1hbmFnZXIub24oJ2Nvbm5lY3RlZCBkaXNjb25uZWN0ZWQnLCB0aGlzLl9vbmxpbmVTdGF0ZUNoYW5nZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBDbGllbnQgaXMgb25saW5lL29mZmxpbmUuXG4gICAqXG4gICAqIEZvciBpbnRlcm5hbCB1c2U7IGFwcGxpY2F0aW9ucyBzaG91bGQgdXNlIGxheWVyLkNsaWVudC5pc09ubGluZS5cbiAgICpcbiAgICogQG1ldGhvZCBpc09ubGluZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT25saW5lKCkge1xuICAgIHJldHVybiB0aGlzLm9ubGluZU1hbmFnZXIuaXNPbmxpbmU7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBzeW5jIHJlcXVlc3Qgd2hlbiBjb25uZWN0aW9uIGlzIHJlc3RvcmVkLlxuICAgKlxuICAgKiBBbnkgdGltZSB3ZSBnbyBiYWNrIG9ubGluZSAoYXMgc2lnbmFsZWQgYnkgdGhlIG9ubGluZVN0YXRlTWFuYWdlciksXG4gICAqIFByb2Nlc3MgdGhlIG5leHQgU3luYyBFdmVudCAod2lsbCBkbyBub3RoaW5nIGlmIG9uZSBpcyBhbHJlYWR5IGZpcmluZylcbiAgICpcbiAgICogQG1ldGhvZCBfb25saW5lU3RhdGVDaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSBldnROYW1lIC0gJ2Nvbm5lY3RlZCcgb3IgJ2Rpc2Nvbm5lY3RlZCdcbiAgICogQHBhcmFtICB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICBfb25saW5lU3RhdGVDaGFuZ2UoZXZ0KSB7XG4gICAgaWYgKGV2dC5ldmVudE5hbWUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHRoaXMucXVldWVbMF0ucmV0dXJuVG9PbmxpbmVDb3VudCsrO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QoKSwgMTAwKTtcbiAgICB9IGVsc2UgaWYgKGV2dC5ldmVudE5hbWUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVswXS5pc0ZpcmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVjZWlwdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlY2VpcHRRdWV1ZS5mb3JFYWNoKHN5bmNFdnQgPT4gKHN5bmNFdnQuaXNGaXJpbmcgPSBmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHhociByZXF1ZXN0IHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogSWYgdGhlIHF1ZXVlIGlzIGVtcHR5LCB0aGlzIHdpbGwgYmUgZmlyZWQgaW1tZWRpYXRlbHk7IGVsc2UgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYW5kIHdhaXQgaXRzIHR1cm4uXG4gICAqXG4gICAqIElmIGl0cyBhIHJlYWQvZGVsaXZlcnkgcmVjZWlwdCByZXF1ZXN0LCBpdCB3aWxsIHR5cGljYWxseSBiZSBmaXJlZCBpbW1lZGlhdGVseSB1bmxlc3MgdGhlcmUgYXJlIG1hbnkgcmVjZWlwdFxuICAgKiByZXF1ZXN0cyBhbHJlYWR5IGluLWZsaWdodC5cbiAgICpcbiAgICogQG1ldGhvZCByZXF1ZXN0XG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIEEgU3luY0V2ZW50IHNwZWNpZnlpbmcgdGhlIHJlcXVlc3QgdG8gYmUgbWFkZVxuICAgKi9cbiAgcmVxdWVzdChyZXF1ZXN0RXZ0KSB7XG4gICAgLy8gSWYgaXRzIGEgUEFUQ0ggcmVxdWVzdCBvbiBhbiBvYmplY3QgdGhhdCBpc24ndCB5ZXQgY3JlYXRlZCxcbiAgICAvLyBkbyBub3QgYWRkIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICBpZiAocmVxdWVzdEV2dC5vcGVyYXRpb24gIT09ICdQQVRDSCcgfHwgIXRoaXMuX2ZpbmRVbmZpcmVkQ3JlYXRlKHJlcXVlc3RFdnQpKSB7XG4gICAgICBsb2dnZXIuaW5mbyhgU3luYyBNYW5hZ2VyIFJlcXVlc3QgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gb24gdGFyZ2V0ICR7cmVxdWVzdEV2dC50YXJnZXR9YCwgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICAgIGlmIChyZXF1ZXN0RXZ0Lm9wZXJhdGlvbiA9PT0gJ1JFQ0VJUFQnKSB7XG4gICAgICAgIHRoaXMucmVjZWlwdFF1ZXVlLnB1c2gocmVxdWVzdEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocmVxdWVzdEV2dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIoJ3N5bmM6YWRkJywge1xuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0RXZ0LFxuICAgICAgICB0YXJnZXQ6IHJlcXVlc3RFdnQudGFyZ2V0LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5pbmZvKGBTeW5jIE1hbmFnZXIgUmVxdWVzdCBQQVRDSCAke3JlcXVlc3RFdnQudGFyZ2V0fSByZXF1ZXN0IGlnbm9yZWQ7IGNyZWF0ZSByZXF1ZXN0IHN0aWxsIGVucXVldWVkYCwgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICB9XG5cbiAgICAvLyBJZiBpdHMgYSBERUxFVEUgcmVxdWVzdCwgcHVyZ2UgYWxsIG90aGVyIHJlcXVlc3RzIG9uIHRoYXQgdGFyZ2V0LlxuICAgIGlmIChyZXF1ZXN0RXZ0Lm9wZXJhdGlvbiA9PT0gJ0RFTEVURScpIHtcbiAgICAgIHRoaXMuX3B1cmdlT25EZWxldGUocmVxdWVzdEV2dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KHJlcXVlc3RFdnQpO1xuICB9XG5cbiAgX3Byb2Nlc3NOZXh0UmVxdWVzdChyZXF1ZXN0RXZ0KSB7XG4gICAgLy8gRmlyZSB0aGUgcmVxdWVzdCBpZiB0aGVyZSBhcmVuJ3QgYW55IGV4aXN0aW5nIHJlcXVlc3RzIGFscmVhZHkgZmlyaW5nXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoICYmICF0aGlzLnF1ZXVlWzBdLmlzRmlyaW5nKSB7XG4gICAgICBpZiAocmVxdWVzdEV2dCkge1xuICAgICAgICB0aGlzLmNsaWVudC5kYk1hbmFnZXIud3JpdGVTeW5jRXZlbnRzKFtyZXF1ZXN0RXZ0XSwgKCkgPT4gdGhpcy5fcHJvY2Vzc05leHRTdGFuZGFyZFJlcXVlc3QoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9jZXNzTmV4dFN0YW5kYXJkUmVxdWVzdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgYW55dGhpbmcgaW4gdGhlIHJlY2VpcHRzIHF1ZXVlLCBmaXJlIGl0XG4gICAgaWYgKHRoaXMucmVjZWlwdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcHJvY2Vzc05leHRSZWNlaXB0UmVxdWVzdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGNyZWF0ZSByZXF1ZXN0IGZvciB0aGlzIHJlc291cmNlLlxuICAgKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIHRhcmdldCBoYXMgYSBQT1NUIHJlcXVlc3Qgd2FpdGluZyB0byBjcmVhdGVcbiAgICogdGhlIHJlc291cmNlLCBhbmQgcmV0dXJuIGFueSBtYXRjaGluZyByZXF1ZXN0cy4gVXNlZFxuICAgKiBmb3IgZm9sZGluZyBQQVRDSCByZXF1ZXN0cyBpbnRvIGFuIHVuZmlyZWQgQ1JFQVRFL1BPU1QgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBfZmluZFVuZmlyZWRDcmVhdGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBfZmluZFVuZmlyZWRDcmVhdGUocmVxdWVzdEV2dCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMucXVldWUuZmlsdGVyKGV2dCA9PlxuICAgICAgZXZ0LnRhcmdldCA9PT0gcmVxdWVzdEV2dC50YXJnZXQgJiYgZXZ0Lm9wZXJhdGlvbiA9PT0gJ1BPU1QnICYmICFldnQuaXNGaXJpbmcpLmxlbmd0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgbmV4dCByZXF1ZXN0IGluIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogUmVxdWVzdCBpcyBkZXF1ZXVlZCBvbiBjb21wbGV0aW5nIHRoZSBwcm9jZXNzLlxuICAgKiBJZiB0aGUgZmlyc3QgcmVxdWVzdCBpbiB0aGUgcXVldWUgaXMgZmlyaW5nLCBkbyBub3RoaW5nLlxuICAgKlxuICAgKiBAbWV0aG9kIF9wcm9jZXNzTmV4dFJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzTmV4dFN0YW5kYXJkUmVxdWVzdCgpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCB8fCAhdGhpcy5jbGllbnQuaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgY29uc3QgcmVxdWVzdEV2dCA9IHRoaXMucXVldWVbMF07XG4gICAgaWYgKHRoaXMuaXNPbmxpbmUoKSAmJiByZXF1ZXN0RXZ0ICYmICFyZXF1ZXN0RXZ0LmlzRmlyaW5nICYmICFyZXF1ZXN0RXZ0Ll9pc1ZhbGlkYXRpbmcpIHtcbiAgICAgIHJlcXVlc3RFdnQuX2lzVmFsaWRhdGluZyA9IHRydWU7XG4gICAgICB0aGlzLl92YWxpZGF0ZVJlcXVlc3QocmVxdWVzdEV2dCwgKGlzVmFsaWQpID0+IHtcbiAgICAgICAgcmVxdWVzdEV2dC5faXNWYWxpZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVJlcXVlc3QocmVxdWVzdEV2dCwgZmFsc2UpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzTmV4dFN0YW5kYXJkUmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2ZpcmVSZXF1ZXN0KHJlcXVlc3RFdnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB1cCB0byBNQVhfUkVDRUlQVF9DT05ORUNUSU9OUyB3b3J0aCBvZiByZWNlaXB0cy5cbiAgICpcbiAgICogVGhlc2UgcmVxdWVzdHMgaGF2ZSBubyBpbnRlcmRlcGVuZGVuY2llcy4gSnVzdCBmaXJlIHRoZW0gYWxsXG4gICAqIGFzIGZhc3QgYXMgd2UgY2FuLCBpbiBwYXJhbGxlbC5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc05leHRSZWNlaXB0UmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NOZXh0UmVjZWlwdFJlcXVlc3QoKSB7XG4gICAgbGV0IGZpcmluZ1JlY2VpcHRzID0gMDtcbiAgICB0aGlzLnJlY2VpcHRRdWV1ZS5mb3JFYWNoKChyZWNlaXB0RXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc09ubGluZSgpICYmIHJlY2VpcHRFdnQpIHtcbiAgICAgICAgaWYgKHJlY2VpcHRFdnQuaXNGaXJpbmcgfHwgcmVjZWlwdEV2dC5faXNWYWxpZGF0aW5nKSB7XG4gICAgICAgICAgZmlyaW5nUmVjZWlwdHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChmaXJpbmdSZWNlaXB0cyA8IE1BWF9SRUNFSVBUX0NPTk5FQ1RJT05TKSB7XG4gICAgICAgICAgZmlyaW5nUmVjZWlwdHMrKztcbiAgICAgICAgICB0aGlzLl9maXJlUmVxdWVzdChyZWNlaXB0RXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpcmVjdGx5IGZpcmUgdGhpcyBzeW5jIHJlcXVlc3QuXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgYWZ0ZXIgY2FyZWZ1bCBhbmFseXNpcyBvZiBvdXIgc3RhdGUgdG8gbWFrZSBzdXJlIGl0cyBzYWZlIHRvIHNlbmQgdGhlIHJlcXVlc3QuXG4gICAqIFNlZSBgX3Byb2Nlc3NOZXh0UmVxdWVzdCgpYFxuICAgKlxuICAgKiBAbWV0aG9kIF9maXJlUmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dFxuICAgKi9cbiAgX2ZpcmVSZXF1ZXN0KHJlcXVlc3RFdnQpIHtcbiAgICBpZiAocmVxdWVzdEV2dCBpbnN0YW5jZW9mIFdlYnNvY2tldFN5bmNFdmVudCkge1xuICAgICAgdGhpcy5fZmlyZVJlcXVlc3RXZWJzb2NrZXQocmVxdWVzdEV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpcmVSZXF1ZXN0WEhSKHJlcXVlc3RFdnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSBmaXJlIHRoaXMgWEhSIFN5bmMgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBfZmlyZVJlcXVlc3RYSFJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnQuWEhSU3luY0V2ZW50fSByZXF1ZXN0RXZ0XG4gICAqL1xuICBfZmlyZVJlcXVlc3RYSFIocmVxdWVzdEV2dCkge1xuICAgIHJlcXVlc3RFdnQuaXNGaXJpbmcgPSB0cnVlO1xuICAgIGlmICghcmVxdWVzdEV2dC5oZWFkZXJzKSByZXF1ZXN0RXZ0LmhlYWRlcnMgPSB7fTtcbiAgICByZXF1ZXN0RXZ0LmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdMYXllciBzZXNzaW9uLXRva2VuPVwiJyArIHRoaXMuY2xpZW50LnNlc3Npb25Ub2tlbiArICdcIic7XG4gICAgbG9nZ2VyLmluZm8oYFN5bmMgTWFuYWdlciBYSFIgUmVxdWVzdCBGaXJpbmcgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gJHtyZXF1ZXN0RXZ0LnRhcmdldH0gYXQgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgIHJlcXVlc3RFdnQudG9PYmplY3QoKSk7XG4gICAgeGhyKHJlcXVlc3RFdnQuX2dldFJlcXVlc3REYXRhKHRoaXMuY2xpZW50KSwgcmVzdWx0ID0+IHRoaXMuX3hoclJlc3VsdChyZXN1bHQsIHJlcXVlc3RFdnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXJlY3RseSBmaXJlIHRoaXMgV2Vic29ja2V0IFN5bmMgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBfZmlyZVJlcXVlc3RXZWJzb2NrZXRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnQuV2Vic29ja2V0U3luY0V2ZW50fSByZXF1ZXN0RXZ0XG4gICAqL1xuICBfZmlyZVJlcXVlc3RXZWJzb2NrZXQocmVxdWVzdEV2dCkge1xuICAgIGlmICh0aGlzLnNvY2tldE1hbmFnZXIgJiYgdGhpcy5zb2NrZXRNYW5hZ2VyLl9pc09wZW4oKSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBTeW5jIE1hbmFnZXIgV2Vic29ja2V0IFJlcXVlc3QgRmlyaW5nICR7cmVxdWVzdEV2dC5vcGVyYXRpb259IG9uIHRhcmdldCAke3JlcXVlc3RFdnQudGFyZ2V0fWAsXG4gICAgICAgIHJlcXVlc3RFdnQudG9PYmplY3QoKSk7XG4gICAgICByZXF1ZXN0RXZ0LmlzRmlyaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc2VuZFJlcXVlc3Qoe1xuICAgICAgICBkYXRhOiByZXF1ZXN0RXZ0Ll9nZXRSZXF1ZXN0RGF0YSh0aGlzLmNsaWVudCksXG4gICAgICAgIGNhbGxiYWNrOiByZXN1bHQgPT4gdGhpcy5feGhyUmVzdWx0KHJlc3VsdCwgcmVxdWVzdEV2dCksXG4gICAgICAgIGlzQ2hhbmdlc0FycmF5OiByZXF1ZXN0RXZ0LnJldHVybkNoYW5nZXNBcnJheSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1N5bmMgTWFuYWdlciBXZWJzb2NrZXQgUmVxdWVzdCBza2lwcGVkOyBzb2NrZXQgY2xvc2VkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBzeW5jRXZlbnQgc3RpbGwgdmFsaWQ/XG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNwZWNpZmljYWxseSB0ZXN0cyB0byBzZWUgaWYgc29tZSBvdGhlciB0YWIgaGFzIGFscmVhZHkgc2VudCB0aGlzIHJlcXVlc3QuXG4gICAqIElmIHBlcnNpc3RlbmNlIG9mIHRoZSBzeW5jUXVldWUgaXMgbm90IGVuYWJsZWQsIHRoZW4gdGhlIGNhbGxiYWNrIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRydWUuXG4gICAqIElmIGFub3RoZXIgdGFiIGhhcyBhbHJlYWR5IHNlbnQgdGhlIHJlcXVlc3QsIHRoZW4gdGhlIGVudHJ5IHdpbGwgbm8gbG9uZ2VyIGJlIGluIGluZGV4ZWREQiBhbmQgdGhlIGNhbGxiYWNrXG4gICAqIHdpbGwgY2FsbCBmYWxzZS5cbiAgICpcbiAgICogQG1ldGhvZCBfdmFsaWRhdGVSZXF1ZXN0XG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50fSBzeW5jRXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2suaXNWYWxpZCAtIFRoZSByZXF1ZXN0IGlzIHN0aWxsIHZhbGlkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdmFsaWRhdGVSZXF1ZXN0KHN5bmNFdmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsaWVudC5kYk1hbmFnZXIuY2xhaW1TeW5jRXZlbnQoc3luY0V2ZW50LCBpc0ZvdW5kID0+IGNhbGxiYWNrKGlzRm91bmQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIGRlZHVwbGljYXRpb24gZXJyb3JzIGludG8gc3VjY2VzcyBtZXNzYWdlcy5cbiAgICpcbiAgICogSWYgdGhpcyByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gbWFkZSBidXQgd2UgZmFpbGVkIHRvIGdldCBhIHJlc3BvbnNlIHRoZSBmaXJzdCB0aW1lIGFuZCB3ZSByZXRyaWVkIHRoZSByZXF1ZXN0LFxuICAgKiB3ZSB3aWxsIHJlaXNzdWUgdGhlIHJlcXVlc3QuICBJZiB0aGUgcHJpb3IgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bCB3ZSdsbCBnZXQgYmFjayBhIGRlZHVwbGljYXRpb24gZXJyb3JcbiAgICogd2l0aCB0aGUgY3JlYXRlZCBvYmplY3QuIEFzIGZhciBhcyB0aGUgV2ViU0RLIGlzIGNvbmNlcm5lZCwgdGhpcyBpcyBhIHN1Y2Nlc3MuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZURlZHVwbGljYXRpb25FcnJvcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVEZWR1cGxpY2F0aW9uRXJyb3JzKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQuZGF0YSAmJiByZXN1bHQuZGF0YS5pZCA9PT0gJ2lkX2luX3VzZScgJiZcbiAgICAgICAgcmVzdWx0LmRhdGEuZGF0YSAmJiByZXN1bHQuZGF0YS5kYXRhLmlkID09PSByZXN1bHQucmVxdWVzdC5fZ2V0Q3JlYXRlSWQoKSkge1xuICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgcmVzdWx0LmRhdGEgPSByZXN1bHQuZGF0YS5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSByZXN1bHQgb2YgYW4geGhyIGNhbGwsIHJvdXRpbmcgaXQgdG8gdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXIuXG4gICAqXG4gICAqIEBtZXRob2QgX3hoclJlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gUmVxdWVzdCBvYmplY3RcbiAgICovXG4gIF94aHJSZXN1bHQocmVzdWx0LCByZXF1ZXN0RXZ0KSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICByZXN1bHQucmVxdWVzdCA9IHJlcXVlc3RFdnQ7XG4gICAgcmVxdWVzdEV2dC5pc0ZpcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2hhbmRsZURlZHVwbGljYXRpb25FcnJvcnMocmVzdWx0KTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICB0aGlzLl94aHJFcnJvcihyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl94aHJTdWNjZXNzKHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhdGVnb3JpemUgdGhlIGVycm9yIGZvciBoYW5kbGluZy5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0RXJyb3JTdGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gUmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gaXNPbmxpbmUgLSBJcyBvdXIgYXBwIHN0YXRlIHNldCB0byBvbmxpbmVcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIF9nZXRFcnJvclN0YXRlKHJlc3VsdCwgcmVxdWVzdEV2dCwgaXNPbmxpbmUpIHtcbiAgICBjb25zdCBlcnJJZCA9IHJlc3VsdC5kYXRhID8gcmVzdWx0LmRhdGEuaWQgOiAnJztcbiAgICBpZiAoIWlzT25saW5lKSB7XG4gICAgICAvLyBDT1JTIGVycm9ycyBsb29rIGlkZW50aWNhbCB0byBvZmZsaW5lOyBidXQgaWYgb3VyIG9ubGluZSBzdGF0ZSBoYXMgdHJhbnNpdGlvbmVkIGZyb20gZmFsc2UgdG8gdHJ1ZSByZXBlYXRlZGx5IHdoaWxlIHByb2Nlc3NpbmcgdGhpcyByZXF1ZXN0LFxuICAgICAgLy8gdGhhdHMgYSBoaW50IHRoYXQgdGhhdCBpdHMgYSBDT1JTIGVycm9yXG4gICAgICBpZiAocmVxdWVzdEV2dC5yZXR1cm5Ub09ubGluZUNvdW50ID49IFN5bmNNYW5hZ2VyLk1BWF9SRVRSSUVTX0JFRk9SRV9DT1JTX0VSUk9SKSB7XG4gICAgICAgIHJldHVybiAnQ09SUyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ29mZmxpbmUnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJySWQgPT09ICdub3RfZm91bmQnKSB7XG4gICAgICByZXR1cm4gJ25vdEZvdW5kJztcbiAgICB9IGVsc2UgaWYgKGVycklkID09PSAnaWRfaW5fdXNlJykge1xuICAgICAgcmV0dXJuICdpbnZhbGlkSWQnOyAvLyBUaGlzIG9ubHkgZmlyZXMgaWYgd2UgZ2V0IGBpZF9pbl91c2VgIGJ1dCBubyBSZXNvdXJjZSwgd2hpY2ggbWVhbnMgdGhlIFVVSUQgd2FzIHVzZWQgYnkgYW5vdGhlciB1c2VyL2FwcC5cbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDQwOCB8fCBlcnJJZCA9PT0gJ3JlcXVlc3RfdGltZW91dCcpIHtcbiAgICAgIGlmIChyZXF1ZXN0RXZ0LnJldHJ5Q291bnQgPj0gU3luY01hbmFnZXIuTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgcmV0dXJuICd0b29NYW55RmFpbHVyZXNXaGlsZU9ubGluZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3ZhbGlkYXRlT25saW5lQW5kUmV0cnknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoWzUwMiwgNTAzLCA1MDRdLmluZGV4T2YocmVzdWx0LnN0YXR1cykgIT09IC0xKSB7XG4gICAgICBpZiAocmVxdWVzdEV2dC5yZXRyeUNvdW50ID49IFN5bmNNYW5hZ2VyLk1BWF9SRVRSSUVTKSB7XG4gICAgICAgIHJldHVybiAndG9vTWFueUZhaWx1cmVzV2hpbGVPbmxpbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdzZXJ2ZXJVbmF2YWlsYWJsZSc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnJJZCA9PT0gJ2F1dGhlbnRpY2F0aW9uX3JlcXVpcmVkJyAmJiByZXN1bHQuZGF0YS5kYXRhICYmIHJlc3VsdC5kYXRhLmRhdGEubm9uY2UpIHtcbiAgICAgIHJldHVybiAncmVhdXRob3JpemUnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3NlcnZlclJlamVjdGVkUmVxdWVzdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBmYWlsZWQgcmVxdWVzdHMuXG4gICAqXG4gICAqIDEuIElmIHRoZXJlIHdhcyBhbiBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIsIHRoZW4gdGhlIHJlcXVlc3QgaGFzIHByb2JsZW1zXG4gICAqIDIuIElmIHdlIGRldGVybWluZSB3ZSBhcmUgbm90IGluIGZhY3Qgb25saW5lLCBjYWxsIHRoZSBjb25uZWN0aW9uRXJyb3IgaGFuZGxlclxuICAgKiAzLiBJZiB3ZSB0aGluayB3ZSBhcmUgb25saW5lLCB2ZXJpZnkgd2UgYXJlIG9ubGluZSBhbmQgdGhlbiBkZXRlcm1pbmUgaG93IHRvIGhhbmRsZSBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBfeGhyRXJyb3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHQgIC0gUmVzcG9uc2Ugb2JqZWN0IHJldHVybmVkIGJ5IHhociBjYWxsXG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIFJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICBfeGhyRXJyb3IocmVzdWx0KSB7XG4gICAgY29uc3QgcmVxdWVzdEV2dCA9IHJlc3VsdC5yZXF1ZXN0O1xuXG4gICAgbG9nZ2VyLndhcm4oYFN5bmMgTWFuYWdlciAke3JlcXVlc3RFdnQgaW5zdGFuY2VvZiBXZWJzb2NrZXRTeW5jRXZlbnQgPyAnV2Vic29ja2V0JyA6ICdYSFInfSBgICtcbiAgICAgIGAke3JlcXVlc3RFdnQub3BlcmF0aW9ufSBSZXF1ZXN0IG9uIHRhcmdldCAke3JlcXVlc3RFdnQudGFyZ2V0fSBoYXMgRmFpbGVkYCwgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcblxuXG4gICAgY29uc3QgZXJyU3RhdGUgPSB0aGlzLl9nZXRFcnJvclN0YXRlKHJlc3VsdCwgcmVxdWVzdEV2dCwgdGhpcy5pc09ubGluZSgpKTtcbiAgICBsb2dnZXIud2FybignU3luYyBNYW5hZ2VyIEVycm9yIFN0YXRlOiAnICsgZXJyU3RhdGUpO1xuICAgIHN3aXRjaCAoZXJyU3RhdGUpIHtcbiAgICAgIGNhc2UgJ3Rvb01hbnlGYWlsdXJlc1doaWxlT25saW5lJzpcbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyRXJyb3IocmVzdWx0LCAnU3luYyBNYW5hZ2VyIFNlcnZlciBVbmF2YWlsYWJsZSBUb28gTG9uZzsgcmVtb3ZpbmcgcmVxdWVzdCcsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub3RGb3VuZCc6XG4gICAgICAgIHRoaXMuX3hockhhbmRsZVNlcnZlckVycm9yKHJlc3VsdCwgJ1Jlc291cmNlIG5vdCBmb3VuZDsgcHJlc3VtYWJseSBkZWxldGVkJywgZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludmFsaWRJZCc6XG4gICAgICAgIHRoaXMuX3hockhhbmRsZVNlcnZlckVycm9yKHJlc3VsdCwgJ0lEIHdhcyBub3QgdW5pcXVlOyByZXF1ZXN0IGZhaWxlZCcsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2YWxpZGF0ZU9ubGluZUFuZFJldHJ5JzpcbiAgICAgICAgLy8gU2VydmVyIGFwcGVhcnMgdG8gYmUgaHVuZyBidXQgd2lsbCBldmVudHVhbGx5IHJlY292ZXIuXG4gICAgICAgIC8vIFJldHJ5IGEgZmV3IHRpbWVzIGFuZCB0aGVuIGVycm9yIG91dC5cbiAgICAgICAgLy8gdGhpcy5feGhyVmFsaWRhdGVJc09ubGluZShyZXF1ZXN0RXZ0KTtcbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyVW5hdmFpbGFibGVFcnJvcihyZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlcnZlclVuYXZhaWxhYmxlJzpcbiAgICAgICAgLy8gU2VydmVyIGlzIGluIGEgYmFkIHN0YXRlIGJ1dCB3aWxsIGV2ZW50dWFsbHkgcmVjb3ZlcjtcbiAgICAgICAgLy8ga2VlcCByZXRyeWluZy5cbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyVW5hdmFpbGFibGVFcnJvcihyZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzpcbiAgICAgICAgLy8gc2Vzc2lvblRva2VuIGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIHZhbGlkOyBmb3J3YXJkIHJlc3BvbnNlXG4gICAgICAgIC8vIG9uIHRvIGNsaWVudC1hdXRoZW50aWNhdG9yIHRvIHByb2Nlc3MuXG4gICAgICAgIC8vIERvIG5vdCByZXRyeSBub3IgYWR2YW5jZSB0byBuZXh0IHJlcXVlc3QuXG4gICAgICAgIGlmIChyZXF1ZXN0RXZ0LmNhbGxiYWNrKSByZXF1ZXN0RXZ0LmNhbGxiYWNrKHJlc3VsdCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXJ2ZXJSZWplY3RlZFJlcXVlc3QnOlxuICAgICAgICAvLyBTZXJ2ZXIgcHJlc3VtYWJseSBkaWQgbm90IGxpa2UgdGhlIGFyZ3VtZW50cyB0byB0aGlzIGNhbGxcbiAgICAgICAgLy8gb3IgdGhlIHVybCB3YXMgaW52YWxpZC4gIERvIG5vdCByZXRyeTsgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gYW5kIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdC5cbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyRXJyb3IocmVzdWx0LCAnU3luYyBNYW5hZ2VyIFNlcnZlciBSZWplY3RzIFJlcXVlc3Q7IHJlbW92aW5nIHJlcXVlc3QnLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdDT1JTJzpcbiAgICAgICAgLy8gQSBwYXR0ZXJuIG9mIG9mZmxpbmUtbGlrZSBmYWlsdXJlcyB0aGF0IHN1Z2dlc3RzIGl0cyBhY3R1YWxseSBhIENPUnMgZXJyb3JcbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyRXJyb3IocmVzdWx0LCAnU3luYyBNYW5hZ2VyIFNlcnZlciBkZXRlY3RzIENPUlMtbGlrZSBlcnJvcnM7IHJlbW92aW5nIHJlcXVlc3QnLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2ZmbGluZSc6XG4gICAgICAgIHRoaXMuX3hockhhbmRsZUNvbm5lY3Rpb25FcnJvcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXcml0ZSB0aGUgc3luYyBldmVudCBiYWNrIHRvIHRoZSBkYXRhYmFzZSBpZiB3ZSBoYXZlbid0IGNvbXBsZXRlZCBwcm9jZXNzaW5nIGl0XG4gICAgaWYgKHRoaXMucXVldWUuaW5kZXhPZihyZXF1ZXN0RXZ0KSAhPT0gLTEgfHwgdGhpcy5yZWNlaXB0UXVldWUuaW5kZXhPZihyZXF1ZXN0RXZ0KSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuY2xpZW50LmRiTWFuYWdlci53cml0ZVN5bmNFdmVudHMoW3JlcXVlc3RFdnRdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgc2VydmVyIHVuYXZhaWxhYmxlIGVycm9yLlxuICAgKlxuICAgKiBJbiB0aGUgZXZlbnQgb2YgYSA1MDIgKEJhZCBHYXRld2F5KSwgNTAzIChzZXJ2aWNlIHVuYXZhaWxhYmxlKVxuICAgKiBvciA1MDQgKGdhdGV3YXkgdGltZW91dCkgZXJyb3IgZnJvbSB0aGUgc2VydmVyXG4gICAqIGFzc3VtZSB3ZSBoYXZlIGFuIGVycm9yIHRoYXQgaXMgc2VsZiBjb3JyZWN0aW5nIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIFVzZSBleHBvbmVudGlhbCBiYWNrb2ZmIHRvIHJldHJ5IHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgZWFjaCBjYWxsIHdpbGwgaW5jcmVtZW50IHJldHJ5Q291bnQ7IHRoZXJlIGlzIGEgbWF4aW11bVxuICAgKiBvZiBNQVhfUkVUUklFUyBiZWZvcmUgaXQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvclxuICAgKlxuICAgKiBAbWV0aG9kICBfeGhySGFuZGxlU2VydmVyVW5hdmFpbGFibGVFcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgICAgICAgICAgICBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICovXG4gIF94aHJIYW5kbGVTZXJ2ZXJVbmF2YWlsYWJsZUVycm9yKHJlc3VsdCkge1xuICAgIHZhciByZXF1ZXN0ID0gcmVzdWx0LnJlcXVlc3Q7XG4gICAgdGhpcy50cmlnZ2VyKCdzeW5jOmVycm9yLXdpbGwtcmV0cnknLCB7XG4gICAgICB0YXJnZXQ6IHJlcXVlc3QudGFyZ2V0LFxuICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICAgIHJldHJ5Q291bnQ6IHJlcXVlc3QucmV0cnlDb3VudFxuICAgIH0pO1xuICAgIGNvbnN0IG1heERlbGF5ID0gU3luY01hbmFnZXIuTUFYX1VOQVZBSUxBQkxFX1JFVFJZX1dBSVQ7XG4gICAgY29uc3QgZGVsYXkgPSBVdGlscy5nZXRFeHBvbmVudGlhbEJhY2tvZmZTZWNvbmRzKG1heERlbGF5LCBNYXRoLm1pbigxNSwgcmVxdWVzdC5yZXRyeUNvdW50KyspKTtcbiAgICBsb2dnZXIud2FybihgU3luYyBNYW5hZ2VyIFNlcnZlciBVbmF2YWlsYWJsZTsgcmV0cnkgY291bnQgJHtyZXF1ZXN0LnJldHJ5Q291bnR9OyByZXRyeWluZyBpbiAke2RlbGF5fSBzZWNvbmRzYCk7XG4gICAgc2V0VGltZW91dCh0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QuYmluZCh0aGlzKSwgZGVsYXkgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzZXJ2ZXIgZXJyb3IgaW4gcmVzcG9uc2UgdG8gZmlyaW5nIHN5bmMgZXZlbnQuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIGEgc2VydmVyIGVycm9yLCBpdHMgcHJlc3VtYWJseSBub24tcmVjb3ZlcmFibGUvbm9uLXJldHJ5YWJsZSBlcnJvciwgc29cbiAgICogd2UncmUgZ29pbmcgdG8gYWJvcnQgdGhpcyByZXF1ZXN0LlxuICAgKlxuICAgKiAxLiBJZiBhIGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAqIDIuIElmIGEgcm9sbGJhY2sgY2FsbCBpcyBwcm92aWRlZCwgY2FsbCBpdCB0byB1bmRvIGFueSBwYXRjaC9kZWxldGUvZXRjLi4uIGNoYW5nZXNcbiAgICogMy4gSWYgdGhlIHJlcXVlc3Qgd2FzIHRvIGNyZWF0ZSBhIHJlc291cmNlLCByZW1vdmUgZnJvbSB0aGUgcXVldWUgYWxsIHJlcXVlc3RzXG4gICAqICAgIHRoYXQgZGVwZW5kZWQgdXBvbiB0aGF0IHJlc291cmNlLlxuICAgKiA0LiBBZHZhbmNlIHRvIG5leHQgcmVxdWVzdFxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJIYW5kbGVTZXJ2ZXJFcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICogQHBhcmFtICB7c3RyaW5nfSBsb2dNc2cgLSBNZXNzYWdlIHRvIGRpc3BsYXkgaW4gY29uc29sZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBzdHJpbmdpZnkgLSBsb2cgb2JqZWN0IGZvciBxdWljayBkZWJ1Z2dpbmdcbiAgICpcbiAgICovXG4gIF94aHJIYW5kbGVTZXJ2ZXJFcnJvcihyZXN1bHQsIGxvZ01zZywgc3RyaW5naWZ5KSB7XG4gICAgLy8gRXhlY3V0ZSBhbGwgY2FsbGJhY2tzIHByb3ZpZGVkIGJ5IHRoZSByZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5yZXF1ZXN0LmNhbGxiYWNrKSByZXN1bHQucmVxdWVzdC5jYWxsYmFjayhyZXN1bHQpO1xuICAgIGlmIChzdHJpbmdpZnkpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihsb2dNc2cgK1xuICAgICAgICAnXFxuUkVRVUVTVDogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdC5yZXF1ZXN0LnRvT2JqZWN0KCksIG51bGwsIDQpICtcbiAgICAgICAgJ1xcblJFU1BPTlNFOiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0LmRhdGEsIG51bGwsIDQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yKGxvZ01zZywgcmVzdWx0KTtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdzeW5jOmVycm9yJywge1xuICAgICAgdGFyZ2V0OiByZXN1bHQucmVxdWVzdC50YXJnZXQsXG4gICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICB9KTtcblxuICAgIHJlc3VsdC5yZXF1ZXN0LnN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIC8vIElmIGEgUE9TVCByZXF1ZXN0IGZhaWxzLCBhbGwgcmVxdWVzdHMgdGhhdCBkZXBlbmQgdXBvbiB0aGlzIG9iamVjdFxuICAgIC8vIG11c3QgYmUgcHVyZ2VkXG4gICAgaWYgKHJlc3VsdC5yZXF1ZXN0Lm9wZXJhdGlvbiA9PT0gJ1BPU1QnKSB7XG4gICAgICB0aGlzLl9wdXJnZURlcGVuZGVudFJlcXVlc3RzKHJlc3VsdC5yZXF1ZXN0KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhpcyByZXF1ZXN0IGFzIHdlbGwgKHNpZGUtZWZmZWN0OiByb2xscyBiYWNrIHRoZSBvcGVyYXRpb24pXG4gICAgdGhpcy5fcmVtb3ZlUmVxdWVzdChyZXN1bHQucmVxdWVzdCwgdHJ1ZSk7XG5cbiAgICAvLyBBbmQgZmluYWxseSwgd2UgYXJlIHJlYWR5IHRvIHRyeSB0aGUgbmV4dCByZXF1ZXN0XG4gICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIGVycm9yLCB3YWl0IGZvciByZXRyeS5cbiAgICpcbiAgICogSW4gdGhlIGV2ZW50IG9mIHdoYXQgYXBwZWFycyB0byBiZSBhIGNvbm5lY3Rpb24gZXJyb3IsXG4gICAqIFdhaXQgdW50aWwgYSAnY29ubmVjdGVkJyBldmVudCBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgbmV4dCByZXF1ZXN0IChhY3R1YWxseSByZXByb2Nlc3NpbmcgdGhlIGN1cnJlbnQgZXZlbnQpXG4gICAqXG4gICAqIEBtZXRob2QgX3hockhhbmRsZUNvbm5lY3Rpb25FcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3hockhhbmRsZUNvbm5lY3Rpb25FcnJvcigpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGJlIGRvbmU7IHdlIGFscmVhZHkgaGF2ZSB0aGUgYmVsb3cgZXZlbnQgaGFuZGxlciBzZXR1cFxuICAgIC8vIHRoaXMub25saW5lTWFuYWdlci5vbmNlKCdjb25uZWN0ZWQnLCAoKSA9PiB0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QoKSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgd2UgYXJlIG9ubGluZSBhbmQgcmV0cnkgcmVxdWVzdC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gd2UgdGhpbmsgd2UncmUgb25saW5lLCBidXRcbiAgICogaGF2ZSBkZXRlcm1pbmVkIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhhdCBhc3N1bXB0aW9uLlxuICAgKlxuICAgKiBUZXN0IHRoYXQgd2UgaGF2ZSBhIGNvbm5lY3Rpb247IGlmIHdlIGRvLFxuICAgKiByZXRyeSB0aGUgcmVxdWVzdCBvbmNlLCBhbmQgaWYgaXQgZmFpbHMgYWdhaW4sXG4gICAqIF94aHJFcnJvcigpIHdpbGwgZGV0ZXJtaW5lIGl0IHRvIGhhdmUgZmFpbGVkIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIElmIHdlIGFyZSBvZmZsaW5lLCB0aGVuIGxldCBfeGhySGFuZGxlQ29ubmVjdGlvbkVycm9yIGhhbmRsZSBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBfeGhyVmFsaWRhdGVJc09ubGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3hoclZhbGlkYXRlSXNPbmxpbmUocmVxdWVzdEV2dCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnU3luYyBNYW5hZ2VyIHZlcmlmeWluZyBvbmxpbmUgc3RhdGUnKTtcbiAgICB0aGlzLm9ubGluZU1hbmFnZXIuY2hlY2tPbmxpbmVTdGF0dXMoaXNPbmxpbmUgPT4gdGhpcy5feGhyVmFsaWRhdGVJc09ubGluZUNhbGxiYWNrKGlzT25saW5lLCByZXF1ZXN0RXZ0KSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgd2UgaGF2ZSB2ZXJpZmllZCB3ZSBhcmUgb25saW5lLCByZXRyeSByZXF1ZXN0LlxuICAgKlxuICAgKiBXZSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlIHRvIG91ciAvbm9uY2VzIGNhbGxcbiAgICogd2hpY2ggYXNzdW1pbmcgdGhlIHNlcnZlciBpcyBhY3R1YWxseSBhbGl2ZSxcbiAgICogd2lsbCB0ZWxsIHVzIGlmIHRoZSBjb25uZWN0aW9uIGlzIHdvcmtpbmcuXG4gICAqXG4gICAqIElmIHdlIGFyZSBvZmZsaW5lLCBmbGFnIHVzIGFzIG9mZmxpbmUgYW5kIGxldCB0aGUgQ29ubmVjdGlvbkVycm9yIGhhbmRsZXIgaGFuZGxlIHRoaXNcbiAgICogSWYgd2UgYXJlIG9ubGluZSwgZ2l2ZSB0aGUgcmVxdWVzdCBhIHNpbmdsZSByZXRyeSAodGhlcmUgaXMgbmV2ZXIgbW9yZSB0aGFuIG9uZSByZXRyeSlcbiAgICpcbiAgICogQG1ldGhvZCBfeGhyVmFsaWRhdGVJc09ubGluZUNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGlzT25saW5lICAtIFJlc3BvbnNlIG9iamVjdCByZXR1cm5lZCBieSB4aHIgY2FsbFxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIFRoZSByZXF1ZXN0IHRoYXQgZmFpbGVkIHRyaWdnZXJpbmcgdGhpcyBjYWxsXG4gICAqL1xuICBfeGhyVmFsaWRhdGVJc09ubGluZUNhbGxiYWNrKGlzT25saW5lLCByZXF1ZXN0RXZ0KSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdTeW5jIE1hbmFnZXIgb25saW5lIGNoZWNrIHJlc3VsdCBpcyAnICsgaXNPbmxpbmUpO1xuICAgIGlmICghaXNPbmxpbmUpIHtcbiAgICAgIC8vIFRyZWF0IHRoaXMgYXMgYSBDb25uZWN0aW9uIEVycm9yXG4gICAgICB0aGlzLl94aHJIYW5kbGVDb25uZWN0aW9uRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgaW4gY2FzZSB3ZSB3ZXJlIG9mZmxpbmUsIGJ1dCBhcmUgbm93IG9ubGluZS5cbiAgICAgIC8vIE9mIGNvdXJzZSwgaWYgdGhpcyBmYWlscywgZ2l2ZSBpdCB1cCBlbnRpcmVseS5cbiAgICAgIHJlcXVlc3RFdnQucmV0cnlDb3VudCsrO1xuICAgICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBYSFIgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICpcbiAgICogQW55IHhociByZXF1ZXN0IHRoYXQgYWN0dWFsbHkgc3VjY2VkZXM6XG4gICAqXG4gICAqIDEuIFJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZVxuICAgKiAyLiBDYWxsIGFueSBjYWxsYmFja3NcbiAgICogMy4gQWR2YW5jZSB0byBuZXh0IHJlcXVlc3RcbiAgICpcbiAgICogQG1ldGhvZCBfeGhyU3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gUmVxdWVzdCBvYmplY3RcbiAgICovXG4gIF94aHJTdWNjZXNzKHJlc3VsdCkge1xuICAgIGNvbnN0IHJlcXVlc3RFdnQgPSByZXN1bHQucmVxdWVzdDtcbiAgICBsb2dnZXIuZGVidWcoYFN5bmMgTWFuYWdlciAke3JlcXVlc3RFdnQgaW5zdGFuY2VvZiBXZWJzb2NrZXRTeW5jRXZlbnQgPyAnV2Vic29ja2V0JyA6ICdYSFInfSBgICtcbiAgICAgIGAke3JlcXVlc3RFdnQub3BlcmF0aW9ufSBSZXF1ZXN0IG9uIHRhcmdldCAke3JlcXVlc3RFdnQudGFyZ2V0fSBoYXMgU3VjY2VlZGVkYCwgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICBpZiAocmVzdWx0LmRhdGEpIGxvZ2dlci5kZWJ1ZyhyZXN1bHQuZGF0YSk7XG4gICAgcmVxdWVzdEV2dC5zdWNjZXNzID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW1vdmVSZXF1ZXN0KHJlcXVlc3RFdnQsIHRydWUpO1xuICAgIGlmIChyZXF1ZXN0RXZ0LmNhbGxiYWNrKSByZXF1ZXN0RXZ0LmNhbGxiYWNrKHJlc3VsdCk7XG4gICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3N5bmM6c3VjY2VzcycsIHtcbiAgICAgIHRhcmdldDogcmVxdWVzdEV2dC50YXJnZXQsXG4gICAgICByZXF1ZXN0OiByZXF1ZXN0RXZ0LFxuICAgICAgcmVzcG9uc2U6IHJlc3VsdC5kYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgU3luY0V2ZW50IHJlcXVlc3QgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBtZXRob2QgX3JlbW92ZVJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gU3luY0V2ZW50IFJlcXVlc3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVsZXRlREIgLSBEZWxldGUgZnJvbSBpbmRleGVkREJcbiAgICovXG4gIF9yZW1vdmVSZXF1ZXN0KHJlcXVlc3RFdnQsIGRlbGV0ZURCKSB7XG4gICAgY29uc3QgcXVldWUgPSByZXF1ZXN0RXZ0Lm9wZXJhdGlvbiA9PT0gJ1JFQ0VJUFQnID8gdGhpcy5yZWNlaXB0UXVldWUgOiB0aGlzLnF1ZXVlO1xuICAgIGNvbnN0IGluZGV4ID0gcXVldWUuaW5kZXhPZihyZXF1ZXN0RXZ0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSBxdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChkZWxldGVEQikgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLmRlbGV0ZU9iamVjdHMoJ3N5bmNRdWV1ZScsIFtyZXF1ZXN0RXZ0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHJlcXVlc3RzIGZyb20gcXVldWUgdGhhdCBkZXBlbmQgb24gc3BlY2lmaWVkIHJlc291cmNlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhIFBPU1QgcmVxdWVzdCB0byBjcmVhdGUgYSBuZXcgcmVzb3VyY2UsIGFuZCB0aGVyZSBhcmUgUEFUQ0gsIERFTEVURSwgZXRjLi4uXG4gICAqIHJlcXVlc3RzIG9uIHRoYXQgcmVzb3VyY2UsIGlmIHRoZSBQT1NUIHJlcXVlc3QgZmFpbHMsIHRoZW4gYWxsIFBBVENILCBERUxFVEUsIGV0Y1xuICAgKiByZXF1ZXN0cyBtdXN0IGJlIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3ZSBkbyBub3QgY2FsbCB0aGUgcm9sbGJhY2sgb24gdGhlc2UgZGVwZW5kZW50IHJlcXVlc3RzIGJlY2F1c2UgdGhlIGV4cGVjdGVkXG4gICAqIHJvbGxiYWNrIGlzIHRvIGRlc3Ryb3kgdGhlIHRoaW5nIHRoYXQgd2FzIGNyZWF0ZWQsIHdoaWNoIG1lYW5zIGFueSBvdGhlciByb2xsYmFjayBoYXMgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBAbWV0aG9kIF9wdXJnZURlcGVuZGVudFJlcXVlc3RzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdCAtIFJlcXVlc3Qgd2hvc2UgdGFyZ2V0IGlzIG5vIGxvbmdlciB2YWxpZFxuICAgKi9cbiAgX3B1cmdlRGVwZW5kZW50UmVxdWVzdHMocmVxdWVzdCkge1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcihldnQgPT4gZXZ0LmRlcGVuZHMuaW5kZXhPZihyZXF1ZXN0LnRhcmdldCkgPT09IC0xIHx8IGV2dCA9PT0gcmVxdWVzdCk7XG4gICAgdGhpcy5yZWNlaXB0UXVldWUgPSB0aGlzLnJlY2VpcHRRdWV1ZS5maWx0ZXIoZXZ0ID0+IGV2dC5kZXBlbmRzLmluZGV4T2YocmVxdWVzdC50YXJnZXQpID09PSAtMSB8fCBldnQgPT09IHJlcXVlc3QpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGZyb20gcXVldWUgYWxsIGV2ZW50cyB0aGF0IG9wZXJhdGUgdXBvbiB0aGUgZGVsZXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgX3B1cmdlT25EZWxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSBldnQgLSBEZWxldGUgZXZlbnQgdGhhdCByZXF1aXJlcyByZW1vdmFsIG9mIG90aGVyIGV2ZW50c1xuICAgKi9cbiAgX3B1cmdlT25EZWxldGUoZXZ0KSB7XG4gICAgdGhpcy5xdWV1ZS5maWx0ZXIocmVxdWVzdCA9PiByZXF1ZXN0LmRlcGVuZHMuaW5kZXhPZihldnQudGFyZ2V0KSAhPT0gLTEgJiYgZXZ0ICE9PSByZXF1ZXN0KVxuICAgICAgLmZvckVhY2goKHJlcXVlc3RFdnQpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jOmFib3J0Jywge1xuICAgICAgICAgIHRhcmdldDogcmVxdWVzdEV2dC50YXJnZXQsXG4gICAgICAgICAgcmVxdWVzdDogcmVxdWVzdEV2dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlbW92ZVJlcXVlc3QocmVxdWVzdEV2dCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgfVxuXG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goZXZ0ID0+IGV2dC5kZXN0cm95KCkpO1xuICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgIHRoaXMucmVjZWlwdFF1ZXVlLmZvckVhY2goZXZ0ID0+IGV2dC5kZXN0cm95KCkpO1xuICAgIHRoaXMucmVjZWlwdFF1ZXVlID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbnkgdW5zZW50IHJlcXVlc3RzIGZyb20gaW5kZXhlZERCLlxuICAgKlxuICAgKiBJZiBwZXJzaXN0ZW5jZSBpcyBkaXNhYmxlZCwgbm90aGluZyB3aWxsIGhhcHBlbjtcbiAgICogZWxzZSBhbGwgcmVxdWVzdHMgZm91bmQgaW4gdGhlIGRhdGFiYXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKiBAbWV0aG9kIF9sb2FkUGVyc2lzdGVkUXVldWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkUGVyc2lzdGVkUXVldWUoKSB7XG4gICAgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLmxvYWRTeW5jUXVldWUoKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5jb25jYXQoZGF0YSk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NOZXh0UmVxdWVzdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogV2Vic29ja2V0IE1hbmFnZXIgZm9yIGdldHRpbmcgc29ja2V0IHN0YXRlLlxuICogQHR5cGUge2xheWVyLldlYnNvY2tldHMuU29ja2V0TWFuYWdlcn1cbiAqL1xuU3luY01hbmFnZXIucHJvdG90eXBlLnNvY2tldE1hbmFnZXIgPSBudWxsO1xuXG4vKipcbiAqIFdlYnNvY2tldCBSZXF1ZXN0IE1hbmFnZXIgZm9yIHNlbmRpbmcgcmVxdWVzdHMuXG4gKiBAdHlwZSB7bGF5ZXIuV2Vic29ja2V0cy5SZXF1ZXN0TWFuYWdlcn1cbiAqL1xuU3luY01hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIE9ubGluZSBTdGF0ZSBNYW5hZ2VyLlxuICpcbiAqIFN5bmMgTWFuYWdlciB1c2VzIG9ubGluZSBzdGF0dXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGNhbiBmaXJlIHN5bmMtcmVxdWVzdHMuXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge2xheWVyLk9ubGluZVN0YXRlTWFuYWdlcn1cbiAqL1xuU3luY01hbmFnZXIucHJvdG90eXBlLm9ubGluZU1hbmFnZXIgPSBudWxsO1xuXG4vKipcbiAqIFRoZSBhcnJheSBvZiBsYXllci5TeW5jRXZlbnQgaW5zdGFuY2VzIGF3YWl0aW5nIHRvIGJlIGZpcmVkLlxuICogQHR5cGUge2xheWVyLlN5bmNFdmVudFtdfVxuICovXG5TeW5jTWFuYWdlci5wcm90b3R5cGUucXVldWUgPSBudWxsO1xuXG4vKipcbiAqIFRoZSBhcnJheSBvZiBsYXllci5TeW5jRXZlbnQgaW5zdGFuY2VzIGF3YWl0aW5nIHRvIGJlIGZpcmVkLlxuICpcbiAqIFJlY2VpcHRzIGNhbiBnZW5lcmFsbHkganVzdCBiZSBmaXJlZCBvZmYgYWxsIGF0IG9uY2Ugd2l0aG91dCBtdWNoIGZyZXR0aW5nIGFib3V0IG9yZGVyaW5nIG9yIGRlcGVuZGVuY2llcy5cbiAqIEB0eXBlIHtsYXllci5TeW5jRXZlbnRbXX1cbiAqL1xuU3luY01hbmFnZXIucHJvdG90eXBlLnJlY2VpcHRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSBDbGllbnQgc28gdGhhdCB3ZSBjYW4gcGFzcyBpdCB0byBTeW5jRXZlbnRzICB3aGljaCBtYXkgbmVlZCB0byBsb29rdXAgdGhlaXIgdGFyZ2V0c1xuICovXG5TeW5jTWFuYWdlci5wcm90b3R5cGUuY2xpZW50ID0gbnVsbDtcblxuLyoqXG4gKiBNYXhpbXVtIGV4cG9uZW50aWFsIGJhY2tvZmYgd2FpdC5cbiAqXG4gKiBJZiB0aGUgc2VydmVyIGlzIHJldHVybmluZyA1MDIsIDUwMyBvciA1MDQgZXJyb3JzLCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gKiBzaG91bGQgbmV2ZXIgd2FpdCBsb25nZXIgdGhhbiB0aGlzIG51bWJlciBvZiBzZWNvbmRzICg2MCBzZWNvbmRzKVxuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuU3luY01hbmFnZXIuTUFYX1VOQVZBSUxBQkxFX1JFVFJZX1dBSVQgPSA2MDtcblxuLyoqXG4gKiBSZXRyaWVzIGJlZm9yZSBzdXNwZWN0IENPUlMgZXJyb3IuXG4gKlxuICogSG93IG1hbnkgdGltZXMgY2FuIHdlIHRyYW5zaXRpb24gZnJvbSBvZmZsaW5lIHRvIG9ubGluZSBzdGF0ZVxuICogd2l0aCB0aGlzIHJlcXVlc3QgYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSBiZWZvcmUgd2UgY29uY2x1ZGVcbiAqIHRoYXQgdGhlIHJlYXNvbiB3ZSBrZWVwIHRoaW5raW5nIHdlJ3JlIGdvaW5nIG9mZmxpbmUgaXNcbiAqIGEgQ09SUyBlcnJvciByZXR1cm5pbmcgYSBzdGF0dXMgb2YgMC4gIElmIHRoYXQgcGF0dGVyblxuICogc2hvd3MgMyB0aW1lcyBpbiBhIHJvdywgdGhlcmUgaXMgbGlrZWx5IGEgQ09SUyBlcnJvci5cbiAqIE5vdGUgdGhhdCBDT1JTIGVycm9ycyBhcHBlYXIgdG8gamF2YXNjcmlwdCBhcyBhIHN0YXR1cz0wIGVycm9yLFxuICogd2hpY2ggaXMgdGhlIHNhbWUgYXMgaWYgdGhlIGNsaWVudCB3ZXJlIG9mZmxpbmUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5TeW5jTWFuYWdlci5NQVhfUkVUUklFU19CRUZPUkVfQ09SU19FUlJPUiA9IDM7XG5cbi8qKlxuICogQWJvcnQgcmVxdWVzdCBhZnRlciB0aGlzIG51bWJlciBvZiByZXRyaWVzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cblN5bmNNYW5hZ2VyLk1BWF9SRVRSSUVTID0gMjA7XG5cblxuU3luY01hbmFnZXIuX3N1cHBvcnRlZEV2ZW50cyA9IFtcbiAgLyoqXG4gICAqIEEgc3luYyByZXF1ZXN0IGhhcyBmYWlsZWQuXG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGllbnQuc3luY01hbmFnZXIub24oJ3N5bmM6ZXJyb3InLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgY29uc29sZS5lcnJvcihldnQudGFyZ2V0ICsgJyBmYWlsZWQgdG8gc2VuZCBjaGFuZ2VzIHRvIHNlcnZlcjogJywgZXZ0LmVycm9yLm1lc3NhZ2UpO1xuICAgKiAgICBjb25zb2xlLmxvZygnUmVxdWVzdCBFdmVudDonLCBldnQucmVxdWVzdCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0ICAgICAgICAgIFN0YW5kYXJkIExheWVyIEV2ZW50IG9iamVjdCBnZW5lcmF0ZWQgYnkgYWxsIGNhbGxzIHRvIGB0cmlnZ2VyYFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXJyb3J9IGV2dC5lcnJvciAgICBBbiBlcnJvciBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzZXJ2ZXIncyByZXNwb25zZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0LnRhcmdldCAgICAgICAgICAgICBJRCBvZiB0aGUgbWVzc2FnZS9jb252ZXJzYXRpb24vZXRjLiBiZWluZyBvcGVyYXRlZCB1cG9uXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50fSBldnQucmVxdWVzdCAgVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICAnc3luYzplcnJvcicsXG5cbiAgLyoqXG4gICAqIEEgc3luYyByZXF1ZXN0IGhhcyBidXQgd2lsbCBiZSByZXRyaWVkIHNvb24uXG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGllbnQuc3luY01hbmFnZXIub24oJ3N5bmM6ZXJyb3Itd2lsbC1yZXRyeScsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICBjb25zb2xlLmVycm9yKGV2dC50YXJnZXQgKyAnIGZhaWxlZCB0byBzZW5kIGNoYW5nZXMgdG8gc2VydmVyOiAnLCBldnQuZXJyb3IubWVzc2FnZSk7XG4gICAqICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IEV2ZW50OicsIGV2dC5yZXF1ZXN0KTtcbiAgICogICAgY29uc29sZS5sb2coJ051bWJlciBvZiByZXRyaWVzOicsIGV2dC5yZXRyeUNvdW50KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnQgICAgICAgICAgU3RhbmRhcmQgTGF5ZXIgRXZlbnQgb2JqZWN0IGdlbmVyYXRlZCBieSBhbGwgY2FsbHMgdG8gYHRyaWdnZXJgXG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gZXZ0LmVycm9yICAgIEFuIGVycm9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNlcnZlcidzIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldnQudGFyZ2V0ICAgICAgICAgICAgIElEIG9mIHRoZSBtZXNzYWdlL2NvbnZlcnNhdGlvbi9ldGMuIGJlaW5nIG9wZXJhdGVkIHVwb25cbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnR9IGV2dC5yZXF1ZXN0ICAgVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldnQucmV0cnlDb3VudCAgICAgICAgIE51bWJlciBvZiByZXRyaWVzIHBlcmZvcm1lZCBvbiB0aGlzIHJlcXVlc3Q7IGZvciB0aGUgZmlyc3QgZXZlbnQgdGhpcyB3aWxsIGJlIDBcbiAgICovXG4gICdzeW5jOmVycm9yLXdpbGwtcmV0cnknLFxuXG4gIC8qKlxuICAgKiBBIHN5bmMgbGF5ZXIgcmVxdWVzdCBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICpcbiAgICogYGBgXG4gICAqIGNsaWVudC5zeW5jTWFuYWdlci5vbignc3luYzpzdWNjZXNzJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAqICAgIGNvbnNvbGUubG9nKGV2dC50YXJnZXQgKyAnIGNoYW5nZXMgc2VudCB0byBzZXJ2ZXIgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAqICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IEV2ZW50OicsIGV2dC5yZXF1ZXN0KTtcbiAgICogICAgY29uc29sZS5sb2coJ1NlcnZlciBSZXNwb25zZTonLCBldnQucmVzcG9uc2UpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dCAgICAgICAgICBTdGFuZGFyZCBMYXllciBFdmVudCBvYmplY3QgZ2VuZXJhdGVkIGJ5IGFsbCBjYWxscyB0byBgdHJpZ2dlcmBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2dC50YXJnZXQgICAgICAgICAgICAgSUQgb2YgdGhlIG1lc3NhZ2UvY29udmVyc2F0aW9uL2V0Yy4gYmVpbmcgb3BlcmF0ZWQgdXBvblxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gZXZ0LnJlcXVlc3QgICBUaGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZ0LnJlc3BvbnNlICAgICAgICAgICBudWxsIG9yIGFueSBkYXRhIHJldHVybmVkIGJ5IHRoZSBjYWxsXG4gICAqL1xuICAnc3luYzpzdWNjZXNzJyxcblxuICAvKipcbiAgICogQSBuZXcgc3luYyByZXF1ZXN0IGhhcyBiZWVuIGFkZGVkLlxuICAgKlxuICAgKiBgYGBcbiAgICogY2xpZW50LnN5bmNNYW5hZ2VyLm9uKCdzeW5jOmFkZCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICBjb25zb2xlLmxvZyhldnQudGFyZ2V0ICsgJyBoYXMgY2hhbmdlcyBxdWV1ZWQgZm9yIHRoZSBzZXJ2ZXInKTtcbiAgICogICAgY29uc29sZS5sb2coJ1JlcXVlc3QgRXZlbnQ6JywgZXZ0LnJlcXVlc3QpO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dCAgICAgICAgICBTdGFuZGFyZCBMYXllciBFdmVudCBvYmplY3QgZ2VuZXJhdGVkIGJ5IGFsbCBjYWxscyB0byBgdHJpZ2dlcmBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2dC50YXJnZXQgICAgICAgICAgICAgSUQgb2YgdGhlIG1lc3NhZ2UvY29udmVyc2F0aW9uL2V0Yy4gYmVpbmcgb3BlcmF0ZWQgdXBvblxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gZXZ0LnJlcXVlc3QgICBUaGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgKi9cbiAgJ3N5bmM6YWRkJyxcblxuICAvKipcbiAgICogQSBzeW5jIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsZWQuXG4gICAqXG4gICAqIFR5cGljYWxseSBjYXVzZWQgYnkgYSBuZXcgU3luY0V2ZW50IHRoYXQgZGVsZXRlcyB0aGUgdGFyZ2V0IG9mIHRoaXMgU3luY0V2ZW50XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dCAgICAgICAgICBTdGFuZGFyZCBMYXllciBFdmVudCBvYmplY3QgZ2VuZXJhdGVkIGJ5IGFsbCBjYWxscyB0byBgdHJpZ2dlcmBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2dC50YXJnZXQgICAgICAgICAgICAgSUQgb2YgdGhlIG1lc3NhZ2UvY29udmVyc2F0aW9uL2V0Yy4gYmVpbmcgb3BlcmF0ZWQgdXBvblxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gZXZ0LnJlcXVlc3QgICBUaGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgKi9cbiAgJ3N5bmM6YWJvcnQnLFxuXS5jb25jYXQoUm9vdC5fc3VwcG9ydGVkRXZlbnRzKTtcblxuUm9vdC5pbml0Q2xhc3MoU3luY01hbmFnZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBTeW5jTWFuYWdlcjtcbiJdfQ==
