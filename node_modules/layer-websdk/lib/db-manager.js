'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Persistence manager.
 *
 * This class manages all indexedDB access.  It is not responsible for any localStorage access, though it may
 * receive configurations related to data stored in localStorage.  It will simply ignore those configurations.
 *
 * Rich Content will be written to IndexedDB as long as its small; see layer.DbManager.MaxPartSize for more info.
 *
 * TODO:
 * 0. Redesign this so that knowledge of the data is not hard-coded in
 * @class layer.DbManager
 * @protected
 */

var Root = require('./root');
var logger = require('./logger');
var SyncEvent = require('./sync-event');
var Constants = require('./const');
var Util = require('./client-utils');
var Announcement = require('./models/announcement');

var DB_VERSION = 5;
var MAX_SAFE_INTEGER = 9007199254740991;
var SYNC_NEW = Constants.SYNC_STATE.NEW;

function getDate(inDate) {
  return inDate ? inDate.toISOString() : null;
}

var TABLES = [{
  name: 'conversations',
  indexes: {
    created_at: ['created_at'],
    last_message_sent: ['last_message_sent']
  }
}, {
  name: 'channels',
  indexes: {
    created_at: ['created_at']
  }
}, {
  name: 'messages',
  indexes: {
    conversationId: ['conversationId', 'position']
  }
}, {
  name: 'identities',
  indexes: {}
}, {
  name: 'syncQueue',
  indexes: {}
}];

var DbManager = function (_Root) {
  _inherits(DbManager, _Root);

  /**
   * Create the DB Manager
   *
   * Key configuration is the layer.DbManager.persistenceFeatures property.
   *
   * @method constructor
   * @param {Object} options
   * @param {layer.Client} options.client
   * @param {Object} options.persistenceFeatures
   * @return {layer.DbManager} this
   */
  function DbManager(options) {
    _classCallCheck(this, DbManager);

    // If no indexedDB, treat everything as disabled.
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DbManager).call(this, options));

    if (!window.indexedDB || !options.enabled) {
      options.tables = {};
    } else {
      // Test if Arrays as keys supported, disable persistence if not
      var enabled = true;

      /* istanbul ignore next */
      try {
        window.IDBKeyRange.bound(['announcement', 0], ['announcement', MAX_SAFE_INTEGER]);
      } catch (e) {
        options.tables = {};
        enabled = false;
      }

      // If Client is a layer.ClientAuthenticator, it won't support these events; this affects Unit Tests
      if (enabled && _this.client.constructor._supportedEvents.indexOf('conversations:add') !== -1) {
        _this.client.on('conversations:add', function (evt) {
          return _this.writeConversations(evt.conversations);
        }, _this);
        _this.client.on('conversations:change', function (evt) {
          return _this._updateConversation(evt.target, evt.changes);
        }, _this);
        _this.client.on('conversations:delete conversations:sent-error', function (evt) {
          return _this.deleteObjects('conversations', [evt.target]);
        }, _this);

        _this.client.on('channels:add', function (evt) {
          return _this.writeChannels(evt.channels);
        }, _this);
        _this.client.on('channels:change', function (evt) {
          return _this._updateChannel(evt.target, evt.changes);
        }, _this);
        _this.client.on('channels:delete channels:sent-error', function (evt) {
          return _this.deleteObjects('channels', [evt.target]);
        }, _this);

        _this.client.on('messages:add', function (evt) {
          return _this.writeMessages(evt.messages);
        }, _this);
        _this.client.on('messages:change', function (evt) {
          return _this.writeMessages([evt.target]);
        }, _this);
        _this.client.on('messages:delete messages:sent-error', function (evt) {
          return _this.deleteObjects('messages', [evt.target]);
        }, _this);

        _this.client.on('identities:add', function (evt) {
          return _this.writeIdentities(evt.identities);
        }, _this);
        _this.client.on('identities:change', function (evt) {
          return _this.writeIdentities([evt.target]);
        }, _this);
        _this.client.on('identities:unfollow', function (evt) {
          return _this.deleteObjects('identities', [evt.target]);
        }, _this);
      }

      // Sync Queue only really works properly if we have the Messages and Conversations written to the DB; turn it off
      // if that won't be the case.
      if (!options.tables.conversations && !options.tables.channels || !options.tables.messages) {
        options.tables.syncQueue = false;
      }
    }

    TABLES.forEach(function (tableDef) {
      _this['_permission_' + tableDef.name] = Boolean(options.tables[tableDef.name]);
    });
    _this._open(false);
    return _this;
  }

  _createClass(DbManager, [{
    key: '_getDbName',
    value: function _getDbName() {
      return 'LayerWebSDK_' + this.client.appId;
    }

    /**
     * Open the Database Connection.
     *
     * This is only called by the constructor.
     * @method _open
     * @param {Boolean} retry
     * @private
     */

  }, {
    key: '_open',
    value: function _open(retry) {
      var _this2 = this;

      if (this.db) {
        this.db.close();
        delete this.db;
      }

      // Abort if all tables are disabled
      var enabledTables = TABLES.filter(function (tableDef) {
        return _this2['_permission_' + tableDef.name];
      });
      if (enabledTables.length === 0) {
        this._isOpenError = true;
        this.trigger('error', { error: 'Persistence is disabled by application' });
        return;
      }

      // Open the database
      var request = window.indexedDB.open(this._getDbName(), DB_VERSION);

      try {
        /* istanbul ignore next */
        request.onerror = function (evt) {
          if (!retry) {
            _this2.deleteTables(function () {
              return _this2._open(true);
            });
          }

          // Triggered by Firefox private browsing window
          else {
              _this2._isOpenError = true;
              logger.warn('Database Unable to Open (common cause: private browsing window)', evt.target.error);
              _this2.trigger('error', { error: evt });
            }
        };

        request.onupgradeneeded = function (evt) {
          return _this2._onUpgradeNeeded(evt);
        };
        request.onsuccess = function (evt) {
          _this2.db = evt.target.result;
          _this2.isOpen = true;
          _this2.trigger('open');

          _this2.db.onversionchange = function () {
            _this2.db.close();
            _this2.isOpen = false;
          };

          _this2.db.onerror = function (err) {
            return logger.error('db-manager Error: ', err);
          };
        };
      }

      /* istanbul ignore next */
      catch (err) {
        // Safari Private Browsing window will fail on request.onerror
        this._isOpenError = true;
        logger.error('Database Unable to Open: ', err);
        this.trigger('error', { error: err });
      }
    }

    /**
     * Use this to setup a call to happen as soon as the database is open.
     *
     * Typically, this call will immediately, synchronously call your callback.
     * But if the DB is not open yet, your callback will be called once its open.
     * @method onOpen
     * @param {Function} callback
     */

  }, {
    key: 'onOpen',
    value: function onOpen(callback) {
      if (this.isOpen || this._isOpenError) callback();else this.once('open error', callback);
    }

    /**
     * The onUpgradeNeeded function is called by IndexedDB any time DB_VERSION is incremented.
     *
     * This invocation is part of the built-in lifecycle of IndexedDB.
     *
     * @method _onUpgradeNeeded
     * @param {IDBVersionChangeEvent} event
     * @private
     */
    /* istanbul ignore next */

  }, {
    key: '_onUpgradeNeeded',
    value: function _onUpgradeNeeded(event) {
      var _this3 = this;

      var db = event.target.result;
      var isComplete = false;

      // This appears to only get called once; its presumed this is because we're creating but not using a lot of transactions.
      var onComplete = function onComplete(evt) {
        if (!isComplete) {
          _this3.db = db;
          _this3.isComplete = true;
          _this3.isOpen = true;
          _this3.trigger('open');
        }
      };

      var currentTables = Array.prototype.slice.call(db.objectStoreNames);
      TABLES.forEach(function (tableDef) {
        try {
          if (currentTables.indexOf(tableDef.name) !== -1) db.deleteObjectStore(tableDef.name);
        } catch (e) {
          // Noop
        }
        try {
          (function () {
            var store = db.createObjectStore(tableDef.name, { keyPath: 'id' });
            Object.keys(tableDef.indexes).forEach(function (indexName) {
              return store.createIndex(indexName, tableDef.indexes[indexName], { unique: false });
            });
            store.transaction.oncomplete = onComplete;
          })();
        } catch (e) {
          // Noop
          /* istanbul ignore next */
          logger.error('Failed to create object store ' + tableDef.name, e);
        }
      });
    }

    /**
     * Convert array of Conversation instances into Conversation DB Entries.
     *
     * A Conversation DB entry looks a lot like the server representation, but
     * includes a sync_state property, and `last_message` contains a message ID not
     * a Message object.
     *
     * @method _getConversationData
     * @private
     * @param {layer.Conversation[]} conversations
     * @return {Object[]} conversations
     */

  }, {
    key: '_getConversationData',
    value: function _getConversationData(conversations) {
      var _this4 = this;

      return conversations.filter(function (conversation) {
        if (conversation._fromDB) {
          conversation._fromDB = false;
          return false;
        } else if (conversation.isLoading || conversation.syncState === SYNC_NEW) {
          return false;
        } else {
          return true;
        }
      }).map(function (conversation) {
        var item = {
          id: conversation.id,
          url: conversation.url,
          participants: _this4._getIdentityData(conversation.participants, true),
          distinct: conversation.distinct,
          created_at: getDate(conversation.createdAt),
          metadata: conversation.metadata,
          unread_message_count: conversation.unreadCount,
          last_message: conversation.lastMessage ? conversation.lastMessage.id : '',
          last_message_sent: conversation.lastMessage ? getDate(conversation.lastMessage.sentAt) : getDate(conversation.createdAt),
          sync_state: conversation.syncState
        };
        return item;
      });
    }
  }, {
    key: '_updateConversation',
    value: function _updateConversation(conversation, changes) {
      var _this5 = this;

      var idChanges = changes.filter(function (item) {
        return item.property === 'id';
      });
      if (idChanges.length) {
        this.deleteObjects('conversations', [{ id: idChanges[0].oldValue }], function () {
          _this5.writeConversations([conversation]);
        });
      } else {
        this.writeConversations([conversation]);
      }
    }

    /**
     * Writes an array of Conversations to the Database.
     *
     * @method writeConversations
     * @param {layer.Conversation[]} conversations - Array of Conversations to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeConversations',
    value: function writeConversations(conversations, callback) {
      this._writeObjects('conversations', this._getConversationData(conversations.filter(function (conversation) {
        return !conversation.isDestroyed;
      })), callback);
    }

    /**
     * Convert array of Channel instances into Channel DB Entries.
     *
     * A Channel DB entry looks a lot like the server representation, but
     * includes a sync_state property, and `last_message` contains a message ID not
     * a Message object.
     *
     * @method _getChannelData
     * @private
     * @param {layer.Channel[]} channels
     * @return {Object[]} channels
     */

  }, {
    key: '_getChannelData',
    value: function _getChannelData(channels) {
      return channels.filter(function (channel) {
        if (channel._fromDB) {
          channel._fromDB = false;
          return false;
        } else if (channel.isLoading || channel.syncState === SYNC_NEW) {
          return false;
        } else {
          return true;
        }
      }).map(function (channel) {
        var item = {
          id: channel.id,
          url: channel.url,
          created_at: getDate(channel.createdAt),
          sync_state: channel.syncState,
          // TODO: membership object should be written... but spec incomplete
          membership: null,
          name: channel.name,
          metadata: channel.metadata
        };
        return item;
      });
    }
  }, {
    key: '_updateChannel',
    value: function _updateChannel(channel, changes) {
      var _this6 = this;

      var idChanges = changes.filter(function (item) {
        return item.property === 'id';
      });
      if (idChanges.length) {
        this.deleteObjects('channels', [{ id: idChanges[0].oldValue }], function () {
          _this6.writeChannels([channel]);
        });
      } else {
        this.writeChannels([channel]);
      }
    }

    /**
     * Writes an array of Conversations to the Database.
     *
     * @method writeChannels
     * @param {layer.Channel[]} channels - Array of Channels to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeChannels',
    value: function writeChannels(channels, callback) {
      this._writeObjects('channels', this._getChannelData(channels.filter(function (channel) {
        return !channel.isDestroyed;
      })), callback);
    }

    /**
     * Convert array of Identity instances into Identity DB Entries.
     *
     * @method _getIdentityData
     * @private
     * @param {layer.Identity[]} identities
     * @param {boolean} writeBasicIdentity - Forces output as a Basic Identity
     * @return {Object[]} identities
     */

  }, {
    key: '_getIdentityData',
    value: function _getIdentityData(identities, writeBasicIdentity) {
      return identities.filter(function (identity) {
        if (identity.isDestroyed || !identity.isFullIdentity && !writeBasicIdentity) return false;

        if (identity._fromDB) {
          identity._fromDB = false;
          return false;
        } else if (identity.isLoading) {
          return false;
        } else {
          return true;
        }
      }).map(function (identity) {
        if (identity.isFullIdentity && !writeBasicIdentity) {
          return {
            id: identity.id,
            url: identity.url,
            user_id: identity.userId,
            first_name: identity.firstName,
            last_name: identity.lastName,
            display_name: identity.displayName,
            avatar_url: identity.avatarUrl,
            metadata: identity.metadata,
            public_key: identity.publicKey,
            phone_number: identity.phoneNumber,
            email_address: identity.emailAddress,
            sync_state: identity.syncState,
            type: identity.type
          };
        } else {
          return {
            id: identity.id,
            url: identity.url,
            user_id: identity.userId,
            display_name: identity.displayName,
            avatar_url: identity.avatarUrl
          };
        }
      });
    }

    /**
     * Writes an array of Identities to the Database.
     *
     * @method writeIdentities
     * @param {layer.Identity[]} identities - Array of Identities to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeIdentities',
    value: function writeIdentities(identities, callback) {
      this._writeObjects('identities', this._getIdentityData(identities), callback);
    }

    /**
     * Convert array of Message instances into Message DB Entries.
     *
     * A Message DB entry looks a lot like the server representation, but
     * includes a sync_state property.
     *
     * @method _getMessageData
     * @private
     * @param {layer.Message[]} messages
     * @param {Function} callback
     * @return {Object[]} messages
     */

  }, {
    key: '_getMessageData',
    value: function _getMessageData(messages, callback) {
      var _this7 = this;

      var dbMessages = messages.filter(function (message) {
        if (message._fromDB) {
          message._fromDB = false;
          return false;
        } else if (message.syncState === Constants.SYNC_STATE.LOADING) {
          return false;
        } else {
          return true;
        }
      }).map(function (message) {
        return {
          id: message.id,
          url: message.url,
          parts: message.parts.map(function (part) {
            var body = Util.isBlob(part.body) && part.body.size > DbManager.MaxPartSize ? null : part.body;
            return {
              body: body,
              id: part.id,
              encoding: part.encoding,
              mime_type: part.mimeType,
              content: !part._content ? null : {
                id: part._content.id,
                download_url: part._content.downloadUrl,
                expiration: part._content.expiration,
                refresh_url: part._content.refreshUrl,
                size: part._content.size
              }
            };
          }),
          position: message.position,
          sender: _this7._getIdentityData([message.sender], true)[0],
          recipient_status: message.recipientStatus,
          sent_at: getDate(message.sentAt),
          received_at: getDate(message.receivedAt),
          conversationId: message instanceof Announcement ? 'announcement' : message.conversationId,
          sync_state: message.syncState,
          is_unread: message.isUnread
        };
      });

      // Find all blobs and convert them to base64... because Safari 9.1 doesn't support writing blobs those Frelling Smurfs.
      var count = 0;
      var parts = [];
      dbMessages.forEach(function (message) {
        message.parts.forEach(function (part) {
          if (Util.isBlob(part.body)) parts.push(part);
        });
      });
      if (parts.length === 0) {
        callback(dbMessages);
      } else {
        parts.forEach(function (part) {
          Util.blobToBase64(part.body, function (base64) {
            part.body = base64;
            part.useBlob = true;
            count++;
            if (count === parts.length) callback(dbMessages);
          });
        });
      }
    }

    /**
     * Writes an array of Messages to the Database.
     *
     * @method writeMessages
     * @param {layer.Message[]} messages - Array of Messages to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeMessages',
    value: function writeMessages(messages, callback) {
      var _this8 = this;

      this._getMessageData(messages.filter(function (message) {
        return !message.isDestroyed;
      }), function (dbMessageData) {
        return _this8._writeObjects('messages', dbMessageData, callback);
      });
    }

    /**
     * Convert array of SyncEvent instances into SyncEvent DB Entries.
     *
     * @method _getSyncEventData
     * @param {layer.SyncEvent[]} syncEvents
     * @return {Object[]} syncEvents
     * @private
     */

  }, {
    key: '_getSyncEventData',
    value: function _getSyncEventData(syncEvents) {
      return syncEvents.filter(function (syncEvt) {
        if (syncEvt.fromDB) {
          syncEvt.fromDB = false;
          return false;
        } else {
          return true;
        }
      }).map(function (syncEvent) {
        var item = {
          id: syncEvent.id,
          target: syncEvent.target,
          depends: syncEvent.depends,
          isWebsocket: syncEvent instanceof SyncEvent.WebsocketSyncEvent,
          operation: syncEvent.operation,
          data: syncEvent.data,
          url: syncEvent.url || '',
          headers: syncEvent.headers || null,
          method: syncEvent.method || null,
          created_at: syncEvent.createdAt
        };
        return item;
      });
    }

    /**
     * Writes an array of SyncEvent to the Database.
     *
     * @method writeSyncEvents
     * @param {layer.SyncEvent[]} syncEvents - Array of Sync Events to write
     * @param {Function} [callback]
     */

  }, {
    key: 'writeSyncEvents',
    value: function writeSyncEvents(syncEvents, callback) {
      this._writeObjects('syncQueue', this._getSyncEventData(syncEvents), callback);
    }

    /**
     * Write an array of data to the specified Database table.
     *
     * @method _writeObjects
     * @param {string} tableName - The name of the table to write to
     * @param {Object[]} data - Array of POJO data to write
     * @param {Function} [callback] - Called when all data is written
     * @protected
     */

  }, {
    key: '_writeObjects',
    value: function _writeObjects(tableName, data, callback) {
      var _this9 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback ? callback() : null;

      // Just quit if no data to write
      if (!data.length) {
        if (callback) callback();
        return;
      }

      // PUT (udpate) or ADD (insert) each item of data one at a time, but all as part of one large transaction.
      this.onOpen(function () {
        _this9.getObjects(tableName, data.map(function (item) {
          return item.id;
        }), function (foundItems) {
          var updateIds = {};
          foundItems.forEach(function (item) {
            updateIds[item.id] = item;
          });

          var transaction = _this9.db.transaction([tableName], 'readwrite');
          var store = transaction.objectStore(tableName);
          transaction.oncomplete = transaction.onerror = callback;

          data.forEach(function (item) {
            try {
              if (updateIds[item.id]) {
                store.put(item);
              } else {
                store.add(item);
              }
            } catch (e) {
              /* istanbul ignore next */
              // Safari throws an error rather than use the onerror event.
              logger.error(e);
            }
          });
        });
      });
    }

    /**
     * Load all conversations from the database.
     *
     * @method loadConversations
     * @param {string} sortBy       - One of 'last_message' or 'created_at'; always sorts in DESC order
     * @param {string} [fromId=]    - For pagination, provide the conversationId to get Conversations after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]  - Callback for getting results
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: 'loadConversations',
    value: function loadConversations(sortBy, fromId, pageSize, callback) {
      var _this10 = this;

      try {
        var sortIndex = void 0,
            range = null;
        var fromConversation = fromId ? this.client.getConversation(fromId) : null;
        if (sortBy === 'last_message') {
          sortIndex = 'last_message_sent';
          if (fromConversation) {
            range = window.IDBKeyRange.upperBound([fromConversation.lastMessage ? getDate(fromConversation.lastMessage.sentAt) : getDate(fromConversation.createdAt)]);
          }
        } else {
          sortIndex = 'created_at';
          if (fromConversation) {
            range = window.IDBKeyRange.upperBound([getDate(fromConversation.createdAt)]);
          }
        }

        // Step 1: Get all Conversations
        this._loadByIndex('conversations', sortIndex, range, Boolean(fromId), pageSize, function (data) {
          // Step 2: Gather all Message IDs needed to initialize these Conversation's lastMessage properties.
          var messagesToLoad = data.map(function (item) {
            return item.last_message;
          }).filter(function (messageId) {
            return messageId && !_this10.client.getMessage(messageId);
          });

          // Step 3: Load all Messages needed to initialize these Conversation's lastMessage properties.
          _this10.getObjects('messages', messagesToLoad, function (messages) {
            _this10._loadConversationsResult(data, messages, callback);
          });
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Assemble all LastMessages and Conversation POJOs into layer.Message and layer.Conversation instances.
     *
     * @method _loadConversationsResult
     * @private
     * @param {Object[]} conversations
     * @param {Object[]} messages
     * @param {Function} callback
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: '_loadConversationsResult',
    value: function _loadConversationsResult(conversations, messages, callback) {
      var _this11 = this;

      // Instantiate and Register each Message
      messages.forEach(function (message) {
        return _this11._createMessage(message);
      });

      // Instantiate and Register each Conversation; will find any lastMessage that was registered.
      var newData = conversations.map(function (conversation) {
        return _this11._createConversation(conversation) || _this11.client.getConversation(conversation.id);
      }).filter(function (conversation) {
        return conversation;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Load all channels from the database.
     *
     * @method loadChannels
     * @param {string} sortBy       - One of 'last_message' or 'created_at'; always sorts in DESC order
     * @param {string} [fromId=]    - For pagination, provide the channelId to get Channel after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]  - Callback for getting results
     * @param {layer.Channel[]} callback.result
     */

  }, {
    key: 'loadChannels',
    value: function loadChannels(fromId, pageSize, callback) {
      var _this12 = this;

      try {
        var sortIndex = 'created_at';
        var range = null;
        var fromChannel = fromId ? this.client.getChannel(fromId) : null;
        if (fromChannel) {
          range = window.IDBKeyRange.upperBound([getDate(fromChannel.createdAt)]);
        }

        this._loadByIndex('channels', sortIndex, range, Boolean(fromId), pageSize, function (data) {
          _this12._loadChannelsResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Assemble all LastMessages and Conversation POJOs into layer.Message and layer.Conversation instances.
     *
     * @method _loadChannelsResult
     * @private
     * @param {Object[]} channels
     * @param {Function} callback
     * @param {layer.Channel[]} callback.result
     */

  }, {
    key: '_loadChannelsResult',
    value: function _loadChannelsResult(channels, callback) {
      var _this13 = this;

      // Instantiate and Register each Conversation; will find any lastMessage that was registered.
      var newData = channels.map(function (channel) {
        return _this13._createChannel(channel) || _this13.client.getChannel(channel.id);
      }).filter(function (conversation) {
        return conversation;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Load all messages for a given Conversation ID from the database.
     *
     * Use _loadAll if loading All Messages rather than all Messages for a Conversation.
     *
     * @method loadMessages
     * @param {string} conversationId - ID of the Conversation whose Messages are of interest.
     * @param {string} [fromId=]    - For pagination, provide the messageId to get Messages after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]   - Callback for getting results
     * @param {layer.Message[]} callback.result
     */

  }, {
    key: 'loadMessages',
    value: function loadMessages(conversationId, fromId, pageSize, callback) {
      var _this14 = this;

      if (!this['_permission_messages'] || this._isOpenError) return callback([]);
      try {
        var fromMessage = fromId ? this.client.getMessage(fromId) : null;
        var query = window.IDBKeyRange.bound([conversationId, 0], [conversationId, fromMessage ? fromMessage.position : MAX_SAFE_INTEGER]);
        this._loadByIndex('messages', 'conversationId', query, Boolean(fromId), pageSize, function (data) {
          _this14._loadMessagesResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }

    /**
     * Load all Announcements from the database.
     *
     * @method loadAnnouncements
     * @param {string} [fromId=]    - For pagination, provide the messageId to get Announcements after
     * @param {number} [pageSize=]  - To limit the number of results, provide a number for how many results to return.
     * @param {Function} [callback]
     * @param {layer.Announcement[]} callback.result
     */

  }, {
    key: 'loadAnnouncements',
    value: function loadAnnouncements(fromId, pageSize, callback) {
      var _this15 = this;

      if (!this['_permission_messages'] || this._isOpenError) return callback([]);
      try {
        var fromMessage = fromId ? this.client.getMessage(fromId) : null;
        var query = window.IDBKeyRange.bound(['announcement', 0], ['announcement', fromMessage ? fromMessage.position : MAX_SAFE_INTEGER]);
        this._loadByIndex('messages', 'conversationId', query, Boolean(fromId), pageSize, function (data) {
          _this15._loadMessagesResult(data, callback);
        });
      } catch (e) {
        // Noop -- handle browsers like IE that don't like these IDBKeyRanges
      }
    }
  }, {
    key: '_blobifyPart',
    value: function _blobifyPart(part) {
      if (part.useBlob) {
        part.body = Util.base64ToBlob(part.body);
        delete part.useBlob;
        part.encoding = null;
      }
    }

    /**
     * Registers and sorts the message objects from the database.
     *
     * TODO: Encode limits on this, else we are sorting tens of thousands
     * of messages in javascript.
     *
     * @method _loadMessagesResult
     * @private
     * @param {Object[]} Message objects from the database.
     * @param {Function} callback
     * @param {layer.Message} callback.result - Message instances created from the database
     */

  }, {
    key: '_loadMessagesResult',
    value: function _loadMessagesResult(messages, callback) {
      var _this16 = this;

      // Convert base64 to blob before sending it along...
      messages.forEach(function (message) {
        return message.parts.forEach(function (part) {
          return _this16._blobifyPart(part);
        });
      });

      // Instantiate and Register each Message
      var newData = messages.map(function (message) {
        return _this16._createMessage(message) || _this16.client.getMessage(message.id);
      }).filter(function (message) {
        return message;
      });

      // Return the results
      if (callback) callback(newData);
    }

    /**
     * Load all Identities from the database.
     *
     * @method loadIdentities
     * @param {Function} callback
     * @param {layer.Identity[]} callback.result
     */

  }, {
    key: 'loadIdentities',
    value: function loadIdentities(callback) {
      var _this17 = this;

      this._loadAll('identities', function (data) {
        _this17._loadIdentitiesResult(data, callback);
      });
    }

    /**
     * Assemble all LastMessages and Identityy POJOs into layer.Message and layer.Identityy instances.
     *
     * @method _loadIdentitiesResult
     * @private
     * @param {Object[]} identities
     * @param {Function} callback
     * @param {layer.Identity[]} callback.result
     */

  }, {
    key: '_loadIdentitiesResult',
    value: function _loadIdentitiesResult(identities, callback) {
      var _this18 = this;

      // Instantiate and Register each Identity.
      var newData = identities.map(function (identity) {
        return _this18._createIdentity(identity) || _this18.client.getIdentity(identity.id);
      }).filter(function (identity) {
        return identity;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Instantiate and Register the Conversation from a conversation DB Entry.
     *
     * If the layer.Conversation already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * Attempts to assign the lastMessage property to refer to appropriate Message.  If it fails,
     * it will be set to null.
     *
     * @method _createConversation
     * @private
     * @param {Object} conversation
     * @returns {layer.Conversation}
     */

  }, {
    key: '_createConversation',
    value: function _createConversation(conversation) {
      if (!this.client.getConversation(conversation.id)) {
        conversation._fromDB = true;
        var newConversation = this.client._createObject(conversation);
        newConversation.syncState = conversation.sync_state;
        return newConversation;
      }
    }

    /**
     * Instantiate and Register the Channel from a Channel DB Entry.
     *
     * If the layer.Channel already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * Attempts to assign the lastMessage property to refer to appropriate Message.  If it fails,
     * it will be set to null.
     *
     * @method _createChannel
     * @private
     * @param {Object} channel
     * @returns {layer.Channel}
     */

  }, {
    key: '_createChannel',
    value: function _createChannel(channel) {
      if (!this.client.getChannel(channel.id)) {
        channel._fromDB = true;
        var newChannel = this.client._createObject(channel);
        newChannel.syncState = channel.sync_state;
        return newChannel;
      }
    }

    /**
     * Instantiate and Register the Message from a message DB Entry.
     *
     * If the layer.Message already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * @method _createMessage
     * @private
     * @param {Object} message
     * @returns {layer.Message}
     */

  }, {
    key: '_createMessage',
    value: function _createMessage(message) {
      if (!this.client.getMessage(message.id)) {
        message._fromDB = true;
        if (message.conversationId.indexOf('layer:///conversations')) {
          message.conversation = {
            id: message.conversationId
          };
        } else if (message.conversationId.indexOf('layer:///channels')) {
          message.channel = {
            id: message.conversationId
          };
        }
        delete message.conversationId;
        var newMessage = this.client._createObject(message);
        newMessage.syncState = message.sync_state;
        return newMessage;
      }
    }

    /**
     * Instantiate and Register the Identity from an identities DB Entry.
     *
     * If the layer.Identity already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * @method _createIdentity
     * @param {Object} identity
     * @returns {layer.Identity}
     */

  }, {
    key: '_createIdentity',
    value: function _createIdentity(identity) {
      if (!this.client.getIdentity(identity.id)) {
        identity._fromDB = true;
        var newidentity = this.client._createObject(identity);
        newidentity.syncState = identity.sync_state;
        return newidentity;
      }
    }

    /**
     * Load all Sync Events from the database.
     *
     * @method loadSyncQueue
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: 'loadSyncQueue',
    value: function loadSyncQueue(callback) {
      var _this19 = this;

      this._loadAll('syncQueue', function (syncEvents) {
        return _this19._loadSyncEventRelatedData(syncEvents, callback);
      });
    }

    /**
     * Validate that we have appropriate data for each SyncEvent and instantiate it.
     *
     * Any operation that is not a DELETE must have a valid target found in the database or javascript cache,
     * otherwise it can not be executed.
     *
     * TODO: Need to cleanup sync entries that have invalid targets
     *
     * @method _loadSyncEventRelatedData
     * @private
     * @param {Object[]} syncEvents
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventRelatedData',
    value: function _loadSyncEventRelatedData(syncEvents, callback) {
      var _this20 = this;

      // Gather all Message IDs that are targets of operations.
      var messageIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/messages/);
      }).map(function (item) {
        return item.target;
      });

      // Gather all Conversation IDs that are targets of operations.
      var conversationIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/conversations/);
      }).map(function (item) {
        return item.target;
      });

      var identityIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/identities/);
      }).map(function (item) {
        return item.target;
      });

      // Load any Messages/Conversations that are targets of operations.
      // Call _createMessage or _createConversation on all targets found.
      var counter = 0;
      var maxCounter = 3;
      this.getObjects('messages', messageIds, function (messages) {
        messages.forEach(function (message) {
          return _this20._createMessage(message);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
      this.getObjects('conversations', conversationIds, function (conversations) {
        conversations.forEach(function (conversation) {
          return _this20._createConversation(conversation);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
      this.getObjects('identities', identityIds, function (identities) {
        identities.forEach(function (identity) {
          return _this20._createIdentity(identity);
        });
        counter++;
        if (counter === maxCounter) _this20._loadSyncEventResults(syncEvents, callback);
      });
    }

    /**
     * Turn an array of Sync Event DB Entries into an array of layer.SyncEvent.
     *
     * @method _loadSyncEventResults
     * @private
     * @param {Object[]} syncEvents
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventResults',
    value: function _loadSyncEventResults(syncEvents, callback) {
      var _this21 = this;

      // If the target is present in the sync event, but does not exist in the system,
      // do NOT attempt to instantiate this event... unless its a DELETE operation.
      var newData = syncEvents.filter(function (syncEvent) {
        var hasTarget = Boolean(syncEvent.target && _this21.client.getObject(syncEvent.target));
        return syncEvent.operation === 'DELETE' || hasTarget;
      }).map(function (syncEvent) {
        if (syncEvent.isWebsocket) {
          return new SyncEvent.WebsocketSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        } else {
          return new SyncEvent.XHRSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            method: syncEvent.method,
            headers: syncEvent.headers,
            url: syncEvent.url,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        }
      });

      // Sort the results and then return them.
      // TODO: Query results should come back sorted by database with proper Index
      Util.sortBy(newData, function (item) {
        return item.createdAt;
      });
      callback(newData);
    }

    /**
     * Load all data from the specified table.
     *
     * @method _loadAll
     * @protected
     * @param {String} tableName
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadAll',
    value: function _loadAll(tableName, callback) {
      var _this22 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      this.onOpen(function () {
        var data = [];
        _this22.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this22.isDestroyed) return;
          var cursor = evt.target.result;
          if (cursor) {
            data.push(cursor.value);
            cursor.continue();
          } else if (!_this22.isDestroyed) {
            /* istanbul ignore next */
            callback(data);
          }
        };
      });
    }

    /**
     * Load all data from the specified table and with the specified index value.
     *
     * Results are always sorted in DESC order at this time.
     *
     * @method _loadByIndex
     * @protected
     * @param {String} tableName - 'messages', 'conversations', 'identities'
     * @param {String} indexName - Name of the index to query on
     * @param {IDBKeyRange} range - Range to Query for (null ok)
     * @param {Boolean} isFromId - If querying for results after a specified ID, then we want to skip the first result (which will be that ID) ("" is OK)
     * @param {number} pageSize - If a value is provided, return at most that number of results; else return all results.
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadByIndex',
    value: function _loadByIndex(tableName, indexName, range, isFromId, pageSize, callback) {
      var _this23 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      var shouldSkipNext = isFromId;
      this.onOpen(function () {
        var data = [];
        _this23.db.transaction([tableName], 'readonly').objectStore(tableName).index(indexName).openCursor(range, 'prev').onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this23.isDestroyed) return;
          var cursor = evt.target.result;
          if (cursor) {
            if (shouldSkipNext) {
              shouldSkipNext = false;
            } else {
              data.push(cursor.value);
            }
            if (pageSize && data.length >= pageSize) {
              callback(data);
            } else {
              cursor.continue();
            }
          } else {
            callback(data);
          }
        };
      });
    }

    /**
     * Deletes the specified objects from the specified table.
     *
     * Currently takes an array of data to delete rather than an array of IDs;
     * If you only have an ID, [{id: myId}] should work.
     *
     * @method deleteObjects
     * @param {String} tableName
     * @param {Object[]} data
     * @param {Function} [callback]
     */

  }, {
    key: 'deleteObjects',
    value: function deleteObjects(tableName, data, callback) {
      var _this24 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback ? callback() : null;
      this.onOpen(function () {
        var transaction = _this24.db.transaction([tableName], 'readwrite');
        var store = transaction.objectStore(tableName);
        transaction.oncomplete = callback;
        data.forEach(function (item) {
          return store.delete(item.id);
        });
      });
    }

    /**
     * Retrieve the identified objects from the specified database table.
     *
     * Turning these into instances is the responsibility of the caller.
     *
     * Inspired by http://www.codeproject.com/Articles/744986/How-to-do-some-magic-with-indexedDB
     *
     * @method getObjects
     * @param {String} tableName
     * @param {String[]} ids
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: 'getObjects',
    value: function getObjects(tableName, ids, callback) {
      var _this25 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback([]);
      var data = [];

      // Gather, sort, and filter replica IDs
      var sortedIds = ids.sort();
      for (var i = sortedIds.length - 1; i > 0; i--) {
        if (sortedIds[i] === sortedIds[i - 1]) sortedIds.splice(i, 1);
      }
      var index = 0;

      // Iterate over the table searching for the specified IDs
      this.onOpen(function () {
        _this25.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          /* istanbul ignore next */
          if (_this25.isDestroyed) return;
          var cursor = evt.target.result;
          if (!cursor) {
            callback(data);
            return;
          }
          var key = cursor.key;

          // The cursor has passed beyond this key. Check next.
          while (key > sortedIds[index]) {
            index++;
          } // The cursor is pointing at one of our IDs, get it and check next.
          if (key === sortedIds[index]) {
            data.push(cursor.value);
            index++;
          }

          // Done or check next
          if (index === sortedIds.length) {
            /* istanbul ignore else */
            if (!_this25.isDestroyed) callback(data);
          } else {
            cursor.continue(sortedIds[index]);
          }
        };
      });
    }

    /**
     * A simplified getObjects() method that gets a single object, and also gets its related objects.
     *
     * @method getObject
     * @param {string} tableName
     * @param {string} id
     * @param {Function} callback
     * @param {Object} callback.data
     */

  }, {
    key: 'getObject',
    value: function getObject(tableName, id, callback) {
      var _this26 = this;

      if (!this['_permission_' + tableName] || this._isOpenError) return callback();

      this.onOpen(function () {
        _this26.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor(window.IDBKeyRange.only(id)).onsuccess = function (evt) {
          var cursor = evt.target.result;
          if (!cursor) return callback(null);

          switch (tableName) {
            case 'messages':
              // Convert base64 to blob before sending it along...
              cursor.value.parts.forEach(function (part) {
                return _this26._blobifyPart(part);
              });
              return callback(cursor.value);
            case 'identities':
            case 'channels':
              return callback(cursor.value);
            case 'conversations':
              if (cursor.value.last_message) {
                var lastMessage = _this26.client.getMessage(cursor.value.last_message);
                if (lastMessage) {
                  return _this26._getMessageData([lastMessage], function (messages) {
                    cursor.value.last_message = messages[0];
                    callback(cursor.value);
                  });
                } else {
                  return _this26.getObject('messages', cursor.value.last_message, function (message) {
                    cursor.value.last_message = message;
                    callback(cursor.value);
                  });
                }
              } else {
                return callback(cursor.value);
              }
          }
        };
      });
    }

    /**
     * Claim a Sync Event.
     *
     * A sync event is claimed by locking the table,  validating that it is still in the table... and then deleting it from the table.
     *
     * @method claimSyncEvent
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Boolean} callback.result
     */

  }, {
    key: 'claimSyncEvent',
    value: function claimSyncEvent(syncEvent, callback) {
      var _this27 = this;

      if (!this._permission_syncQueue || this._isOpenError) return callback(true);
      this.onOpen(function () {
        var transaction = _this27.db.transaction(['syncQueue'], 'readwrite');
        var store = transaction.objectStore('syncQueue');
        store.get(syncEvent.id).onsuccess = function (evt) {
          return callback(Boolean(evt.target.result));
        };
        store.delete(syncEvent.id);
      });
    }

    /**
     * Delete all data from all tables.
     *
     * This should be called from layer.Client.logout()
     *
     * @method deleteTables
     * @param {Function} [calllback]
     */

  }, {
    key: 'deleteTables',
    value: function deleteTables() {
      var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

      try {
        var request = window.indexedDB.deleteDatabase(this._getDbName());
        request.onsuccess = request.onerror = callback;
        delete this.db;
      } catch (e) {
        logger.error('Failed to delete database', e);
        if (callback) callback(e);
      }
    }
  }]);

  return DbManager;
}(Root);

/**
 * @type {layer.Client} Layer Client instance
 */


DbManager.prototype.client = null;

/**
 * @type {boolean} is the db connection open
 */
DbManager.prototype.isOpen = false;

/**
 * @type {boolean} is the db connection will not open
 * @private
 */
DbManager.prototype._isOpenError = false;

/**
 * @type {boolean} Is reading/writing messages allowed?
 * @private
 */
DbManager.prototype._permission_messages = false;

/**
 * @type {boolean} Is reading/writing conversations allowed?
 * @private
 */
DbManager.prototype._permission_conversations = false;

/**
 * @type {boolean} Is reading/writing channels allowed?
 * @private
 */
DbManager.prototype._permission_channels = false;

/**
 * @type {boolean} Is reading/writing identities allowed?
 * @private
 */
DbManager.prototype._permission_identities = false;

/**
 * @type {boolean} Is reading/writing unsent server requests allowed?
 * @private
 */
DbManager.prototype._permission_syncQueue = false;

/**
 * @type IDBDatabase
 */
DbManager.prototype.db = null;

/**
 * Rich Content may be written to indexeddb and persisted... if its size is less than this number of bytes.
 *
 * This value can be customized; this example only writes Rich Content that is less than 5000 bytes
 *
 *    layer.DbManager.MaxPartSize = 5000;
 *
 * @static
 * @type {Number}
 */
DbManager.MaxPartSize = 250000;

DbManager._supportedEvents = ['open', 'error'].concat(Root._supportedEvents);

Root.initClass.apply(DbManager, [DbManager, 'DbManager']);
module.exports = DbManager;
//# sourceMappingURL=data:application/json;base64,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RUE7OztBQUdBLFVBQVUsU0FBVixDQUFvQixNQUFwQixHQUE2QixLQUE3Qjs7QUFFQTs7OztBQUlBLFVBQVUsU0FBVixDQUFvQixZQUFwQixHQUFtQyxLQUFuQzs7QUFFQTs7OztBQUlBLFVBQVUsU0FBVixDQUFvQixvQkFBcEIsR0FBMkMsS0FBM0M7O0FBRUE7Ozs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IseUJBQXBCLEdBQWdELEtBQWhEOztBQUVBOzs7O0FBSUEsVUFBVSxTQUFWLENBQW9CLG9CQUFwQixHQUEyQyxLQUEzQzs7QUFFQTs7OztBQUlBLFVBQVUsU0FBVixDQUFvQixzQkFBcEIsR0FBNkMsS0FBN0M7O0FBRUE7Ozs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IscUJBQXBCLEdBQTRDLEtBQTVDOztBQUVBOzs7QUFHQSxVQUFVLFNBQVYsQ0FBb0IsRUFBcEIsR0FBeUIsSUFBekI7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxVQUFVLFdBQVYsR0FBd0IsTUFBeEI7O0FBRUEsVUFBVSxnQkFBVixHQUE2QixDQUMzQixNQUQyQixFQUNuQixPQURtQixFQUUzQixNQUYyQixDQUVwQixLQUFLLGdCQUZlLENBQTdCOztBQUlBLEtBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsU0FBckIsRUFBZ0MsQ0FBQyxTQUFELEVBQVksV0FBWixDQUFoQztBQUNBLE9BQU8sT0FBUCxHQUFpQixTQUFqQiIsImZpbGUiOiJkYi1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJzaXN0ZW5jZSBtYW5hZ2VyLlxuICpcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhbGwgaW5kZXhlZERCIGFjY2Vzcy4gIEl0IGlzIG5vdCByZXNwb25zaWJsZSBmb3IgYW55IGxvY2FsU3RvcmFnZSBhY2Nlc3MsIHRob3VnaCBpdCBtYXlcbiAqIHJlY2VpdmUgY29uZmlndXJhdGlvbnMgcmVsYXRlZCB0byBkYXRhIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2UuICBJdCB3aWxsIHNpbXBseSBpZ25vcmUgdGhvc2UgY29uZmlndXJhdGlvbnMuXG4gKlxuICogUmljaCBDb250ZW50IHdpbGwgYmUgd3JpdHRlbiB0byBJbmRleGVkREIgYXMgbG9uZyBhcyBpdHMgc21hbGw7IHNlZSBsYXllci5EYk1hbmFnZXIuTWF4UGFydFNpemUgZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBUT0RPOlxuICogMC4gUmVkZXNpZ24gdGhpcyBzbyB0aGF0IGtub3dsZWRnZSBvZiB0aGUgZGF0YSBpcyBub3QgaGFyZC1jb2RlZCBpblxuICogQGNsYXNzIGxheWVyLkRiTWFuYWdlclxuICogQHByb3RlY3RlZFxuICovXG5cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCBTeW5jRXZlbnQgPSByZXF1aXJlKCcuL3N5bmMtZXZlbnQnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuY29uc3QgQW5ub3VuY2VtZW50ID0gcmVxdWlyZSgnLi9tb2RlbHMvYW5ub3VuY2VtZW50Jyk7XG5cbmNvbnN0IERCX1ZFUlNJT04gPSA1O1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5jb25zdCBTWU5DX05FVyA9IENvbnN0YW50cy5TWU5DX1NUQVRFLk5FVztcblxuZnVuY3Rpb24gZ2V0RGF0ZShpbkRhdGUpIHtcbiAgcmV0dXJuIGluRGF0ZSA/IGluRGF0ZS50b0lTT1N0cmluZygpIDogbnVsbDtcbn1cblxuY29uc3QgVEFCTEVTID0gW1xuICB7XG4gICAgbmFtZTogJ2NvbnZlcnNhdGlvbnMnLFxuICAgIGluZGV4ZXM6IHtcbiAgICAgIGNyZWF0ZWRfYXQ6IFsnY3JlYXRlZF9hdCddLFxuICAgICAgbGFzdF9tZXNzYWdlX3NlbnQ6IFsnbGFzdF9tZXNzYWdlX3NlbnQnXSxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgbmFtZTogJ2NoYW5uZWxzJyxcbiAgICBpbmRleGVzOiB7XG4gICAgICBjcmVhdGVkX2F0OiBbJ2NyZWF0ZWRfYXQnXSxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgbmFtZTogJ21lc3NhZ2VzJyxcbiAgICBpbmRleGVzOiB7XG4gICAgICBjb252ZXJzYXRpb25JZDogWydjb252ZXJzYXRpb25JZCcsICdwb3NpdGlvbiddLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaWRlbnRpdGllcycsXG4gICAgaW5kZXhlczoge30sXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnc3luY1F1ZXVlJyxcbiAgICBpbmRleGVzOiB7fSxcbiAgfSxcbl07XG5cbmNsYXNzIERiTWFuYWdlciBleHRlbmRzIFJvb3Qge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERCIE1hbmFnZXJcbiAgICpcbiAgICogS2V5IGNvbmZpZ3VyYXRpb24gaXMgdGhlIGxheWVyLkRiTWFuYWdlci5wZXJzaXN0ZW5jZUZlYXR1cmVzIHByb3BlcnR5LlxuICAgKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBvcHRpb25zLmNsaWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wZXJzaXN0ZW5jZUZlYXR1cmVzXG4gICAqIEByZXR1cm4ge2xheWVyLkRiTWFuYWdlcn0gdGhpc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgLy8gSWYgbm8gaW5kZXhlZERCLCB0cmVhdCBldmVyeXRoaW5nIGFzIGRpc2FibGVkLlxuICAgIGlmICghd2luZG93LmluZGV4ZWREQiB8fCAhb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBvcHRpb25zLnRhYmxlcyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUZXN0IGlmIEFycmF5cyBhcyBrZXlzIHN1cHBvcnRlZCwgZGlzYWJsZSBwZXJzaXN0ZW5jZSBpZiBub3RcbiAgICAgIGxldCBlbmFibGVkID0gdHJ1ZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5JREJLZXlSYW5nZS5ib3VuZChbJ2Fubm91bmNlbWVudCcsIDBdLCBbJ2Fubm91bmNlbWVudCcsIE1BWF9TQUZFX0lOVEVHRVJdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3B0aW9ucy50YWJsZXMgPSB7fTtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBDbGllbnQgaXMgYSBsYXllci5DbGllbnRBdXRoZW50aWNhdG9yLCBpdCB3b24ndCBzdXBwb3J0IHRoZXNlIGV2ZW50czsgdGhpcyBhZmZlY3RzIFVuaXQgVGVzdHNcbiAgICAgIGlmIChlbmFibGVkICYmIHRoaXMuY2xpZW50LmNvbnN0cnVjdG9yLl9zdXBwb3J0ZWRFdmVudHMuaW5kZXhPZignY29udmVyc2F0aW9uczphZGQnKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5jbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6YWRkJywgZXZ0ID0+IHRoaXMud3JpdGVDb252ZXJzYXRpb25zKGV2dC5jb252ZXJzYXRpb25zKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2xpZW50Lm9uKCdjb252ZXJzYXRpb25zOmNoYW5nZScsIGV2dCA9PiB0aGlzLl91cGRhdGVDb252ZXJzYXRpb24oZXZ0LnRhcmdldCwgZXZ0LmNoYW5nZXMpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6ZGVsZXRlIGNvbnZlcnNhdGlvbnM6c2VudC1lcnJvcicsXG4gICAgICAgICAgZXZ0ID0+IHRoaXMuZGVsZXRlT2JqZWN0cygnY29udmVyc2F0aW9ucycsIFtldnQudGFyZ2V0XSksIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2xpZW50Lm9uKCdjaGFubmVsczphZGQnLCBldnQgPT4gdGhpcy53cml0ZUNoYW5uZWxzKGV2dC5jaGFubmVscyksIHRoaXMpO1xuICAgICAgICB0aGlzLmNsaWVudC5vbignY2hhbm5lbHM6Y2hhbmdlJywgZXZ0ID0+IHRoaXMuX3VwZGF0ZUNoYW5uZWwoZXZ0LnRhcmdldCwgZXZ0LmNoYW5nZXMpLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jbGllbnQub24oJ2NoYW5uZWxzOmRlbGV0ZSBjaGFubmVsczpzZW50LWVycm9yJyxcbiAgICAgICAgICBldnQgPT4gdGhpcy5kZWxldGVPYmplY3RzKCdjaGFubmVscycsIFtldnQudGFyZ2V0XSksIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2xpZW50Lm9uKCdtZXNzYWdlczphZGQnLCBldnQgPT4gdGhpcy53cml0ZU1lc3NhZ2VzKGV2dC5tZXNzYWdlcyksIHRoaXMpO1xuICAgICAgICB0aGlzLmNsaWVudC5vbignbWVzc2FnZXM6Y2hhbmdlJywgZXZ0ID0+IHRoaXMud3JpdGVNZXNzYWdlcyhbZXZ0LnRhcmdldF0pLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jbGllbnQub24oJ21lc3NhZ2VzOmRlbGV0ZSBtZXNzYWdlczpzZW50LWVycm9yJyxcbiAgICAgICAgICBldnQgPT4gdGhpcy5kZWxldGVPYmplY3RzKCdtZXNzYWdlcycsIFtldnQudGFyZ2V0XSksIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuY2xpZW50Lm9uKCdpZGVudGl0aWVzOmFkZCcsIGV2dCA9PiB0aGlzLndyaXRlSWRlbnRpdGllcyhldnQuaWRlbnRpdGllcyksIHRoaXMpO1xuICAgICAgICB0aGlzLmNsaWVudC5vbignaWRlbnRpdGllczpjaGFuZ2UnLCBldnQgPT4gdGhpcy53cml0ZUlkZW50aXRpZXMoW2V2dC50YXJnZXRdKSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2xpZW50Lm9uKCdpZGVudGl0aWVzOnVuZm9sbG93JywgZXZ0ID0+IHRoaXMuZGVsZXRlT2JqZWN0cygnaWRlbnRpdGllcycsIFtldnQudGFyZ2V0XSksIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTeW5jIFF1ZXVlIG9ubHkgcmVhbGx5IHdvcmtzIHByb3Blcmx5IGlmIHdlIGhhdmUgdGhlIE1lc3NhZ2VzIGFuZCBDb252ZXJzYXRpb25zIHdyaXR0ZW4gdG8gdGhlIERCOyB0dXJuIGl0IG9mZlxuICAgICAgLy8gaWYgdGhhdCB3b24ndCBiZSB0aGUgY2FzZS5cbiAgICAgIGlmICgoIW9wdGlvbnMudGFibGVzLmNvbnZlcnNhdGlvbnMgJiYgIW9wdGlvbnMudGFibGVzLmNoYW5uZWxzKSB8fCAhb3B0aW9ucy50YWJsZXMubWVzc2FnZXMpIHtcbiAgICAgICAgb3B0aW9ucy50YWJsZXMuc3luY1F1ZXVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVEFCTEVTLmZvckVhY2goKHRhYmxlRGVmKSA9PiB7XG4gICAgICB0aGlzWydfcGVybWlzc2lvbl8nICsgdGFibGVEZWYubmFtZV0gPSBCb29sZWFuKG9wdGlvbnMudGFibGVzW3RhYmxlRGVmLm5hbWVdKTtcbiAgICB9KTtcbiAgICB0aGlzLl9vcGVuKGZhbHNlKTtcbiAgfVxuXG4gIF9nZXREYk5hbWUoKSB7XG4gICAgcmV0dXJuICdMYXllcldlYlNES18nICsgdGhpcy5jbGllbnQuYXBwSWQ7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgRGF0YWJhc2UgQ29ubmVjdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyBvbmx5IGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAqIEBtZXRob2QgX29wZW5cbiAgICogQHBhcmFtIHtCb29sZWFufSByZXRyeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW4ocmV0cnkpIHtcbiAgICBpZiAodGhpcy5kYikge1xuICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZGI7XG4gICAgfVxuXG4gICAgLy8gQWJvcnQgaWYgYWxsIHRhYmxlcyBhcmUgZGlzYWJsZWRcbiAgICBjb25zdCBlbmFibGVkVGFibGVzID0gVEFCTEVTLmZpbHRlcih0YWJsZURlZiA9PiB0aGlzWydfcGVybWlzc2lvbl8nICsgdGFibGVEZWYubmFtZV0pO1xuICAgIGlmIChlbmFibGVkVGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5faXNPcGVuRXJyb3IgPSB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicsIHsgZXJyb3I6ICdQZXJzaXN0ZW5jZSBpcyBkaXNhYmxlZCBieSBhcHBsaWNhdGlvbicgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3BlbiB0aGUgZGF0YWJhc2VcbiAgICBjb25zdCByZXF1ZXN0ID0gd2luZG93LmluZGV4ZWREQi5vcGVuKHRoaXMuX2dldERiTmFtZSgpLCBEQl9WRVJTSU9OKTtcblxuICAgIHRyeSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2dCkgPT4ge1xuICAgICAgICBpZiAoIXJldHJ5KSB7XG4gICAgICAgICAgdGhpcy5kZWxldGVUYWJsZXMoKCkgPT4gdGhpcy5fb3Blbih0cnVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmlnZ2VyZWQgYnkgRmlyZWZveCBwcml2YXRlIGJyb3dzaW5nIHdpbmRvd1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pc09wZW5FcnJvciA9IHRydWU7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0RhdGFiYXNlIFVuYWJsZSB0byBPcGVuIChjb21tb24gY2F1c2U6IHByaXZhdGUgYnJvd3Npbmcgd2luZG93KScsIGV2dC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InLCB7IGVycm9yOiBldnQgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZXZ0ID0+IHRoaXMuX29uVXBncmFkZU5lZWRlZChldnQpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgIHRoaXMuZGIgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW4nKTtcblxuICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRiLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRiLm9uZXJyb3IgPSBlcnIgPT4gbG9nZ2VyLmVycm9yKCdkYi1tYW5hZ2VyIEVycm9yOiAnLCBlcnIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFNhZmFyaSBQcml2YXRlIEJyb3dzaW5nIHdpbmRvdyB3aWxsIGZhaWwgb24gcmVxdWVzdC5vbmVycm9yXG4gICAgICB0aGlzLl9pc09wZW5FcnJvciA9IHRydWU7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFiYXNlIFVuYWJsZSB0byBPcGVuOiAnLCBlcnIpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicsIHsgZXJyb3I6IGVyciB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gc2V0dXAgYSBjYWxsIHRvIGhhcHBlbiBhcyBzb29uIGFzIHRoZSBkYXRhYmFzZSBpcyBvcGVuLlxuICAgKlxuICAgKiBUeXBpY2FsbHksIHRoaXMgY2FsbCB3aWxsIGltbWVkaWF0ZWx5LCBzeW5jaHJvbm91c2x5IGNhbGwgeW91ciBjYWxsYmFjay5cbiAgICogQnV0IGlmIHRoZSBEQiBpcyBub3Qgb3BlbiB5ZXQsIHlvdXIgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBpdHMgb3Blbi5cbiAgICogQG1ldGhvZCBvbk9wZW5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uT3BlbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzT3BlbiB8fCB0aGlzLl9pc09wZW5FcnJvcikgY2FsbGJhY2soKTtcbiAgICBlbHNlIHRoaXMub25jZSgnb3BlbiBlcnJvcicsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb25VcGdyYWRlTmVlZGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBJbmRleGVkREIgYW55IHRpbWUgREJfVkVSU0lPTiBpcyBpbmNyZW1lbnRlZC5cbiAgICpcbiAgICogVGhpcyBpbnZvY2F0aW9uIGlzIHBhcnQgb2YgdGhlIGJ1aWx0LWluIGxpZmVjeWNsZSBvZiBJbmRleGVkREIuXG4gICAqXG4gICAqIEBtZXRob2QgX29uVXBncmFkZU5lZWRlZFxuICAgKiBAcGFyYW0ge0lEQlZlcnNpb25DaGFuZ2VFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9vblVwZ3JhZGVOZWVkZWQoZXZlbnQpIHtcbiAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgY29uc3QgaXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBhcHBlYXJzIHRvIG9ubHkgZ2V0IGNhbGxlZCBvbmNlOyBpdHMgcHJlc3VtZWQgdGhpcyBpcyBiZWNhdXNlIHdlJ3JlIGNyZWF0aW5nIGJ1dCBub3QgdXNpbmcgYSBsb3Qgb2YgdHJhbnNhY3Rpb25zLlxuICAgIGNvbnN0IG9uQ29tcGxldGUgPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMudHJpZ2dlcignb3BlbicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjdXJyZW50VGFibGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgVEFCTEVTLmZvckVhY2goKHRhYmxlRGVmKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoY3VycmVudFRhYmxlcy5pbmRleE9mKHRhYmxlRGVmLm5hbWUpICE9PSAtMSkgZGIuZGVsZXRlT2JqZWN0U3RvcmUodGFibGVEZWYubmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUodGFibGVEZWYubmFtZSwgeyBrZXlQYXRoOiAnaWQnIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh0YWJsZURlZi5pbmRleGVzKVxuICAgICAgICAgIC5mb3JFYWNoKGluZGV4TmFtZSA9PiBzdG9yZS5jcmVhdGVJbmRleChpbmRleE5hbWUsIHRhYmxlRGVmLmluZGV4ZXNbaW5kZXhOYW1lXSwgeyB1bmlxdWU6IGZhbHNlIH0pKTtcbiAgICAgICAgc3RvcmUudHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IG9uQ29tcGxldGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG9iamVjdCBzdG9yZSAke3RhYmxlRGVmLm5hbWV9YCwgZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhcnJheSBvZiBDb252ZXJzYXRpb24gaW5zdGFuY2VzIGludG8gQ29udmVyc2F0aW9uIERCIEVudHJpZXMuXG4gICAqXG4gICAqIEEgQ29udmVyc2F0aW9uIERCIGVudHJ5IGxvb2tzIGEgbG90IGxpa2UgdGhlIHNlcnZlciByZXByZXNlbnRhdGlvbiwgYnV0XG4gICAqIGluY2x1ZGVzIGEgc3luY19zdGF0ZSBwcm9wZXJ0eSwgYW5kIGBsYXN0X21lc3NhZ2VgIGNvbnRhaW5zIGEgbWVzc2FnZSBJRCBub3RcbiAgICogYSBNZXNzYWdlIG9iamVjdC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0Q29udmVyc2F0aW9uRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBjb252ZXJzYXRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBjb252ZXJzYXRpb25zXG4gICAqL1xuICBfZ2V0Q29udmVyc2F0aW9uRGF0YShjb252ZXJzYXRpb25zKSB7XG4gICAgcmV0dXJuIGNvbnZlcnNhdGlvbnMuZmlsdGVyKChjb252ZXJzYXRpb24pID0+IHtcbiAgICAgIGlmIChjb252ZXJzYXRpb24uX2Zyb21EQikge1xuICAgICAgICBjb252ZXJzYXRpb24uX2Zyb21EQiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGNvbnZlcnNhdGlvbi5pc0xvYWRpbmcgfHwgY29udmVyc2F0aW9uLnN5bmNTdGF0ZSA9PT0gU1lOQ19ORVcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkubWFwKChjb252ZXJzYXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIGlkOiBjb252ZXJzYXRpb24uaWQsXG4gICAgICAgIHVybDogY29udmVyc2F0aW9uLnVybCxcbiAgICAgICAgcGFydGljaXBhbnRzOiB0aGlzLl9nZXRJZGVudGl0eURhdGEoY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cywgdHJ1ZSksXG4gICAgICAgIGRpc3RpbmN0OiBjb252ZXJzYXRpb24uZGlzdGluY3QsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGdldERhdGUoY29udmVyc2F0aW9uLmNyZWF0ZWRBdCksXG4gICAgICAgIG1ldGFkYXRhOiBjb252ZXJzYXRpb24ubWV0YWRhdGEsXG4gICAgICAgIHVucmVhZF9tZXNzYWdlX2NvdW50OiBjb252ZXJzYXRpb24udW5yZWFkQ291bnQsXG4gICAgICAgIGxhc3RfbWVzc2FnZTogY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID8gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLmlkIDogJycsXG4gICAgICAgIGxhc3RfbWVzc2FnZV9zZW50OiBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgP1xuICAgICAgICAgIGdldERhdGUoY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLnNlbnRBdCkgOiBnZXREYXRlKGNvbnZlcnNhdGlvbi5jcmVhdGVkQXQpLFxuICAgICAgICBzeW5jX3N0YXRlOiBjb252ZXJzYXRpb24uc3luY1N0YXRlLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb24sIGNoYW5nZXMpIHtcbiAgICBjb25zdCBpZENoYW5nZXMgPSBjaGFuZ2VzLmZpbHRlcihpdGVtID0+IGl0ZW0ucHJvcGVydHkgPT09ICdpZCcpO1xuICAgIGlmIChpZENoYW5nZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmRlbGV0ZU9iamVjdHMoJ2NvbnZlcnNhdGlvbnMnLCBbeyBpZDogaWRDaGFuZ2VzWzBdLm9sZFZhbHVlIH1dLCAoKSA9PiB7XG4gICAgICAgIHRoaXMud3JpdGVDb252ZXJzYXRpb25zKFtjb252ZXJzYXRpb25dKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyaXRlQ29udmVyc2F0aW9ucyhbY29udmVyc2F0aW9uXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhbiBhcnJheSBvZiBDb252ZXJzYXRpb25zIHRvIHRoZSBEYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCB3cml0ZUNvbnZlcnNhdGlvbnNcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb25bXX0gY29udmVyc2F0aW9ucyAtIEFycmF5IG9mIENvbnZlcnNhdGlvbnMgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgd3JpdGVDb252ZXJzYXRpb25zKGNvbnZlcnNhdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fd3JpdGVPYmplY3RzKCdjb252ZXJzYXRpb25zJyxcbiAgICAgIHRoaXMuX2dldENvbnZlcnNhdGlvbkRhdGEoY29udmVyc2F0aW9ucy5maWx0ZXIoY29udmVyc2F0aW9uID0+ICFjb252ZXJzYXRpb24uaXNEZXN0cm95ZWQpKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXJyYXkgb2YgQ2hhbm5lbCBpbnN0YW5jZXMgaW50byBDaGFubmVsIERCIEVudHJpZXMuXG4gICAqXG4gICAqIEEgQ2hhbm5lbCBEQiBlbnRyeSBsb29rcyBhIGxvdCBsaWtlIHRoZSBzZXJ2ZXIgcmVwcmVzZW50YXRpb24sIGJ1dFxuICAgKiBpbmNsdWRlcyBhIHN5bmNfc3RhdGUgcHJvcGVydHksIGFuZCBgbGFzdF9tZXNzYWdlYCBjb250YWlucyBhIG1lc3NhZ2UgSUQgbm90XG4gICAqIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldENoYW5uZWxEYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2hhbm5lbFtdfSBjaGFubmVsc1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gY2hhbm5lbHNcbiAgICovXG4gIF9nZXRDaGFubmVsRGF0YShjaGFubmVscykge1xuICAgIHJldHVybiBjaGFubmVscy5maWx0ZXIoKGNoYW5uZWwpID0+IHtcbiAgICAgIGlmIChjaGFubmVsLl9mcm9tREIpIHtcbiAgICAgICAgY2hhbm5lbC5fZnJvbURCID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5pc0xvYWRpbmcgfHwgY2hhbm5lbC5zeW5jU3RhdGUgPT09IFNZTkNfTkVXKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcCgoY2hhbm5lbCkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgaWQ6IGNoYW5uZWwuaWQsXG4gICAgICAgIHVybDogY2hhbm5lbC51cmwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGdldERhdGUoY2hhbm5lbC5jcmVhdGVkQXQpLFxuICAgICAgICBzeW5jX3N0YXRlOiBjaGFubmVsLnN5bmNTdGF0ZSxcbiAgICAgICAgLy8gVE9ETzogbWVtYmVyc2hpcCBvYmplY3Qgc2hvdWxkIGJlIHdyaXR0ZW4uLi4gYnV0IHNwZWMgaW5jb21wbGV0ZVxuICAgICAgICBtZW1iZXJzaGlwOiBudWxsLFxuICAgICAgICBuYW1lOiBjaGFubmVsLm5hbWUsXG4gICAgICAgIG1ldGFkYXRhOiBjaGFubmVsLm1ldGFkYXRhLFxuICAgICAgfTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUNoYW5uZWwoY2hhbm5lbCwgY2hhbmdlcykge1xuICAgIGNvbnN0IGlkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wcm9wZXJ0eSA9PT0gJ2lkJyk7XG4gICAgaWYgKGlkQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZGVsZXRlT2JqZWN0cygnY2hhbm5lbHMnLCBbeyBpZDogaWRDaGFuZ2VzWzBdLm9sZFZhbHVlIH1dLCAoKSA9PiB7XG4gICAgICAgIHRoaXMud3JpdGVDaGFubmVscyhbY2hhbm5lbF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVDaGFubmVscyhbY2hhbm5lbF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYW4gYXJyYXkgb2YgQ29udmVyc2F0aW9ucyB0byB0aGUgRGF0YWJhc2UuXG4gICAqXG4gICAqIEBtZXRob2Qgd3JpdGVDaGFubmVsc1xuICAgKiBAcGFyYW0ge2xheWVyLkNoYW5uZWxbXX0gY2hhbm5lbHMgLSBBcnJheSBvZiBDaGFubmVscyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICB3cml0ZUNoYW5uZWxzKGNoYW5uZWxzLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3dyaXRlT2JqZWN0cygnY2hhbm5lbHMnLFxuICAgICAgdGhpcy5fZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbHMuZmlsdGVyKGNoYW5uZWwgPT4gIWNoYW5uZWwuaXNEZXN0cm95ZWQpKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXJyYXkgb2YgSWRlbnRpdHkgaW5zdGFuY2VzIGludG8gSWRlbnRpdHkgREIgRW50cmllcy5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0SWRlbnRpdHlEYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bGF5ZXIuSWRlbnRpdHlbXX0gaWRlbnRpdGllc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdyaXRlQmFzaWNJZGVudGl0eSAtIEZvcmNlcyBvdXRwdXQgYXMgYSBCYXNpYyBJZGVudGl0eVxuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gaWRlbnRpdGllc1xuICAgKi9cbiAgX2dldElkZW50aXR5RGF0YShpZGVudGl0aWVzLCB3cml0ZUJhc2ljSWRlbnRpdHkpIHtcbiAgICByZXR1cm4gaWRlbnRpdGllcy5maWx0ZXIoKGlkZW50aXR5KSA9PiB7XG4gICAgICBpZiAoaWRlbnRpdHkuaXNEZXN0cm95ZWQgfHwgKCFpZGVudGl0eS5pc0Z1bGxJZGVudGl0eSAmJiAhd3JpdGVCYXNpY0lkZW50aXR5KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoaWRlbnRpdHkuX2Zyb21EQikge1xuICAgICAgICBpZGVudGl0eS5fZnJvbURCID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaWRlbnRpdHkuaXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcCgoaWRlbnRpdHkpID0+IHtcbiAgICAgIGlmIChpZGVudGl0eS5pc0Z1bGxJZGVudGl0eSAmJiAhd3JpdGVCYXNpY0lkZW50aXR5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkZW50aXR5LmlkLFxuICAgICAgICAgIHVybDogaWRlbnRpdHkudXJsLFxuICAgICAgICAgIHVzZXJfaWQ6IGlkZW50aXR5LnVzZXJJZCxcbiAgICAgICAgICBmaXJzdF9uYW1lOiBpZGVudGl0eS5maXJzdE5hbWUsXG4gICAgICAgICAgbGFzdF9uYW1lOiBpZGVudGl0eS5sYXN0TmFtZSxcbiAgICAgICAgICBkaXNwbGF5X25hbWU6IGlkZW50aXR5LmRpc3BsYXlOYW1lLFxuICAgICAgICAgIGF2YXRhcl91cmw6IGlkZW50aXR5LmF2YXRhclVybCxcbiAgICAgICAgICBtZXRhZGF0YTogaWRlbnRpdHkubWV0YWRhdGEsXG4gICAgICAgICAgcHVibGljX2tleTogaWRlbnRpdHkucHVibGljS2V5LFxuICAgICAgICAgIHBob25lX251bWJlcjogaWRlbnRpdHkucGhvbmVOdW1iZXIsXG4gICAgICAgICAgZW1haWxfYWRkcmVzczogaWRlbnRpdHkuZW1haWxBZGRyZXNzLFxuICAgICAgICAgIHN5bmNfc3RhdGU6IGlkZW50aXR5LnN5bmNTdGF0ZSxcbiAgICAgICAgICB0eXBlOiBpZGVudGl0eS50eXBlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWRlbnRpdHkuaWQsXG4gICAgICAgICAgdXJsOiBpZGVudGl0eS51cmwsXG4gICAgICAgICAgdXNlcl9pZDogaWRlbnRpdHkudXNlcklkLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZTogaWRlbnRpdHkuZGlzcGxheU5hbWUsXG4gICAgICAgICAgYXZhdGFyX3VybDogaWRlbnRpdHkuYXZhdGFyVXJsLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhbiBhcnJheSBvZiBJZGVudGl0aWVzIHRvIHRoZSBEYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCB3cml0ZUlkZW50aXRpZXNcbiAgICogQHBhcmFtIHtsYXllci5JZGVudGl0eVtdfSBpZGVudGl0aWVzIC0gQXJyYXkgb2YgSWRlbnRpdGllcyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICB3cml0ZUlkZW50aXRpZXMoaWRlbnRpdGllcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl93cml0ZU9iamVjdHMoJ2lkZW50aXRpZXMnLFxuICAgICAgdGhpcy5fZ2V0SWRlbnRpdHlEYXRhKGlkZW50aXRpZXMpLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhcnJheSBvZiBNZXNzYWdlIGluc3RhbmNlcyBpbnRvIE1lc3NhZ2UgREIgRW50cmllcy5cbiAgICpcbiAgICogQSBNZXNzYWdlIERCIGVudHJ5IGxvb2tzIGEgbG90IGxpa2UgdGhlIHNlcnZlciByZXByZXNlbnRhdGlvbiwgYnV0XG4gICAqIGluY2x1ZGVzIGEgc3luY19zdGF0ZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0TWVzc2FnZURhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlW119IG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBtZXNzYWdlc1xuICAgKi9cbiAgX2dldE1lc3NhZ2VEYXRhKG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGRiTWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLl9mcm9tREIpIHtcbiAgICAgICAgbWVzc2FnZS5fZnJvbURCID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zeW5jU3RhdGUgPT09IENvbnN0YW50cy5TWU5DX1NUQVRFLkxPQURJTkcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkubWFwKG1lc3NhZ2UgPT4gKHtcbiAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgdXJsOiBtZXNzYWdlLnVybCxcbiAgICAgIHBhcnRzOiBtZXNzYWdlLnBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gVXRpbC5pc0Jsb2IocGFydC5ib2R5KSAmJiBwYXJ0LmJvZHkuc2l6ZSA+IERiTWFuYWdlci5NYXhQYXJ0U2l6ZSA/IG51bGwgOiBwYXJ0LmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICBlbmNvZGluZzogcGFydC5lbmNvZGluZyxcbiAgICAgICAgICBtaW1lX3R5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgY29udGVudDogIXBhcnQuX2NvbnRlbnQgPyBudWxsIDoge1xuICAgICAgICAgICAgaWQ6IHBhcnQuX2NvbnRlbnQuaWQsXG4gICAgICAgICAgICBkb3dubG9hZF91cmw6IHBhcnQuX2NvbnRlbnQuZG93bmxvYWRVcmwsXG4gICAgICAgICAgICBleHBpcmF0aW9uOiBwYXJ0Ll9jb250ZW50LmV4cGlyYXRpb24sXG4gICAgICAgICAgICByZWZyZXNoX3VybDogcGFydC5fY29udGVudC5yZWZyZXNoVXJsLFxuICAgICAgICAgICAgc2l6ZTogcGFydC5fY29udGVudC5zaXplLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHBvc2l0aW9uOiBtZXNzYWdlLnBvc2l0aW9uLFxuICAgICAgc2VuZGVyOiB0aGlzLl9nZXRJZGVudGl0eURhdGEoW21lc3NhZ2Uuc2VuZGVyXSwgdHJ1ZSlbMF0sXG4gICAgICByZWNpcGllbnRfc3RhdHVzOiBtZXNzYWdlLnJlY2lwaWVudFN0YXR1cyxcbiAgICAgIHNlbnRfYXQ6IGdldERhdGUobWVzc2FnZS5zZW50QXQpLFxuICAgICAgcmVjZWl2ZWRfYXQ6IGdldERhdGUobWVzc2FnZS5yZWNlaXZlZEF0KSxcbiAgICAgIGNvbnZlcnNhdGlvbklkOiBtZXNzYWdlIGluc3RhbmNlb2YgQW5ub3VuY2VtZW50ID8gJ2Fubm91bmNlbWVudCcgOiBtZXNzYWdlLmNvbnZlcnNhdGlvbklkLFxuICAgICAgc3luY19zdGF0ZTogbWVzc2FnZS5zeW5jU3RhdGUsXG4gICAgICBpc191bnJlYWQ6IG1lc3NhZ2UuaXNVbnJlYWQsXG4gICAgfSkpO1xuXG4gICAgLy8gRmluZCBhbGwgYmxvYnMgYW5kIGNvbnZlcnQgdGhlbSB0byBiYXNlNjQuLi4gYmVjYXVzZSBTYWZhcmkgOS4xIGRvZXNuJ3Qgc3VwcG9ydCB3cml0aW5nIGJsb2JzIHRob3NlIEZyZWxsaW5nIFNtdXJmcy5cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZGJNZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBtZXNzYWdlLnBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgaWYgKFV0aWwuaXNCbG9iKHBhcnQuYm9keSkpIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjYWxsYmFjayhkYk1lc3NhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICBVdGlsLmJsb2JUb0Jhc2U2NChwYXJ0LmJvZHksIChiYXNlNjQpID0+IHtcbiAgICAgICAgICBwYXJ0LmJvZHkgPSBiYXNlNjQ7XG4gICAgICAgICAgcGFydC51c2VCbG9iID0gdHJ1ZTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gcGFydHMubGVuZ3RoKSBjYWxsYmFjayhkYk1lc3NhZ2VzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGFuIGFycmF5IG9mIE1lc3NhZ2VzIHRvIHRoZSBEYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCB3cml0ZU1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZVtdfSBtZXNzYWdlcyAtIEFycmF5IG9mIE1lc3NhZ2VzIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHdyaXRlTWVzc2FnZXMobWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZ2V0TWVzc2FnZURhdGEoXG4gICAgICBtZXNzYWdlcy5maWx0ZXIobWVzc2FnZSA9PiAhbWVzc2FnZS5pc0Rlc3Ryb3llZCksXG4gICAgICBkYk1lc3NhZ2VEYXRhID0+IHRoaXMuX3dyaXRlT2JqZWN0cygnbWVzc2FnZXMnLCBkYk1lc3NhZ2VEYXRhLCBjYWxsYmFjaylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXJyYXkgb2YgU3luY0V2ZW50IGluc3RhbmNlcyBpbnRvIFN5bmNFdmVudCBEQiBFbnRyaWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9nZXRTeW5jRXZlbnREYXRhXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IHN5bmNFdmVudHNcbiAgICogQHJldHVybiB7T2JqZWN0W119IHN5bmNFdmVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTeW5jRXZlbnREYXRhKHN5bmNFdmVudHMpIHtcbiAgICByZXR1cm4gc3luY0V2ZW50cy5maWx0ZXIoKHN5bmNFdnQpID0+IHtcbiAgICAgIGlmIChzeW5jRXZ0LmZyb21EQikge1xuICAgICAgICBzeW5jRXZ0LmZyb21EQiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAoKHN5bmNFdmVudCkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgaWQ6IHN5bmNFdmVudC5pZCxcbiAgICAgICAgdGFyZ2V0OiBzeW5jRXZlbnQudGFyZ2V0LFxuICAgICAgICBkZXBlbmRzOiBzeW5jRXZlbnQuZGVwZW5kcyxcbiAgICAgICAgaXNXZWJzb2NrZXQ6IHN5bmNFdmVudCBpbnN0YW5jZW9mIFN5bmNFdmVudC5XZWJzb2NrZXRTeW5jRXZlbnQsXG4gICAgICAgIG9wZXJhdGlvbjogc3luY0V2ZW50Lm9wZXJhdGlvbixcbiAgICAgICAgZGF0YTogc3luY0V2ZW50LmRhdGEsXG4gICAgICAgIHVybDogc3luY0V2ZW50LnVybCB8fCAnJyxcbiAgICAgICAgaGVhZGVyczogc3luY0V2ZW50LmhlYWRlcnMgfHwgbnVsbCxcbiAgICAgICAgbWV0aG9kOiBzeW5jRXZlbnQubWV0aG9kIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IHN5bmNFdmVudC5jcmVhdGVkQXQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGFuIGFycmF5IG9mIFN5bmNFdmVudCB0byB0aGUgRGF0YWJhc2UuXG4gICAqXG4gICAqIEBtZXRob2Qgd3JpdGVTeW5jRXZlbnRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IHN5bmNFdmVudHMgLSBBcnJheSBvZiBTeW5jIEV2ZW50cyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICB3cml0ZVN5bmNFdmVudHMoc3luY0V2ZW50cywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl93cml0ZU9iamVjdHMoJ3N5bmNRdWV1ZScsIHRoaXMuX2dldFN5bmNFdmVudERhdGEoc3luY0V2ZW50cyksIGNhbGxiYWNrKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdyaXRlIGFuIGFycmF5IG9mIGRhdGEgdG8gdGhlIHNwZWNpZmllZCBEYXRhYmFzZSB0YWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBfd3JpdGVPYmplY3RzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGFibGUgdG8gd3JpdGUgdG9cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YSAtIEFycmF5IG9mIFBPSk8gZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQ2FsbGVkIHdoZW4gYWxsIGRhdGEgaXMgd3JpdHRlblxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfd3JpdGVPYmplY3RzKHRhYmxlTmFtZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXNbJ19wZXJtaXNzaW9uXycgKyB0YWJsZU5hbWVdIHx8IHRoaXMuX2lzT3BlbkVycm9yKSByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjaygpIDogbnVsbDtcblxuICAgIC8vIEp1c3QgcXVpdCBpZiBubyBkYXRhIHRvIHdyaXRlXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBVVCAodWRwYXRlKSBvciBBREQgKGluc2VydCkgZWFjaCBpdGVtIG9mIGRhdGEgb25lIGF0IGEgdGltZSwgYnV0IGFsbCBhcyBwYXJ0IG9mIG9uZSBsYXJnZSB0cmFuc2FjdGlvbi5cbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLmdldE9iamVjdHModGFibGVOYW1lLCBkYXRhLm1hcChpdGVtID0+IGl0ZW0uaWQpLCAoZm91bmRJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVJZHMgPSB7fTtcbiAgICAgICAgZm91bmRJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7IHVwZGF0ZUlkc1tpdGVtLmlkXSA9IGl0ZW07IH0pO1xuXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGFibGVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gY2FsbGJhY2s7XG5cbiAgICAgICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVJZHNbaXRlbS5pZF0pIHtcbiAgICAgICAgICAgICAgc3RvcmUucHV0KGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RvcmUuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAvLyBTYWZhcmkgdGhyb3dzIGFuIGVycm9yIHJhdGhlciB0aGFuIHVzZSB0aGUgb25lcnJvciBldmVudC5cbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgY29udmVyc2F0aW9ucyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCBsb2FkQ29udmVyc2F0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydEJ5ICAgICAgIC0gT25lIG9mICdsYXN0X21lc3NhZ2UnIG9yICdjcmVhdGVkX2F0JzsgYWx3YXlzIHNvcnRzIGluIERFU0Mgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tSWQ9XSAgICAtIEZvciBwYWdpbmF0aW9uLCBwcm92aWRlIHRoZSBjb252ZXJzYXRpb25JZCB0byBnZXQgQ29udmVyc2F0aW9ucyBhZnRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplPV0gIC0gVG8gbGltaXQgdGhlIG51bWJlciBvZiByZXN1bHRzLCBwcm92aWRlIGEgbnVtYmVyIGZvciBob3cgbWFueSByZXN1bHRzIHRvIHJldHVybi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAgLSBDYWxsYmFjayBmb3IgZ2V0dGluZyByZXN1bHRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9uW119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgbG9hZENvbnZlcnNhdGlvbnMoc29ydEJ5LCBmcm9tSWQsIHBhZ2VTaXplLCBjYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgc29ydEluZGV4LFxuICAgICAgICByYW5nZSA9IG51bGw7XG4gICAgICBjb25zdCBmcm9tQ29udmVyc2F0aW9uID0gZnJvbUlkID8gdGhpcy5jbGllbnQuZ2V0Q29udmVyc2F0aW9uKGZyb21JZCkgOiBudWxsO1xuICAgICAgaWYgKHNvcnRCeSA9PT0gJ2xhc3RfbWVzc2FnZScpIHtcbiAgICAgICAgc29ydEluZGV4ID0gJ2xhc3RfbWVzc2FnZV9zZW50JztcbiAgICAgICAgaWYgKGZyb21Db252ZXJzYXRpb24pIHtcbiAgICAgICAgICByYW5nZSA9IHdpbmRvdy5JREJLZXlSYW5nZS51cHBlckJvdW5kKFtmcm9tQ29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID9cbiAgICAgICAgICAgIGdldERhdGUoZnJvbUNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5zZW50QXQpIDogZ2V0RGF0ZShmcm9tQ29udmVyc2F0aW9uLmNyZWF0ZWRBdCldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ydEluZGV4ID0gJ2NyZWF0ZWRfYXQnO1xuICAgICAgICBpZiAoZnJvbUNvbnZlcnNhdGlvbikge1xuICAgICAgICAgIHJhbmdlID0gd2luZG93LklEQktleVJhbmdlLnVwcGVyQm91bmQoW2dldERhdGUoZnJvbUNvbnZlcnNhdGlvbi5jcmVhdGVkQXQpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3RlcCAxOiBHZXQgYWxsIENvbnZlcnNhdGlvbnNcbiAgICAgIHRoaXMuX2xvYWRCeUluZGV4KCdjb252ZXJzYXRpb25zJywgc29ydEluZGV4LCByYW5nZSwgQm9vbGVhbihmcm9tSWQpLCBwYWdlU2l6ZSwgKGRhdGEpID0+IHtcbiAgICAgICAgLy8gU3RlcCAyOiBHYXRoZXIgYWxsIE1lc3NhZ2UgSURzIG5lZWRlZCB0byBpbml0aWFsaXplIHRoZXNlIENvbnZlcnNhdGlvbidzIGxhc3RNZXNzYWdlIHByb3BlcnRpZXMuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzVG9Mb2FkID0gZGF0YVxuICAgICAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLmxhc3RfbWVzc2FnZSlcbiAgICAgICAgICAuZmlsdGVyKG1lc3NhZ2VJZCA9PiBtZXNzYWdlSWQgJiYgIXRoaXMuY2xpZW50LmdldE1lc3NhZ2UobWVzc2FnZUlkKSk7XG5cbiAgICAgICAgLy8gU3RlcCAzOiBMb2FkIGFsbCBNZXNzYWdlcyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSB0aGVzZSBDb252ZXJzYXRpb24ncyBsYXN0TWVzc2FnZSBwcm9wZXJ0aWVzLlxuICAgICAgICB0aGlzLmdldE9iamVjdHMoJ21lc3NhZ2VzJywgbWVzc2FnZXNUb0xvYWQsIChtZXNzYWdlcykgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvYWRDb252ZXJzYXRpb25zUmVzdWx0KGRhdGEsIG1lc3NhZ2VzLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gTm9vcCAtLSBoYW5kbGUgYnJvd3NlcnMgbGlrZSBJRSB0aGF0IGRvbid0IGxpa2UgdGhlc2UgSURCS2V5UmFuZ2VzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGFsbCBMYXN0TWVzc2FnZXMgYW5kIENvbnZlcnNhdGlvbiBQT0pPcyBpbnRvIGxheWVyLk1lc3NhZ2UgYW5kIGxheWVyLkNvbnZlcnNhdGlvbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRDb252ZXJzYXRpb25zUmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnZlcnNhdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb25bXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBfbG9hZENvbnZlcnNhdGlvbnNSZXN1bHQoY29udmVyc2F0aW9ucywgbWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgLy8gSW5zdGFudGlhdGUgYW5kIFJlZ2lzdGVyIGVhY2ggTWVzc2FnZVxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB0aGlzLl9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIGFuZCBSZWdpc3RlciBlYWNoIENvbnZlcnNhdGlvbjsgd2lsbCBmaW5kIGFueSBsYXN0TWVzc2FnZSB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgIGNvbnN0IG5ld0RhdGEgPSBjb252ZXJzYXRpb25zXG4gICAgICAubWFwKGNvbnZlcnNhdGlvbiA9PiB0aGlzLl9jcmVhdGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSB8fCB0aGlzLmNsaWVudC5nZXRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uLmlkKSlcbiAgICAgIC5maWx0ZXIoY29udmVyc2F0aW9uID0+IGNvbnZlcnNhdGlvbik7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhdGFcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG5ld0RhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIGNoYW5uZWxzIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRDaGFubmVsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydEJ5ICAgICAgIC0gT25lIG9mICdsYXN0X21lc3NhZ2UnIG9yICdjcmVhdGVkX2F0JzsgYWx3YXlzIHNvcnRzIGluIERFU0Mgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tSWQ9XSAgICAtIEZvciBwYWdpbmF0aW9uLCBwcm92aWRlIHRoZSBjaGFubmVsSWQgdG8gZ2V0IENoYW5uZWwgYWZ0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZT1dICAtIFRvIGxpbWl0IHRoZSBudW1iZXIgb2YgcmVzdWx0cywgcHJvdmlkZSBhIG51bWJlciBmb3IgaG93IG1hbnkgcmVzdWx0cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gIC0gQ2FsbGJhY2sgZm9yIGdldHRpbmcgcmVzdWx0c1xuICAgKiBAcGFyYW0ge2xheWVyLkNoYW5uZWxbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBsb2FkQ2hhbm5lbHMoZnJvbUlkLCBwYWdlU2l6ZSwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc29ydEluZGV4ID0gJ2NyZWF0ZWRfYXQnO1xuICAgICAgbGV0IHJhbmdlID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyb21DaGFubmVsID0gZnJvbUlkID8gdGhpcy5jbGllbnQuZ2V0Q2hhbm5lbChmcm9tSWQpIDogbnVsbDtcbiAgICAgIGlmIChmcm9tQ2hhbm5lbCkge1xuICAgICAgICByYW5nZSA9IHdpbmRvdy5JREJLZXlSYW5nZS51cHBlckJvdW5kKFtnZXREYXRlKGZyb21DaGFubmVsLmNyZWF0ZWRBdCldKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbG9hZEJ5SW5kZXgoJ2NoYW5uZWxzJywgc29ydEluZGV4LCByYW5nZSwgQm9vbGVhbihmcm9tSWQpLCBwYWdlU2l6ZSwgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5fbG9hZENoYW5uZWxzUmVzdWx0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIE5vb3AgLS0gaGFuZGxlIGJyb3dzZXJzIGxpa2UgSUUgdGhhdCBkb24ndCBsaWtlIHRoZXNlIElEQktleVJhbmdlc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBhbGwgTGFzdE1lc3NhZ2VzIGFuZCBDb252ZXJzYXRpb24gUE9KT3MgaW50byBsYXllci5NZXNzYWdlIGFuZCBsYXllci5Db252ZXJzYXRpb24gaW5zdGFuY2VzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkQ2hhbm5lbHNSZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY2hhbm5lbHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5DaGFubmVsW119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRDaGFubmVsc1Jlc3VsdChjaGFubmVscywgY2FsbGJhY2spIHtcbiAgICAvLyBJbnN0YW50aWF0ZSBhbmQgUmVnaXN0ZXIgZWFjaCBDb252ZXJzYXRpb247IHdpbGwgZmluZCBhbnkgbGFzdE1lc3NhZ2UgdGhhdCB3YXMgcmVnaXN0ZXJlZC5cbiAgICBjb25zdCBuZXdEYXRhID0gY2hhbm5lbHNcbiAgICAgIC5tYXAoY2hhbm5lbCA9PiB0aGlzLl9jcmVhdGVDaGFubmVsKGNoYW5uZWwpIHx8IHRoaXMuY2xpZW50LmdldENoYW5uZWwoY2hhbm5lbC5pZCkpXG4gICAgICAuZmlsdGVyKGNvbnZlcnNhdGlvbiA9PiBjb252ZXJzYXRpb24pO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBkYXRhXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhuZXdEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBtZXNzYWdlcyBmb3IgYSBnaXZlbiBDb252ZXJzYXRpb24gSUQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIFVzZSBfbG9hZEFsbCBpZiBsb2FkaW5nIEFsbCBNZXNzYWdlcyByYXRoZXIgdGhhbiBhbGwgTWVzc2FnZXMgZm9yIGEgQ29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRNZXNzYWdlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udmVyc2F0aW9uSWQgLSBJRCBvZiB0aGUgQ29udmVyc2F0aW9uIHdob3NlIE1lc3NhZ2VzIGFyZSBvZiBpbnRlcmVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tSWQ9XSAgICAtIEZvciBwYWdpbmF0aW9uLCBwcm92aWRlIHRoZSBtZXNzYWdlSWQgdG8gZ2V0IE1lc3NhZ2VzIGFmdGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemU9XSAgLSBUbyBsaW1pdCB0aGUgbnVtYmVyIG9mIHJlc3VsdHMsIHByb3ZpZGUgYSBudW1iZXIgZm9yIGhvdyBtYW55IHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdICAgLSBDYWxsYmFjayBmb3IgZ2V0dGluZyByZXN1bHRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZVtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGxvYWRNZXNzYWdlcyhjb252ZXJzYXRpb25JZCwgZnJvbUlkLCBwYWdlU2l6ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXNbJ19wZXJtaXNzaW9uX21lc3NhZ2VzJ10gfHwgdGhpcy5faXNPcGVuRXJyb3IpIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZyb21NZXNzYWdlID0gZnJvbUlkID8gdGhpcy5jbGllbnQuZ2V0TWVzc2FnZShmcm9tSWQpIDogbnVsbDtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gd2luZG93LklEQktleVJhbmdlLmJvdW5kKFtjb252ZXJzYXRpb25JZCwgMF0sXG4gICAgICAgIFtjb252ZXJzYXRpb25JZCwgZnJvbU1lc3NhZ2UgPyBmcm9tTWVzc2FnZS5wb3NpdGlvbiA6IE1BWF9TQUZFX0lOVEVHRVJdKTtcbiAgICAgIHRoaXMuX2xvYWRCeUluZGV4KCdtZXNzYWdlcycsICdjb252ZXJzYXRpb25JZCcsIHF1ZXJ5LCBCb29sZWFuKGZyb21JZCksIHBhZ2VTaXplLCAoZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLl9sb2FkTWVzc2FnZXNSZXN1bHQoZGF0YSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gTm9vcCAtLSBoYW5kbGUgYnJvd3NlcnMgbGlrZSBJRSB0aGF0IGRvbid0IGxpa2UgdGhlc2UgSURCS2V5UmFuZ2VzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIEFubm91bmNlbWVudHMgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBtZXRob2QgbG9hZEFubm91bmNlbWVudHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tSWQ9XSAgICAtIEZvciBwYWdpbmF0aW9uLCBwcm92aWRlIHRoZSBtZXNzYWdlSWQgdG8gZ2V0IEFubm91bmNlbWVudHMgYWZ0ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZT1dICAtIFRvIGxpbWl0IHRoZSBudW1iZXIgb2YgcmVzdWx0cywgcHJvdmlkZSBhIG51bWJlciBmb3IgaG93IG1hbnkgcmVzdWx0cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICogQHBhcmFtIHtsYXllci5Bbm5vdW5jZW1lbnRbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBsb2FkQW5ub3VuY2VtZW50cyhmcm9tSWQsIHBhZ2VTaXplLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpc1snX3Blcm1pc3Npb25fbWVzc2FnZXMnXSB8fCB0aGlzLl9pc09wZW5FcnJvcikgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBmcm9tSWQgPyB0aGlzLmNsaWVudC5nZXRNZXNzYWdlKGZyb21JZCkgOiBudWxsO1xuICAgICAgY29uc3QgcXVlcnkgPSB3aW5kb3cuSURCS2V5UmFuZ2UuYm91bmQoWydhbm5vdW5jZW1lbnQnLCAwXSxcbiAgICAgICAgWydhbm5vdW5jZW1lbnQnLCBmcm9tTWVzc2FnZSA/IGZyb21NZXNzYWdlLnBvc2l0aW9uIDogTUFYX1NBRkVfSU5URUdFUl0pO1xuICAgICAgdGhpcy5fbG9hZEJ5SW5kZXgoJ21lc3NhZ2VzJywgJ2NvbnZlcnNhdGlvbklkJywgcXVlcnksIEJvb2xlYW4oZnJvbUlkKSwgcGFnZVNpemUsIChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvYWRNZXNzYWdlc1Jlc3VsdChkYXRhLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBOb29wIC0tIGhhbmRsZSBicm93c2VycyBsaWtlIElFIHRoYXQgZG9uJ3QgbGlrZSB0aGVzZSBJREJLZXlSYW5nZXNcbiAgICB9XG4gIH1cblxuICBfYmxvYmlmeVBhcnQocGFydCkge1xuICAgIGlmIChwYXJ0LnVzZUJsb2IpIHtcbiAgICAgIHBhcnQuYm9keSA9IFV0aWwuYmFzZTY0VG9CbG9iKHBhcnQuYm9keSk7XG4gICAgICBkZWxldGUgcGFydC51c2VCbG9iO1xuICAgICAgcGFydC5lbmNvZGluZyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbmQgc29ydHMgdGhlIG1lc3NhZ2Ugb2JqZWN0cyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogVE9ETzogRW5jb2RlIGxpbWl0cyBvbiB0aGlzLCBlbHNlIHdlIGFyZSBzb3J0aW5nIHRlbnMgb2YgdGhvdXNhbmRzXG4gICAqIG9mIG1lc3NhZ2VzIGluIGphdmFzY3JpcHQuXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRNZXNzYWdlc1Jlc3VsdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBNZXNzYWdlIG9iamVjdHMgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gY2FsbGJhY2sucmVzdWx0IC0gTWVzc2FnZSBpbnN0YW5jZXMgY3JlYXRlZCBmcm9tIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgX2xvYWRNZXNzYWdlc1Jlc3VsdChtZXNzYWdlcywgY2FsbGJhY2spIHtcbiAgICAvLyBDb252ZXJ0IGJhc2U2NCB0byBibG9iIGJlZm9yZSBzZW5kaW5nIGl0IGFsb25nLi4uXG4gICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IG1lc3NhZ2UucGFydHMuZm9yRWFjaChwYXJ0ID0+IHRoaXMuX2Jsb2JpZnlQYXJ0KHBhcnQpKSk7XG5cbiAgICAvLyBJbnN0YW50aWF0ZSBhbmQgUmVnaXN0ZXIgZWFjaCBNZXNzYWdlXG4gICAgY29uc3QgbmV3RGF0YSA9IG1lc3NhZ2VzXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gdGhpcy5fY3JlYXRlTWVzc2FnZShtZXNzYWdlKSB8fCB0aGlzLmNsaWVudC5nZXRNZXNzYWdlKG1lc3NhZ2UuaWQpKVxuICAgICAgLmZpbHRlcihtZXNzYWdlID0+IG1lc3NhZ2UpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHRzXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhuZXdEYXRhKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIElkZW50aXRpZXMgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBtZXRob2QgbG9hZElkZW50aXRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5JZGVudGl0eVtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGxvYWRJZGVudGl0aWVzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9hZEFsbCgnaWRlbnRpdGllcycsIChkYXRhKSA9PiB7XG4gICAgICB0aGlzLl9sb2FkSWRlbnRpdGllc1Jlc3VsdChkYXRhLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUgYWxsIExhc3RNZXNzYWdlcyBhbmQgSWRlbnRpdHl5IFBPSk9zIGludG8gbGF5ZXIuTWVzc2FnZSBhbmQgbGF5ZXIuSWRlbnRpdHl5IGluc3RhbmNlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZElkZW50aXRpZXNSZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gaWRlbnRpdGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLklkZW50aXR5W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRJZGVudGl0aWVzUmVzdWx0KGlkZW50aXRpZXMsIGNhbGxiYWNrKSB7XG4gICAgLy8gSW5zdGFudGlhdGUgYW5kIFJlZ2lzdGVyIGVhY2ggSWRlbnRpdHkuXG4gICAgY29uc3QgbmV3RGF0YSA9IGlkZW50aXRpZXNcbiAgICAgIC5tYXAoaWRlbnRpdHkgPT4gdGhpcy5fY3JlYXRlSWRlbnRpdHkoaWRlbnRpdHkpIHx8IHRoaXMuY2xpZW50LmdldElkZW50aXR5KGlkZW50aXR5LmlkKSlcbiAgICAgIC5maWx0ZXIoaWRlbnRpdHkgPT4gaWRlbnRpdHkpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBkYXRhXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhuZXdEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhbmQgUmVnaXN0ZXIgdGhlIENvbnZlcnNhdGlvbiBmcm9tIGEgY29udmVyc2F0aW9uIERCIEVudHJ5LlxuICAgKlxuICAgKiBJZiB0aGUgbGF5ZXIuQ29udmVyc2F0aW9uIGFscmVhZHkgZXhpc3RzLCB0aGVuIGl0cyBwcmVzdW1lZCB0aGF0IHdoYXRldmVyIGlzIGluXG4gICAqIGphdmFzY3JpcHQgY2FjaGUgaXMgbW9yZSB1cCB0byBkYXRlIHRoYW4gd2hhdHMgaW4gSW5kZXhlZERCIGNhY2hlLlxuICAgKlxuICAgKiBBdHRlbXB0cyB0byBhc3NpZ24gdGhlIGxhc3RNZXNzYWdlIHByb3BlcnR5IHRvIHJlZmVyIHRvIGFwcHJvcHJpYXRlIE1lc3NhZ2UuICBJZiBpdCBmYWlscyxcbiAgICogaXQgd2lsbCBiZSBzZXQgdG8gbnVsbC5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlQ29udmVyc2F0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb252ZXJzYXRpb25cbiAgICogQHJldHVybnMge2xheWVyLkNvbnZlcnNhdGlvbn1cbiAgICovXG4gIF9jcmVhdGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudC5nZXRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uLmlkKSkge1xuICAgICAgY29udmVyc2F0aW9uLl9mcm9tREIgPSB0cnVlO1xuICAgICAgY29uc3QgbmV3Q29udmVyc2F0aW9uID0gdGhpcy5jbGllbnQuX2NyZWF0ZU9iamVjdChjb252ZXJzYXRpb24pO1xuICAgICAgbmV3Q29udmVyc2F0aW9uLnN5bmNTdGF0ZSA9IGNvbnZlcnNhdGlvbi5zeW5jX3N0YXRlO1xuICAgICAgcmV0dXJuIG5ld0NvbnZlcnNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW5kIFJlZ2lzdGVyIHRoZSBDaGFubmVsIGZyb20gYSBDaGFubmVsIERCIEVudHJ5LlxuICAgKlxuICAgKiBJZiB0aGUgbGF5ZXIuQ2hhbm5lbCBhbHJlYWR5IGV4aXN0cywgdGhlbiBpdHMgcHJlc3VtZWQgdGhhdCB3aGF0ZXZlciBpcyBpblxuICAgKiBqYXZhc2NyaXB0IGNhY2hlIGlzIG1vcmUgdXAgdG8gZGF0ZSB0aGFuIHdoYXRzIGluIEluZGV4ZWREQiBjYWNoZS5cbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gYXNzaWduIHRoZSBsYXN0TWVzc2FnZSBwcm9wZXJ0eSB0byByZWZlciB0byBhcHByb3ByaWF0ZSBNZXNzYWdlLiAgSWYgaXQgZmFpbHMsXG4gICAqIGl0IHdpbGwgYmUgc2V0IHRvIG51bGwuXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZUNoYW5uZWxcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5uZWxcbiAgICogQHJldHVybnMge2xheWVyLkNoYW5uZWx9XG4gICAqL1xuICBfY3JlYXRlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudC5nZXRDaGFubmVsKGNoYW5uZWwuaWQpKSB7XG4gICAgICBjaGFubmVsLl9mcm9tREIgPSB0cnVlO1xuICAgICAgY29uc3QgbmV3Q2hhbm5lbCA9IHRoaXMuY2xpZW50Ll9jcmVhdGVPYmplY3QoY2hhbm5lbCk7XG4gICAgICBuZXdDaGFubmVsLnN5bmNTdGF0ZSA9IGNoYW5uZWwuc3luY19zdGF0ZTtcbiAgICAgIHJldHVybiBuZXdDaGFubmVsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhbmQgUmVnaXN0ZXIgdGhlIE1lc3NhZ2UgZnJvbSBhIG1lc3NhZ2UgREIgRW50cnkuXG4gICAqXG4gICAqIElmIHRoZSBsYXllci5NZXNzYWdlIGFscmVhZHkgZXhpc3RzLCB0aGVuIGl0cyBwcmVzdW1lZCB0aGF0IHdoYXRldmVyIGlzIGluXG4gICAqIGphdmFzY3JpcHQgY2FjaGUgaXMgbW9yZSB1cCB0byBkYXRlIHRoYW4gd2hhdHMgaW4gSW5kZXhlZERCIGNhY2hlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVNZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtsYXllci5NZXNzYWdlfVxuICAgKi9cbiAgX2NyZWF0ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jbGllbnQuZ2V0TWVzc2FnZShtZXNzYWdlLmlkKSkge1xuICAgICAgbWVzc2FnZS5fZnJvbURCID0gdHJ1ZTtcbiAgICAgIGlmIChtZXNzYWdlLmNvbnZlcnNhdGlvbklkLmluZGV4T2YoJ2xheWVyOi8vL2NvbnZlcnNhdGlvbnMnKSkge1xuICAgICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9IHtcbiAgICAgICAgICBpZDogbWVzc2FnZS5jb252ZXJzYXRpb25JZCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25JZC5pbmRleE9mKCdsYXllcjovLy9jaGFubmVscycpKSB7XG4gICAgICAgIG1lc3NhZ2UuY2hhbm5lbCA9IHtcbiAgICAgICAgICBpZDogbWVzc2FnZS5jb252ZXJzYXRpb25JZCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBtZXNzYWdlLmNvbnZlcnNhdGlvbklkO1xuICAgICAgY29uc3QgbmV3TWVzc2FnZSA9IHRoaXMuY2xpZW50Ll9jcmVhdGVPYmplY3QobWVzc2FnZSk7XG4gICAgICBuZXdNZXNzYWdlLnN5bmNTdGF0ZSA9IG1lc3NhZ2Uuc3luY19zdGF0ZTtcbiAgICAgIHJldHVybiBuZXdNZXNzYWdlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhbmQgUmVnaXN0ZXIgdGhlIElkZW50aXR5IGZyb20gYW4gaWRlbnRpdGllcyBEQiBFbnRyeS5cbiAgICpcbiAgICogSWYgdGhlIGxheWVyLklkZW50aXR5IGFscmVhZHkgZXhpc3RzLCB0aGVuIGl0cyBwcmVzdW1lZCB0aGF0IHdoYXRldmVyIGlzIGluXG4gICAqIGphdmFzY3JpcHQgY2FjaGUgaXMgbW9yZSB1cCB0byBkYXRlIHRoYW4gd2hhdHMgaW4gSW5kZXhlZERCIGNhY2hlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVJZGVudGl0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gaWRlbnRpdHlcbiAgICogQHJldHVybnMge2xheWVyLklkZW50aXR5fVxuICAgKi9cbiAgX2NyZWF0ZUlkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudC5nZXRJZGVudGl0eShpZGVudGl0eS5pZCkpIHtcbiAgICAgIGlkZW50aXR5Ll9mcm9tREIgPSB0cnVlO1xuICAgICAgY29uc3QgbmV3aWRlbnRpdHkgPSB0aGlzLmNsaWVudC5fY3JlYXRlT2JqZWN0KGlkZW50aXR5KTtcbiAgICAgIG5ld2lkZW50aXR5LnN5bmNTdGF0ZSA9IGlkZW50aXR5LnN5bmNfc3RhdGU7XG4gICAgICByZXR1cm4gbmV3aWRlbnRpdHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIFN5bmMgRXZlbnRzIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRTeW5jUXVldWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnRbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBsb2FkU3luY1F1ZXVlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9hZEFsbCgnc3luY1F1ZXVlJywgc3luY0V2ZW50cyA9PiB0aGlzLl9sb2FkU3luY0V2ZW50UmVsYXRlZERhdGEoc3luY0V2ZW50cywgY2FsbGJhY2spKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGF0IHdlIGhhdmUgYXBwcm9wcmlhdGUgZGF0YSBmb3IgZWFjaCBTeW5jRXZlbnQgYW5kIGluc3RhbnRpYXRlIGl0LlxuICAgKlxuICAgKiBBbnkgb3BlcmF0aW9uIHRoYXQgaXMgbm90IGEgREVMRVRFIG11c3QgaGF2ZSBhIHZhbGlkIHRhcmdldCBmb3VuZCBpbiB0aGUgZGF0YWJhc2Ugb3IgamF2YXNjcmlwdCBjYWNoZSxcbiAgICogb3RoZXJ3aXNlIGl0IGNhbiBub3QgYmUgZXhlY3V0ZWQuXG4gICAqXG4gICAqIFRPRE86IE5lZWQgdG8gY2xlYW51cCBzeW5jIGVudHJpZXMgdGhhdCBoYXZlIGludmFsaWQgdGFyZ2V0c1xuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkU3luY0V2ZW50UmVsYXRlZERhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gc3luY0V2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudFtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIF9sb2FkU3luY0V2ZW50UmVsYXRlZERhdGEoc3luY0V2ZW50cywgY2FsbGJhY2spIHtcbiAgICAvLyBHYXRoZXIgYWxsIE1lc3NhZ2UgSURzIHRoYXQgYXJlIHRhcmdldHMgb2Ygb3BlcmF0aW9ucy5cbiAgICBjb25zdCBtZXNzYWdlSWRzID0gc3luY0V2ZW50c1xuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0ub3BlcmF0aW9uICE9PSAnREVMRVRFJyAmJiBpdGVtLnRhcmdldCAmJiBpdGVtLnRhcmdldC5tYXRjaCgvbWVzc2FnZXMvKSlcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnRhcmdldCk7XG5cbiAgICAvLyBHYXRoZXIgYWxsIENvbnZlcnNhdGlvbiBJRHMgdGhhdCBhcmUgdGFyZ2V0cyBvZiBvcGVyYXRpb25zLlxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbklkcyA9IHN5bmNFdmVudHNcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLm9wZXJhdGlvbiAhPT0gJ0RFTEVURScgJiYgaXRlbS50YXJnZXQgJiYgaXRlbS50YXJnZXQubWF0Y2goL2NvbnZlcnNhdGlvbnMvKSlcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnRhcmdldCk7XG5cbiAgICBjb25zdCBpZGVudGl0eUlkcyA9IHN5bmNFdmVudHNcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLm9wZXJhdGlvbiAhPT0gJ0RFTEVURScgJiYgaXRlbS50YXJnZXQgJiYgaXRlbS50YXJnZXQubWF0Y2goL2lkZW50aXRpZXMvKSlcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLnRhcmdldCk7XG5cbiAgICAvLyBMb2FkIGFueSBNZXNzYWdlcy9Db252ZXJzYXRpb25zIHRoYXQgYXJlIHRhcmdldHMgb2Ygb3BlcmF0aW9ucy5cbiAgICAvLyBDYWxsIF9jcmVhdGVNZXNzYWdlIG9yIF9jcmVhdGVDb252ZXJzYXRpb24gb24gYWxsIHRhcmdldHMgZm91bmQuXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGNvbnN0IG1heENvdW50ZXIgPSAzO1xuICAgIHRoaXMuZ2V0T2JqZWN0cygnbWVzc2FnZXMnLCBtZXNzYWdlSWRzLCAobWVzc2FnZXMpID0+IHtcbiAgICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB0aGlzLl9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgIGNvdW50ZXIrKztcbiAgICAgIGlmIChjb3VudGVyID09PSBtYXhDb3VudGVyKSB0aGlzLl9sb2FkU3luY0V2ZW50UmVzdWx0cyhzeW5jRXZlbnRzLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5nZXRPYmplY3RzKCdjb252ZXJzYXRpb25zJywgY29udmVyc2F0aW9uSWRzLCAoY29udmVyc2F0aW9ucykgPT4ge1xuICAgICAgY29udmVyc2F0aW9ucy5mb3JFYWNoKGNvbnZlcnNhdGlvbiA9PiB0aGlzLl9jcmVhdGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSk7XG4gICAgICBjb3VudGVyKys7XG4gICAgICBpZiAoY291bnRlciA9PT0gbWF4Q291bnRlcikgdGhpcy5fbG9hZFN5bmNFdmVudFJlc3VsdHMoc3luY0V2ZW50cywgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0T2JqZWN0cygnaWRlbnRpdGllcycsIGlkZW50aXR5SWRzLCAoaWRlbnRpdGllcykgPT4ge1xuICAgICAgaWRlbnRpdGllcy5mb3JFYWNoKGlkZW50aXR5ID0+IHRoaXMuX2NyZWF0ZUlkZW50aXR5KGlkZW50aXR5KSk7XG4gICAgICBjb3VudGVyKys7XG4gICAgICBpZiAoY291bnRlciA9PT0gbWF4Q291bnRlcikgdGhpcy5fbG9hZFN5bmNFdmVudFJlc3VsdHMoc3luY0V2ZW50cywgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gYW4gYXJyYXkgb2YgU3luYyBFdmVudCBEQiBFbnRyaWVzIGludG8gYW4gYXJyYXkgb2YgbGF5ZXIuU3luY0V2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkU3luY0V2ZW50UmVzdWx0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBzeW5jRXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRTeW5jRXZlbnRSZXN1bHRzKHN5bmNFdmVudHMsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgdGhlIHRhcmdldCBpcyBwcmVzZW50IGluIHRoZSBzeW5jIGV2ZW50LCBidXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHN5c3RlbSxcbiAgICAvLyBkbyBOT1QgYXR0ZW1wdCB0byBpbnN0YW50aWF0ZSB0aGlzIGV2ZW50Li4uIHVubGVzcyBpdHMgYSBERUxFVEUgb3BlcmF0aW9uLlxuICAgIGNvbnN0IG5ld0RhdGEgPSBzeW5jRXZlbnRzXG4gICAgLmZpbHRlcigoc3luY0V2ZW50KSA9PiB7XG4gICAgICBjb25zdCBoYXNUYXJnZXQgPSBCb29sZWFuKHN5bmNFdmVudC50YXJnZXQgJiYgdGhpcy5jbGllbnQuZ2V0T2JqZWN0KHN5bmNFdmVudC50YXJnZXQpKTtcbiAgICAgIHJldHVybiBzeW5jRXZlbnQub3BlcmF0aW9uID09PSAnREVMRVRFJyB8fCBoYXNUYXJnZXQ7XG4gICAgfSlcbiAgICAubWFwKChzeW5jRXZlbnQpID0+IHtcbiAgICAgIGlmIChzeW5jRXZlbnQuaXNXZWJzb2NrZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW5jRXZlbnQuV2Vic29ja2V0U3luY0V2ZW50KHtcbiAgICAgICAgICB0YXJnZXQ6IHN5bmNFdmVudC50YXJnZXQsXG4gICAgICAgICAgZGVwZW5kczogc3luY0V2ZW50LmRlcGVuZHMsXG4gICAgICAgICAgb3BlcmF0aW9uOiBzeW5jRXZlbnQub3BlcmF0aW9uLFxuICAgICAgICAgIGlkOiBzeW5jRXZlbnQuaWQsXG4gICAgICAgICAgZGF0YTogc3luY0V2ZW50LmRhdGEsXG4gICAgICAgICAgZnJvbURCOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogc3luY0V2ZW50LmNyZWF0ZWRfYXQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW5jRXZlbnQuWEhSU3luY0V2ZW50KHtcbiAgICAgICAgICB0YXJnZXQ6IHN5bmNFdmVudC50YXJnZXQsXG4gICAgICAgICAgZGVwZW5kczogc3luY0V2ZW50LmRlcGVuZHMsXG4gICAgICAgICAgb3BlcmF0aW9uOiBzeW5jRXZlbnQub3BlcmF0aW9uLFxuICAgICAgICAgIGlkOiBzeW5jRXZlbnQuaWQsXG4gICAgICAgICAgZGF0YTogc3luY0V2ZW50LmRhdGEsXG4gICAgICAgICAgbWV0aG9kOiBzeW5jRXZlbnQubWV0aG9kLFxuICAgICAgICAgIGhlYWRlcnM6IHN5bmNFdmVudC5oZWFkZXJzLFxuICAgICAgICAgIHVybDogc3luY0V2ZW50LnVybCxcbiAgICAgICAgICBmcm9tREI6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBzeW5jRXZlbnQuY3JlYXRlZF9hdCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHRoZSByZXN1bHRzIGFuZCB0aGVuIHJldHVybiB0aGVtLlxuICAgIC8vIFRPRE86IFF1ZXJ5IHJlc3VsdHMgc2hvdWxkIGNvbWUgYmFjayBzb3J0ZWQgYnkgZGF0YWJhc2Ugd2l0aCBwcm9wZXIgSW5kZXhcbiAgICBVdGlsLnNvcnRCeShuZXdEYXRhLCBpdGVtID0+IGl0ZW0uY3JlYXRlZEF0KTtcbiAgICBjYWxsYmFjayhuZXdEYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCB0YWJsZS5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZEFsbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBfbG9hZEFsbCh0YWJsZU5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzWydfcGVybWlzc2lvbl8nICsgdGFibGVOYW1lXSB8fCB0aGlzLl9pc09wZW5FcnJvcikgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0YWJsZU5hbWVdLCAncmVhZG9ubHknKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgZGF0YS5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIHRhYmxlIGFuZCB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggdmFsdWUuXG4gICAqXG4gICAqIFJlc3VsdHMgYXJlIGFsd2F5cyBzb3J0ZWQgaW4gREVTQyBvcmRlciBhdCB0aGlzIHRpbWUuXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRCeUluZGV4XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhYmxlTmFtZSAtICdtZXNzYWdlcycsICdjb252ZXJzYXRpb25zJywgJ2lkZW50aXRpZXMnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBxdWVyeSBvblxuICAgKiBAcGFyYW0ge0lEQktleVJhbmdlfSByYW5nZSAtIFJhbmdlIHRvIFF1ZXJ5IGZvciAobnVsbCBvaylcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0Zyb21JZCAtIElmIHF1ZXJ5aW5nIGZvciByZXN1bHRzIGFmdGVyIGEgc3BlY2lmaWVkIElELCB0aGVuIHdlIHdhbnQgdG8gc2tpcCB0aGUgZmlyc3QgcmVzdWx0ICh3aGljaCB3aWxsIGJlIHRoYXQgSUQpIChcIlwiIGlzIE9LKVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVNpemUgLSBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkLCByZXR1cm4gYXQgbW9zdCB0aGF0IG51bWJlciBvZiByZXN1bHRzOyBlbHNlIHJldHVybiBhbGwgcmVzdWx0cy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBfbG9hZEJ5SW5kZXgodGFibGVOYW1lLCBpbmRleE5hbWUsIHJhbmdlLCBpc0Zyb21JZCwgcGFnZVNpemUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzWydfcGVybWlzc2lvbl8nICsgdGFibGVOYW1lXSB8fCB0aGlzLl9pc09wZW5FcnJvcikgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICBsZXQgc2hvdWxkU2tpcE5leHQgPSBpc0Zyb21JZDtcbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0YWJsZU5hbWVdLCAncmVhZG9ubHknKVxuICAgICAgICAgIC5vYmplY3RTdG9yZSh0YWJsZU5hbWUpXG4gICAgICAgICAgLmluZGV4KGluZGV4TmFtZSlcbiAgICAgICAgICAub3BlbkN1cnNvcihyYW5nZSwgJ3ByZXYnKVxuICAgICAgICAgIC5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICBpZiAoc2hvdWxkU2tpcE5leHQpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRTa2lwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYWdlU2l6ZSAmJiBkYXRhLmxlbmd0aCA+PSBwYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCB0YWJsZS5cbiAgICpcbiAgICogQ3VycmVudGx5IHRha2VzIGFuIGFycmF5IG9mIGRhdGEgdG8gZGVsZXRlIHJhdGhlciB0aGFuIGFuIGFycmF5IG9mIElEcztcbiAgICogSWYgeW91IG9ubHkgaGF2ZSBhbiBJRCwgW3tpZDogbXlJZH1dIHNob3VsZCB3b3JrLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZU9iamVjdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIGRlbGV0ZU9iamVjdHModGFibGVOYW1lLCBkYXRhLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpc1snX3Blcm1pc3Npb25fJyArIHRhYmxlTmFtZV0gfHwgdGhpcy5faXNPcGVuRXJyb3IpIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKCkgOiBudWxsO1xuICAgIHRoaXMub25PcGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGFibGVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGNhbGxiYWNrO1xuICAgICAgZGF0YS5mb3JFYWNoKGl0ZW0gPT4gc3RvcmUuZGVsZXRlKGl0ZW0uaWQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgaWRlbnRpZmllZCBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCBkYXRhYmFzZSB0YWJsZS5cbiAgICpcbiAgICogVHVybmluZyB0aGVzZSBpbnRvIGluc3RhbmNlcyBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxlci5cbiAgICpcbiAgICogSW5zcGlyZWQgYnkgaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvNzQ0OTg2L0hvdy10by1kby1zb21lLW1hZ2ljLXdpdGgtaW5kZXhlZERCXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0T2JqZWN0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGlkc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGdldE9iamVjdHModGFibGVOYW1lLCBpZHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzWydfcGVybWlzc2lvbl8nICsgdGFibGVOYW1lXSB8fCB0aGlzLl9pc09wZW5FcnJvcikgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICBjb25zdCBkYXRhID0gW107XG5cbiAgICAvLyBHYXRoZXIsIHNvcnQsIGFuZCBmaWx0ZXIgcmVwbGljYSBJRHNcbiAgICBjb25zdCBzb3J0ZWRJZHMgPSBpZHMuc29ydCgpO1xuICAgIGZvciAobGV0IGkgPSBzb3J0ZWRJZHMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgaWYgKHNvcnRlZElkc1tpXSA9PT0gc29ydGVkSWRzW2kgLSAxXSkgc29ydGVkSWRzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdGFibGUgc2VhcmNoaW5nIGZvciB0aGUgc3BlY2lmaWVkIElEc1xuICAgIHRoaXMub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb24oW3RhYmxlTmFtZV0sICdyZWFkb25seScpXG4gICAgICAgIC5vYmplY3RTdG9yZSh0YWJsZU5hbWUpXG4gICAgICAgIC5vcGVuQ3Vyc29yKCkub25zdWNjZXNzID0gKGV2dCkgPT4ge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG5cbiAgICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICAgIHdoaWxlIChrZXkgPiBzb3J0ZWRJZHNbaW5kZXhdKSBpbmRleCsrO1xuXG4gICAgICAgICAgLy8gVGhlIGN1cnNvciBpcyBwb2ludGluZyBhdCBvbmUgb2Ygb3VyIElEcywgZ2V0IGl0IGFuZCBjaGVjayBuZXh0LlxuICAgICAgICAgIGlmIChrZXkgPT09IHNvcnRlZElkc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb25lIG9yIGNoZWNrIG5leHRcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHNvcnRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQpIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoc29ydGVkSWRzW2luZGV4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxpZmllZCBnZXRPYmplY3RzKCkgbWV0aG9kIHRoYXQgZ2V0cyBhIHNpbmdsZSBvYmplY3QsIGFuZCBhbHNvIGdldHMgaXRzIHJlbGF0ZWQgb2JqZWN0cy5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRPYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrLmRhdGFcbiAgICovXG4gIGdldE9iamVjdCh0YWJsZU5hbWUsIGlkLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpc1snX3Blcm1pc3Npb25fJyArIHRhYmxlTmFtZV0gfHwgdGhpcy5faXNPcGVuRXJyb3IpIHJldHVybiBjYWxsYmFjaygpO1xuXG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5kYi50cmFuc2FjdGlvbihbdGFibGVOYW1lXSwgJ3JlYWRvbmx5JylcbiAgICAgICAgLm9iamVjdFN0b3JlKHRhYmxlTmFtZSlcbiAgICAgICAgLm9wZW5DdXJzb3Iod2luZG93LklEQktleVJhbmdlLm9ubHkoaWQpKS5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgaWYgKCFjdXJzb3IpIHJldHVybiBjYWxsYmFjayhudWxsKTtcblxuICAgICAgICAgIHN3aXRjaCAodGFibGVOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgYmFzZTY0IHRvIGJsb2IgYmVmb3JlIHNlbmRpbmcgaXQgYWxvbmcuLi5cbiAgICAgICAgICAgICAgY3Vyc29yLnZhbHVlLnBhcnRzLmZvckVhY2gocGFydCA9PiB0aGlzLl9ibG9iaWZ5UGFydChwYXJ0KSk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnaWRlbnRpdGllcyc6XG4gICAgICAgICAgICBjYXNlICdjaGFubmVscyc6XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnY29udmVyc2F0aW9ucyc6XG4gICAgICAgICAgICAgIGlmIChjdXJzb3IudmFsdWUubGFzdF9tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmNsaWVudC5nZXRNZXNzYWdlKGN1cnNvci52YWx1ZS5sYXN0X21lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1lc3NhZ2VEYXRhKFtsYXN0TWVzc2FnZV0sIChtZXNzYWdlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IudmFsdWUubGFzdF9tZXNzYWdlID0gbWVzc2FnZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KCdtZXNzYWdlcycsIGN1cnNvci52YWx1ZS5sYXN0X21lc3NhZ2UsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci52YWx1ZS5sYXN0X21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsYWltIGEgU3luYyBFdmVudC5cbiAgICpcbiAgICogQSBzeW5jIGV2ZW50IGlzIGNsYWltZWQgYnkgbG9ja2luZyB0aGUgdGFibGUsICB2YWxpZGF0aW5nIHRoYXQgaXQgaXMgc3RpbGwgaW4gdGhlIHRhYmxlLi4uIGFuZCB0aGVuIGRlbGV0aW5nIGl0IGZyb20gdGhlIHRhYmxlLlxuICAgKlxuICAgKiBAbWV0aG9kIGNsYWltU3luY0V2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50fSBzeW5jRXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGNsYWltU3luY0V2ZW50KHN5bmNFdmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3Blcm1pc3Npb25fc3luY1F1ZXVlIHx8IHRoaXMuX2lzT3BlbkVycm9yKSByZXR1cm4gY2FsbGJhY2sodHJ1ZSk7XG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnc3luY1F1ZXVlJ10sICdyZWFkd3JpdGUnKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ3N5bmNRdWV1ZScpO1xuICAgICAgc3RvcmUuZ2V0KHN5bmNFdmVudC5pZCkub25zdWNjZXNzID0gZXZ0ID0+IGNhbGxiYWNrKEJvb2xlYW4oZXZ0LnRhcmdldC5yZXN1bHQpKTtcbiAgICAgIHN0b3JlLmRlbGV0ZShzeW5jRXZlbnQuaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgZGF0YSBmcm9tIGFsbCB0YWJsZXMuXG4gICAqXG4gICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIGxheWVyLkNsaWVudC5sb2dvdXQoKVxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZVRhYmxlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGxiYWNrXVxuICAgKi9cbiAgZGVsZXRlVGFibGVzKGNhbGxiYWNrID0gKCkgPT4ge30pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHdpbmRvdy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5fZ2V0RGJOYW1lKCkpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSByZXF1ZXN0Lm9uZXJyb3IgPSBjYWxsYmFjaztcbiAgICAgIGRlbGV0ZSB0aGlzLmRiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBkYXRhYmFzZScsIGUpO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7bGF5ZXIuQ2xpZW50fSBMYXllciBDbGllbnQgaW5zdGFuY2VcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSBpcyB0aGUgZGIgY29ubmVjdGlvbiBvcGVuXG4gKi9cbkRiTWFuYWdlci5wcm90b3R5cGUuaXNPcGVuID0gZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59IGlzIHRoZSBkYiBjb25uZWN0aW9uIHdpbGwgbm90IG9wZW5cbiAqIEBwcml2YXRlXG4gKi9cbkRiTWFuYWdlci5wcm90b3R5cGUuX2lzT3BlbkVycm9yID0gZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59IElzIHJlYWRpbmcvd3JpdGluZyBtZXNzYWdlcyBhbGxvd2VkP1xuICogQHByaXZhdGVcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5fcGVybWlzc2lvbl9tZXNzYWdlcyA9IGZhbHNlO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSBJcyByZWFkaW5nL3dyaXRpbmcgY29udmVyc2F0aW9ucyBhbGxvd2VkP1xuICogQHByaXZhdGVcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5fcGVybWlzc2lvbl9jb252ZXJzYXRpb25zID0gZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59IElzIHJlYWRpbmcvd3JpdGluZyBjaGFubmVscyBhbGxvd2VkP1xuICogQHByaXZhdGVcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5fcGVybWlzc2lvbl9jaGFubmVscyA9IGZhbHNlO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSBJcyByZWFkaW5nL3dyaXRpbmcgaWRlbnRpdGllcyBhbGxvd2VkP1xuICogQHByaXZhdGVcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5fcGVybWlzc2lvbl9pZGVudGl0aWVzID0gZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59IElzIHJlYWRpbmcvd3JpdGluZyB1bnNlbnQgc2VydmVyIHJlcXVlc3RzIGFsbG93ZWQ/XG4gKiBAcHJpdmF0ZVxuICovXG5EYk1hbmFnZXIucHJvdG90eXBlLl9wZXJtaXNzaW9uX3N5bmNRdWV1ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEB0eXBlIElEQkRhdGFiYXNlXG4gKi9cbkRiTWFuYWdlci5wcm90b3R5cGUuZGIgPSBudWxsO1xuXG4vKipcbiAqIFJpY2ggQ29udGVudCBtYXkgYmUgd3JpdHRlbiB0byBpbmRleGVkZGIgYW5kIHBlcnNpc3RlZC4uLiBpZiBpdHMgc2l6ZSBpcyBsZXNzIHRoYW4gdGhpcyBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogVGhpcyB2YWx1ZSBjYW4gYmUgY3VzdG9taXplZDsgdGhpcyBleGFtcGxlIG9ubHkgd3JpdGVzIFJpY2ggQ29udGVudCB0aGF0IGlzIGxlc3MgdGhhbiA1MDAwIGJ5dGVzXG4gKlxuICogICAgbGF5ZXIuRGJNYW5hZ2VyLk1heFBhcnRTaXplID0gNTAwMDtcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5EYk1hbmFnZXIuTWF4UGFydFNpemUgPSAyNTAwMDA7XG5cbkRiTWFuYWdlci5fc3VwcG9ydGVkRXZlbnRzID0gW1xuICAnb3BlbicsICdlcnJvcicsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShEYk1hbmFnZXIsIFtEYk1hbmFnZXIsICdEYk1hbmFnZXInXSk7XG5tb2R1bGUuZXhwb3J0cyA9IERiTWFuYWdlcjtcbiJdfQ==
